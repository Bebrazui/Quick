"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/nostr.ts":
/*!**************************!*\
  !*** ./src/lib/nostr.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_RELAYS: function() { return /* binding */ DEFAULT_RELAYS; },\n/* harmony export */   nostrClient: function() { return /* binding */ nostrClient; }\n/* harmony export */ });\n/* harmony import */ var nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools/pure */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/pure.js\");\n/* harmony import */ var nostr_tools_nip04__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nostr-tools/nip04 */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/nip04.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _chunkStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunkStore */ \"(app-pages-browser)/./src/lib/chunkStore.ts\");\n\n\n\n\nconst DEFAULT_RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://nos.lol\",\n    \"wss://relay.snort.social\",\n    \"wss://relay.primal.net\",\n    \"wss://purplepag.es\",\n    \"wss://nostr.mom\",\n    \"wss://relay.nostr.bg\"\n];\nclass NostrClient {\n    get publicKey() {\n        return this._pk;\n    }\n    get privateKeyHex() {\n        return this._sk ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(this._sk) : \"\";\n    }\n    get relays() {\n        return [\n            ...this._relays\n        ];\n    }\n    get channels() {\n        return [\n            ...this._channels\n        ];\n    }\n    get sk() {\n        return this._sk;\n    }\n    getRelayStatus(relay) {\n        return this.relayStatus.get(relay) || \"disconnected\";\n    }\n    get connectedRelayCount() {\n        let c = 0;\n        this.relayStatus.forEach((s)=>{\n            if (s === \"connected\") {\n                c++;\n            }\n        });\n        return c;\n    }\n    generateKeys() {\n        const sk = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n        const pk = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(sk);\n        return {\n            privateKey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(sk),\n            publicKey: pk\n        };\n    }\n    login(privateKeyHex) {\n        const sk = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(privateKeyHex);\n        const pk = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(sk);\n        this._sk = sk;\n        this._pk = pk;\n        this._stopped = false;\n        localStorage.setItem(\"nostr_sk\", privateKeyHex);\n        return pk;\n    }\n    logout() {\n        this._stopped = true;\n        this.disconnectAll();\n        this._sk = null;\n        this._pk = \"\";\n        localStorage.removeItem(\"nostr_sk\");\n        localStorage.removeItem(\"nostr_contacts\");\n    }\n    tryAutoLogin() {\n        const sk = localStorage.getItem(\"nostr_sk\");\n        if ((sk === null || sk === void 0 ? void 0 : sk.length) === 64) {\n            try {\n                this.login(sk);\n                return true;\n            } catch (e) {\n                localStorage.removeItem(\"nostr_sk\");\n            }\n        }\n        return false;\n    }\n    onMessage(cb) {\n        this.messageCallbacks.add(cb);\n        return ()=>{\n            this.messageCallbacks.delete(cb);\n        };\n    }\n    onChannel(cb) {\n        this.channelCallbacks.add(cb);\n        return ()=>{\n            this.channelCallbacks.delete(cb);\n        };\n    }\n    onChannelMessage(cb) {\n        this.channelMessageCallbacks.add(cb);\n        return ()=>{\n            this.channelMessageCallbacks.delete(cb);\n        };\n    }\n    onProfile(cb) {\n        this.profileCallbacks.add(cb);\n        return ()=>{\n            this.profileCallbacks.delete(cb);\n        };\n    }\n    onConnection(cb) {\n        this.connectionCallbacks.add(cb);\n        return ()=>{\n            this.connectionCallbacks.delete(cb);\n        };\n    }\n    onSignal(cb) {\n        this.signalCallbacks.add(cb);\n        return ()=>{\n            this.signalCallbacks.delete(cb);\n        };\n    }\n    async connectToRelays() {\n        for (const r of this._relays)this.connectToRelay(r);\n    }\n    setChannels(channelIds) {\n        this._channels = [\n            ...new Set(channelIds.filter(Boolean))\n        ];\n        for (const [relay, ws] of this.sockets){\n            if (ws.readyState === WebSocket.OPEN) this.subscribeToChannels(relay);\n        }\n    }\n    connectToRelay(url) {\n        if (this._stopped) return;\n        if (this.sockets.has(url)) {\n            const e = this.sockets.get(url);\n            if (e.readyState === WebSocket.OPEN || e.readyState === WebSocket.CONNECTING) return;\n        }\n        this.relayStatus.set(url, \"connecting\");\n        this.connectionCallbacks.forEach((cb)=>cb(url, \"disconnected\"));\n        try {\n            const ws = new WebSocket(url);\n            const ct = setTimeout(()=>{\n                if (ws.readyState !== WebSocket.OPEN) ws.close();\n            }, 8000);\n            this.sockets.set(url, ws);\n            ws.onopen = ()=>{\n                clearTimeout(ct);\n                this.reconnectAttempts.set(url, 0);\n                this.relayStatus.set(url, \"connected\");\n                this.connectionCallbacks.forEach((cb)=>cb(url, \"connected\"));\n                this.subscribeToMessages(url);\n            };\n            ws.onclose = ()=>{\n                clearTimeout(ct);\n                this.relayStatus.set(url, \"disconnected\");\n                this.connectionCallbacks.forEach((cb)=>cb(url, \"disconnected\"));\n                this.sockets.delete(url);\n                this.scheduleReconnect(url);\n            };\n            ws.onerror = ()=>{\n                this.relayStatus.set(url, \"error\");\n                this.connectionCallbacks.forEach((cb)=>cb(url, \"error\"));\n            };\n            ws.onmessage = (e)=>{\n                try {\n                    this.handleRelayMessage(JSON.parse(e.data));\n                } catch (e) {}\n            };\n        } catch (e) {\n            this.relayStatus.set(url, \"error\");\n            this.scheduleReconnect(url);\n        }\n    }\n    scheduleReconnect(url) {\n        if (this._stopped) return;\n        const e = this.reconnectTimers.get(url);\n        if (e) clearTimeout(e);\n        const a = this.reconnectAttempts.get(url) || 0;\n        const d = Math.min(3000 * Math.pow(2, a), 60000);\n        this.reconnectAttempts.set(url, a + 1);\n        this.reconnectTimers.set(url, setTimeout(()=>{\n            if (!this._stopped && this._sk) this.connectToRelay(url);\n        }, d));\n    }\n    handleRelayMessage(data) {\n        if (!Array.isArray(data)) return;\n        if (data[0] === \"EVENT\") {\n            const ev = data[2];\n            if (!ev || this.seenEvents.has(ev.id)) return;\n            this.seenEvents.add(ev.id);\n            if (ev.kind === 4) this.handleEncryptedDM(ev);\n            else if (ev.kind === 0) this.handleProfileEvent(ev);\n            else if (ev.kind === 40) this.handleChannelEvent(ev);\n            else if (ev.kind === 42) this.handleChannelMessageEvent(ev);\n        }\n    }\n    async handleEncryptedDM(event) {\n        if (!this._sk) return;\n        const pTag = event.tags.find((t)=>t[0] === \"p\");\n        if (!pTag) return;\n        const isForMe = pTag[1] === this._pk, isFromMe = event.pubkey === this._pk;\n        if (!isForMe && !isFromMe) return;\n        const other = isFromMe ? pTag[1] : event.pubkey;\n        try {\n            const dec = await (0,nostr_tools_nip04__WEBPACK_IMPORTED_MODULE_3__.decrypt)(this._sk, other, event.content);\n            try {\n                const p = JSON.parse(dec);\n                if (p === null || p === void 0 ? void 0 : p._nostr_msg_type) {\n                    const mt = p._nostr_msg_type;\n                    if (mt === \"text\") {\n                        this.messageCallbacks.forEach((cb)=>cb({\n                                id: event.id,\n                                from: event.pubkey,\n                                to: pTag[1],\n                                content: p.text || \"\",\n                                timestamp: event.created_at * 1000,\n                                msgType: \"text\",\n                                replyTo: p.replyTo\n                            }));\n                        return;\n                    }\n                    if ([\n                        \"webrtc-offer\",\n                        \"webrtc-answer\",\n                        \"webrtc-ice\",\n                        \"call-request\",\n                        \"call-accept\",\n                        \"call-reject\",\n                        \"call-end\"\n                    ].includes(mt)) {\n                        this.signalCallbacks.forEach((cb)=>cb(event.pubkey, {\n                                type: mt,\n                                sdp: p.sdp,\n                                candidate: p.candidate,\n                                callType: p.callType,\n                                callId: p.callId\n                            }));\n                        return;\n                    }\n                    if (mt === \"file-chunk\") {\n                        this.handleFileChunk(event.id, event.pubkey, pTag[1], event.created_at * 1000, p);\n                        return;\n                    }\n                    if (mt === \"file-meta\") {\n                        const transferId = p.transferId || \"\";\n                        if (!transferId) return;\n                        const fileType = [\n                            \"image\",\n                            \"audio\"\n                        ].includes(p.fileType) ? p.fileType : \"file\";\n                        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.ensureTransfer)({\n                            transferId,\n                            fileName: p.fileName || \"file\",\n                            mimeType: p.mimeType || \"application/octet-stream\",\n                            fileType,\n                            size: p.size || 0,\n                            totalChunks: p.totalChunks || 0,\n                            text: p.text || \"\"\n                        });\n                        return;\n                    }\n                    if (mt === \"image\" || mt === \"file\" || mt === \"audio\") {\n                        this.messageCallbacks.forEach((cb)=>cb({\n                                id: event.id,\n                                from: event.pubkey,\n                                to: pTag[1],\n                                content: p.text || \"\",\n                                timestamp: event.created_at * 1000,\n                                msgType: mt,\n                                replyTo: p.replyTo,\n                                attachment: {\n                                    type: mt,\n                                    name: p.fileName || \"file\",\n                                    mimeType: p.mimeType || \"application/octet-stream\",\n                                    data: p.data || \"\",\n                                    size: p.size || 0\n                                }\n                            }));\n                        return;\n                    }\n                }\n            } catch (e) {}\n            this.messageCallbacks.forEach((cb)=>cb({\n                    id: event.id,\n                    from: event.pubkey,\n                    to: pTag[1],\n                    content: dec,\n                    timestamp: event.created_at * 1000,\n                    msgType: \"text\"\n                }));\n        } catch (e) {}\n    }\n    async handleFileChunk(eventId, from, to, timestamp, p) {\n        const transferId = p.transferId;\n        const chunkIndex = p.chunkIndex;\n        const totalChunks = p.totalChunks;\n        const data = p.data;\n        if (!transferId || typeof chunkIndex !== \"number\" || typeof totalChunks !== \"number\" || typeof data !== \"string\") return;\n        const fileType = [\n            \"image\",\n            \"audio\"\n        ].includes(p.fileType) ? p.fileType : \"file\";\n        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.ensureTransfer)({\n            transferId,\n            fileName: p.fileName || \"file\",\n            mimeType: p.mimeType || \"application/octet-stream\",\n            fileType,\n            size: p.size || 0,\n            totalChunks,\n            text: p.text || \"\"\n        });\n        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.storeChunk)(transferId, chunkIndex, totalChunks, data);\n        const done = await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.isTransferComplete)(transferId);\n        if (!done) return;\n        this.messageCallbacks.forEach((cb)=>cb({\n                id: \"\".concat(eventId, \"-assembled-\").concat(transferId),\n                from,\n                to,\n                content: p.text || \"\",\n                timestamp,\n                msgType: fileType,\n                replyTo: p.replyTo,\n                attachment: {\n                    type: fileType,\n                    name: p.fileName || \"file\",\n                    mimeType: p.mimeType || \"application/octet-stream\",\n                    data: \"\",\n                    size: p.size || 0,\n                    transferId,\n                    totalChunks,\n                    chunked: true\n                }\n            }));\n    }\n    handleProfileEvent(event) {\n        try {\n            const p = JSON.parse(event.content);\n            this.profileCache.set(event.pubkey, p);\n            this.pendingProfiles.delete(event.pubkey);\n            this.profileCallbacks.forEach((cb)=>cb(event.pubkey, p));\n        } catch (e) {}\n    }\n    handleChannelEvent(event) {\n        try {\n            var _payload_name;\n            const payload = JSON.parse(event.content);\n            const channel = {\n                id: event.id,\n                name: ((_payload_name = payload.name) === null || _payload_name === void 0 ? void 0 : _payload_name.trim()) || \"channel-\".concat(event.id.slice(0, 8)),\n                about: payload.about,\n                createdBy: event.pubkey,\n                createdAt: event.created_at * 1000\n            };\n            this.channelCallbacks.forEach((cb)=>cb(channel));\n        } catch (e) {}\n    }\n    handleChannelMessageEvent(event) {\n        var _event_tags_find;\n        const eTag = (_event_tags_find = event.tags.find((t)=>t[0] === \"e\")) === null || _event_tags_find === void 0 ? void 0 : _event_tags_find[1];\n        if (!eTag) return;\n        try {\n            const payload = JSON.parse(event.content);\n            this.channelMessageCallbacks.forEach((cb)=>cb({\n                    id: event.id,\n                    from: event.pubkey,\n                    to: \"\",\n                    content: payload.text || \"\",\n                    timestamp: event.created_at * 1000,\n                    msgType: \"channel\",\n                    channelId: eTag,\n                    replyTo: payload.replyTo\n                }));\n        } catch (e) {\n            this.channelMessageCallbacks.forEach((cb)=>cb({\n                    id: event.id,\n                    from: event.pubkey,\n                    to: \"\",\n                    content: event.content || \"\",\n                    timestamp: event.created_at * 1000,\n                    msgType: \"channel\",\n                    channelId: eTag\n                }));\n        }\n    }\n    subscribeToMessages(relayUrl) {\n        if (!this._pk) return;\n        const ws = this.sockets.get(relayUrl);\n        if (!ws || ws.readyState !== WebSocket.OPEN) return;\n        const subId = \"dm-\" + Math.random().toString(36).slice(2, 8);\n        const since = Math.floor(Date.now() / 1000) - 86400 * 30;\n        ws.send(JSON.stringify([\n            \"REQ\",\n            subId,\n            {\n                kinds: [\n                    4\n                ],\n                \"#p\": [\n                    this._pk\n                ],\n                since\n            },\n            {\n                kinds: [\n                    4\n                ],\n                authors: [\n                    this._pk\n                ],\n                since\n            }\n        ]));\n        this.subscriptions.set(subId, {\n            filters: [],\n            relay: relayUrl\n        });\n        this.subscribeToChannels(relayUrl);\n    }\n    subscribeToChannels(relayUrl) {\n        const ws = this.sockets.get(relayUrl);\n        if (!ws || ws.readyState !== WebSocket.OPEN) return;\n        if (this._channels.length === 0) return; // Do not subscribe to global channels\n        const subId = \"ch-\" + Math.random().toString(36).slice(2, 8);\n        const since = Math.floor(Date.now() / 1000) - 86400 * 30;\n        // Only subscribe to channels the user has joined\n        ws.send(JSON.stringify([\n            \"REQ\",\n            subId,\n            {\n                kinds: [\n                    40\n                ],\n                ids: this._channels,\n                since\n            },\n            {\n                kinds: [\n                    42\n                ],\n                \"#e\": this._channels,\n                since\n            }\n        ]));\n        this.subscriptions.set(subId, {\n            filters: [],\n            relay: relayUrl\n        });\n    }\n    async sendEncryptedPayload(recipientPubkey, payload) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const encrypted = await (0,nostr_tools_nip04__WEBPACK_IMPORTED_MODULE_3__.encrypt)(this._sk, recipientPubkey, payload);\n        const ev = {\n            kind: 4,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [\n                [\n                    \"p\",\n                    recipientPubkey\n                ]\n            ],\n            content: encrypted,\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        this.seenEvents.add(event.id);\n        const json = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        const open = [];\n        for (const [, ws] of this.sockets)if (ws.readyState === WebSocket.OPEN) open.push(ws);\n        if (!open.length) throw new Error(\"No connected relays\");\n        open.forEach((ws)=>{\n            try {\n                ws.send(json);\n            } catch (e) {}\n        });\n        return event.id;\n    }\n    bytesToBase64(bytes) {\n        let bin = \"\";\n        const step = 0x8000;\n        for(let i = 0; i < bytes.length; i += step){\n            bin += String.fromCharCode(...bytes.subarray(i, i + step));\n        }\n        return btoa(bin);\n    }\n    async sendDirectMessage(recipientPubkey, content, replyTo) {\n        const payload = replyTo ? JSON.stringify({\n            _nostr_msg_type: \"text\",\n            text: content,\n            replyTo\n        }) : content;\n        const id = await this.sendEncryptedPayload(recipientPubkey, payload);\n        return {\n            id,\n            from: this._pk,\n            to: recipientPubkey,\n            content,\n            timestamp: Date.now(),\n            msgType: \"text\",\n            replyTo\n        };\n    }\n    async sendAttachment(recipientPubkey, attachment, text, onProgress, replyTo) {\n        const maxSize = 2 * 1024 * 1024 * 1024;\n        if (attachment.size > maxSize) throw new Error(\"File is too large. Max size is 2GB.\");\n        if (!attachment.file) {\n            const b64 = attachment.data;\n            if (b64.length < 40000) {\n                const id = await this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n                    _nostr_msg_type: attachment.type,\n                    fileName: attachment.name,\n                    mimeType: attachment.mimeType,\n                    data: b64,\n                    size: attachment.size,\n                    text: text || \"\",\n                    replyTo\n                }));\n                return {\n                    id,\n                    from: this._pk,\n                    to: recipientPubkey,\n                    content: text || \"\",\n                    timestamp: Date.now(),\n                    msgType: attachment.type,\n                    attachment,\n                    replyTo\n                };\n            }\n        }\n        const file = attachment.file;\n        const transferId = Math.random().toString(36).slice(2) + Date.now().toString(36);\n        const fileSize = file ? file.size : attachment.size;\n        const totalChunks = Math.ceil(fileSize / NostrClient.CHUNK_SIZE);\n        let lastId = \"\";\n        let sent = 0;\n        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.ensureTransfer)({\n            transferId,\n            fileName: attachment.name,\n            mimeType: attachment.mimeType,\n            fileType: attachment.type,\n            size: fileSize,\n            totalChunks,\n            text: text || \"\"\n        });\n        await this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n            _nostr_msg_type: \"file-meta\",\n            transferId,\n            totalChunks,\n            fileName: attachment.name,\n            mimeType: attachment.mimeType,\n            size: fileSize,\n            text: text || \"\",\n            fileType: attachment.type,\n            replyTo\n        }));\n        for(let batch = 0; batch < totalChunks; batch += NostrClient.PARALLEL){\n            const promises = [];\n            const localChunks = [];\n            for(let j = 0; j < NostrClient.PARALLEL && batch + j < totalChunks; j++){\n                const i = batch + j;\n                let chunkData;\n                if (file) {\n                    const start = i * NostrClient.CHUNK_SIZE;\n                    const end = Math.min(start + NostrClient.CHUNK_SIZE, fileSize);\n                    const bytes = new Uint8Array(await file.slice(start, end).arrayBuffer());\n                    chunkData = this.bytesToBase64(bytes);\n                } else {\n                    const base64ChunkSize = Math.floor(NostrClient.CHUNK_SIZE / 3 * 4);\n                    chunkData = attachment.data.slice(i * base64ChunkSize, (i + 1) * base64ChunkSize);\n                }\n                localChunks.push({\n                    i,\n                    data: chunkData\n                });\n                promises.push(this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n                    _nostr_msg_type: \"file-chunk\",\n                    transferId,\n                    chunkIndex: i,\n                    totalChunks,\n                    data: chunkData,\n                    fileName: attachment.name,\n                    mimeType: attachment.mimeType,\n                    size: fileSize,\n                    text: text || \"\",\n                    fileType: attachment.type,\n                    replyTo\n                })));\n            }\n            const ids = await Promise.all(promises);\n            lastId = ids[ids.length - 1] || lastId;\n            for (const chunk of localChunks){\n                await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.storeChunk)(transferId, chunk.i, totalChunks, chunk.data);\n            }\n            sent += promises.length;\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(sent, totalChunks);\n            if (sent < totalChunks) await new Promise((r)=>setTimeout(r, 50));\n        }\n        return {\n            id: lastId || \"local-\".concat(transferId),\n            from: this._pk,\n            to: recipientPubkey,\n            content: text || \"\",\n            timestamp: Date.now(),\n            msgType: attachment.type,\n            replyTo,\n            attachment: {\n                ...attachment,\n                data: attachment.file ? \"\" : attachment.data,\n                transferId,\n                totalChunks,\n                chunked: true\n            }\n        };\n    }\n    async sendWebRTCSignal(recipientPubkey, signal) {\n        await this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n            _nostr_msg_type: signal.type,\n            sdp: signal.sdp,\n            candidate: signal.candidate,\n            callType: signal.callType,\n            callId: signal.callId\n        }));\n    }\n    async createChannel(name, about) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const ev = {\n            kind: 40,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [],\n            content: JSON.stringify({\n                name,\n                about: about || \"\"\n            }),\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        const payload = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        for (const [, ws] of this.sockets)if (ws.readyState === WebSocket.OPEN) try {\n            ws.send(payload);\n        } catch (e) {}\n        const channel = {\n            id: event.id,\n            name,\n            about,\n            createdBy: this._pk,\n            createdAt: Date.now()\n        };\n        this.channelCallbacks.forEach((cb)=>cb(channel));\n        return channel;\n    }\n    async sendChannelMessage(channelId, text, replyTo) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const ev = {\n            kind: 42,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [\n                [\n                    \"e\",\n                    channelId,\n                    \"\",\n                    \"root\"\n                ]\n            ],\n            content: JSON.stringify({\n                text,\n                replyTo\n            }),\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        const payload = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        let sent = false;\n        for (const [, ws] of this.sockets){\n            if (ws.readyState !== WebSocket.OPEN) continue;\n            sent = true;\n            try {\n                ws.send(payload);\n            } catch (e) {}\n        }\n        if (!sent) throw new Error(\"No connected relays\");\n        return {\n            id: event.id,\n            from: this._pk,\n            to: \"\",\n            content: text,\n            timestamp: Date.now(),\n            msgType: \"channel\",\n            channelId,\n            replyTo\n        };\n    }\n    requestProfile(pubkey) {\n        if (this.profileCache.has(pubkey)) return this.profileCache.get(pubkey);\n        if (this.pendingProfiles.has(pubkey)) return null;\n        this.pendingProfiles.add(pubkey);\n        const subId = \"p-\" + Math.random().toString(36).slice(2, 8);\n        for (const [, ws] of this.sockets){\n            if (ws.readyState === WebSocket.OPEN) {\n                ws.send(JSON.stringify([\n                    \"REQ\",\n                    subId,\n                    {\n                        kinds: [\n                            0\n                        ],\n                        authors: [\n                            pubkey\n                        ],\n                        limit: 1\n                    }\n                ]));\n                break;\n            }\n        }\n        return null;\n    }\n    getProfile(pubkey) {\n        return this.profileCache.get(pubkey) || null;\n    }\n    async updateProfile(profile) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const ev = {\n            kind: 0,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [],\n            content: JSON.stringify(profile),\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        const json = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        for (const [, ws] of this.sockets)if (ws.readyState === WebSocket.OPEN) try {\n            ws.send(json);\n        } catch (e) {}\n        this.profileCache.set(this._pk, profile);\n    }\n    disconnectAll() {\n        for (const [, t] of this.reconnectTimers)clearTimeout(t);\n        this.reconnectTimers.clear();\n        this.reconnectAttempts.clear();\n        for (const [, ws] of this.sockets)ws.close();\n        this.sockets.clear();\n        this.subscriptions.clear();\n        this.relayStatus.clear();\n    }\n    addRelay(url) {\n        if (!this._relays.includes(url)) {\n            this._relays.push(url);\n            this.connectToRelay(url);\n        }\n    }\n    removeRelay(url) {\n        this._relays = this._relays.filter((r)=>r !== url);\n        const t = this.reconnectTimers.get(url);\n        if (t) {\n            clearTimeout(t);\n            this.reconnectTimers.delete(url);\n        }\n        this.reconnectAttempts.delete(url);\n        const ws = this.sockets.get(url);\n        if (ws) {\n            ws.close();\n            this.sockets.delete(url);\n        }\n        this.relayStatus.delete(url);\n    }\n    shortenKey(key) {\n        return !key || key.length < 16 ? key : key.slice(0, 8) + \"â€¦\" + key.slice(-8);\n    }\n    isValidHexKey(key) {\n        return /^[0-9a-fA-F]{64}$/.test(key);\n    }\n    constructor(){\n        this._sk = null;\n        this._pk = \"\";\n        this.sockets = new Map();\n        this.relayStatus = new Map();\n        this.subscriptions = new Map();\n        this.messageCallbacks = new Set();\n        this.channelCallbacks = new Set();\n        this.channelMessageCallbacks = new Set();\n        this.profileCallbacks = new Set();\n        this.connectionCallbacks = new Set();\n        this.signalCallbacks = new Set();\n        this.profileCache = new Map();\n        this.pendingProfiles = new Set();\n        this.seenEvents = new Set();\n        this._relays = [\n            ...DEFAULT_RELAYS\n        ];\n        this.reconnectAttempts = new Map();\n        this.reconnectTimers = new Map();\n        this._stopped = false;\n        this._channels = [];\n    }\n}\n// 256KB chunks, parallel send by 3\nNostrClient.CHUNK_SIZE = 262144;\nNostrClient.PARALLEL = 3;\nconst nostrClient = new NostrClient();\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbm9zdHIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNHO0FBQ2pEO0FBQ1E7QUFFaUI7QUFzRjlFLE1BQU1VLGlCQUFpQjtJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBaUJELE1BQU1DO0lBcUJKLElBQUlDLFlBQW9CO1FBQUUsT0FBTyxJQUFJLENBQUNDLEdBQUc7SUFBRTtJQUMzQyxJQUFJQyxnQkFBd0I7UUFBRSxPQUFPLElBQUksQ0FBQ0MsR0FBRyxHQUFHViwrREFBVUEsQ0FBQyxJQUFJLENBQUNVLEdBQUcsSUFBSTtJQUFJO0lBQzNFLElBQUlDLFNBQW1CO1FBQUUsT0FBTztlQUFJLElBQUksQ0FBQ0MsT0FBTztTQUFDO0lBQUU7SUFDbkQsSUFBSUMsV0FBcUI7UUFBRSxPQUFPO2VBQUksSUFBSSxDQUFDQyxTQUFTO1NBQUM7SUFBRTtJQUN2RCxJQUFJQyxLQUF3QjtRQUFFLE9BQU8sSUFBSSxDQUFDTCxHQUFHO0lBQUU7SUFFL0NNLGVBQWVDLEtBQWEsRUFBVTtRQUNwQyxPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxHQUFHLENBQUNGLFVBQVU7SUFDeEM7SUFFQSxJQUFJRyxzQkFBOEI7UUFDaEMsSUFBSUMsSUFBSTtRQUNSLElBQUksQ0FBQ0gsV0FBVyxDQUFDSSxPQUFPLENBQUMsQ0FBQ0M7WUFDeEIsSUFBSUEsTUFBTSxhQUFhO2dCQUNyQkY7WUFDRjtRQUNGO1FBQ0EsT0FBT0E7SUFDVDtJQUVBRyxlQUFlO1FBQ2IsTUFBTVQsS0FBS3BCLG1FQUFpQkE7UUFDNUIsTUFBTThCLEtBQUs3Qiw4REFBWUEsQ0FBQ21CO1FBQ3hCLE9BQU87WUFBRVcsWUFBWTFCLCtEQUFVQSxDQUFDZTtZQUFLUixXQUFXa0I7UUFBRztJQUNyRDtJQUVBRSxNQUFNbEIsYUFBcUIsRUFBVTtRQUNuQyxNQUFNTSxLQUFLZCwrREFBVUEsQ0FBQ1E7UUFDdEIsTUFBTWdCLEtBQUs3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RyxDQUFDK0M7UUFBTSxJQUFJTixJQUFJO1lBQUVBLEdBQUdhLEtBQUs7WUFBSSxJQUFJLENBQUNaLE9BQU8sQ0FBQ3BCLE1BQU0sQ0FBQ3lCO1FBQU07UUFDbEYsSUFBSSxDQUFDaEQsV0FBVyxDQUFDdUIsTUFBTSxDQUFDeUI7SUFDMUI7SUFFQTJKLFdBQVdDLEdBQVcsRUFBRTtRQUFFLE9BQU8sQ0FBRUEsT0FBT0EsSUFBSTFMLE1BQU0sR0FBRyxLQUFNMEwsTUFBTUEsSUFBSTNFLEtBQUssQ0FBQyxHQUFHLEtBQUssTUFBTTJFLElBQUkzRSxLQUFLLENBQUMsQ0FBQztJQUFJO0lBQzFHNEUsY0FBY0QsR0FBVyxFQUFFO1FBQUUsT0FBTyxvQkFBb0JFLElBQUksQ0FBQ0Y7SUFBTTs7YUFqaEIzRHBOLE1BQXlCO2FBQ3pCRixNQUFjO2FBQ2RxRCxVQUFrQyxJQUFJb0s7YUFDdEMvTSxjQUFrRixJQUFJK007YUFDdEY1RCxnQkFBbUUsSUFBSTREO2FBQ3ZFMUwsbUJBQXlDLElBQUlrQjthQUM3Q2QsbUJBQXlDLElBQUljO2FBQzdDWiwwQkFBdUQsSUFBSVk7YUFDM0RWLG1CQUF5QyxJQUFJVTthQUM3Q1Isc0JBQStDLElBQUlRO2FBQ25ETixrQkFBdUMsSUFBSU07YUFDM0NxRixlQUEwQyxJQUFJbUY7YUFDOUNsRixrQkFBK0IsSUFBSXRGO2FBQ25Dc0MsYUFBMEIsSUFBSXRDO2FBQzlCN0MsVUFBb0I7ZUFBSVA7U0FBZTthQUN2Q3VFLG9CQUF5QyxJQUFJcUo7YUFDN0MzSSxrQkFBOEQsSUFBSTJJO2FBQ2xFck0sV0FBVzthQUNYZCxZQUFzQixFQUFFOztBQWdnQmxDO0FBcE5FLG1DQUFtQztBQS9UL0JSLFlBZ1VXMEwsYUFBYTtBQWhVeEIxTCxZQWlVVzhMLFdBQVc7QUFvTnJCLE1BQU04QixjQUFjLElBQUk1TixjQUFjO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvbm9zdHIudHM/ZjhmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZW5lcmF0ZVNlY3JldEtleSwgZ2V0UHVibGljS2V5LCBmaW5hbGl6ZUV2ZW50LCB0eXBlIFVuc2lnbmVkRXZlbnQgfSBmcm9tICdub3N0ci10b29scy9wdXJlJztcbmltcG9ydCB7IGVuY3J5cHQsIGRlY3J5cHQgfSBmcm9tICdub3N0ci10b29scy9uaXAwNCc7XG5pbXBvcnQgeyBieXRlc1RvSGV4LCBoZXhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlciB9IGZyb20gJ25vc3RyLXRvb2xzJztcbmltcG9ydCB7IGVuc3VyZVRyYW5zZmVyLCBpc1RyYW5zZmVyQ29tcGxldGUsIHN0b3JlQ2h1bmsgfSBmcm9tICcuL2NodW5rU3RvcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vc3RyUHJvZmlsZSB7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIGFib3V0Pzogc3RyaW5nO1xuICBwaWN0dXJlPzogc3RyaW5nO1xuICBuaXAwNT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3N0ckV2ZW50IHtcbiAgaWQ6IHN0cmluZztcbiAgcHVia2V5OiBzdHJpbmc7XG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcbiAga2luZDogbnVtYmVyO1xuICB0YWdzOiBzdHJpbmdbXVtdO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHNpZzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBNZXNzYWdlVHlwZSA9XG4gIHwgJ3RleHQnXG4gIHwgJ2ltYWdlJ1xuICB8ICdmaWxlJ1xuICB8ICdhdWRpbydcbiAgfCAnZmlsZS1tZXRhJ1xuICB8ICdmaWxlLWNodW5rJ1xuICB8ICdjaGFubmVsJ1xuICB8ICd3ZWJydGMtb2ZmZXInXG4gIHwgJ3dlYnJ0Yy1hbnN3ZXInXG4gIHwgJ3dlYnJ0Yy1pY2UnXG4gIHwgJ2NhbGwtcmVxdWVzdCdcbiAgfCAnY2FsbC1hY2NlcHQnXG4gIHwgJ2NhbGwtcmVqZWN0J1xuICB8ICdjYWxsLWVuZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVwbHlSZWYge1xuICBpZDogc3RyaW5nO1xuICBmcm9tOiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgdHlwZTogJ2ltYWdlJyB8ICdmaWxlJyB8ICdhdWRpbyc7XG4gIG5hbWU6IHN0cmluZztcbiAgbWltZVR5cGU6IHN0cmluZztcbiAgZGF0YTogc3RyaW5nO1xuICBzaXplOiBudW1iZXI7XG4gIGZpbGU/OiBGaWxlO1xuICB0cmFuc2ZlcklkPzogc3RyaW5nO1xuICB0b3RhbENodW5rcz86IG51bWJlcjtcbiAgY2h1bmtlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlyZWN0TWVzc2FnZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGZyb206IHN0cmluZztcbiAgdG86IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgcGVuZGluZz86IGJvb2xlYW47XG4gIGZhaWxlZD86IGJvb2xlYW47XG4gIG1zZ1R5cGU/OiBNZXNzYWdlVHlwZTtcbiAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQ7XG4gIHJlcGx5VG8/OiBSZXBseVJlZjtcbiAgY2hhbm5lbElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYW5uZWwge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFib3V0Pzogc3RyaW5nO1xuICBjcmVhdGVkQnk6IHN0cmluZztcbiAgY3JlYXRlZEF0OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFjdCB7XG4gIHB1YmtleTogc3RyaW5nO1xuICBuYW1lPzogc3RyaW5nO1xuICBhYm91dD86IHN0cmluZztcbiAgcGljdHVyZT86IHN0cmluZztcbiAgbGFzdE1lc3NhZ2U/OiBzdHJpbmc7XG4gIGxhc3RNZXNzYWdlVGltZT86IG51bWJlcjtcbiAgdW5yZWFkPzogbnVtYmVyO1xuICBvbmxpbmU/OiBib29sZWFuO1xufVxuXG5jb25zdCBERUZBVUxUX1JFTEFZUyA9IFtcbiAgJ3dzczovL3JlbGF5LmRhbXVzLmlvJyxcbiAgJ3dzczovL25vcy5sb2wnLFxuICAnd3NzOi8vcmVsYXkuc25vcnQuc29jaWFsJyxcbiAgJ3dzczovL3JlbGF5LnByaW1hbC5uZXQnLFxuICAnd3NzOi8vcHVycGxlcGFnLmVzJyxcbiAgJ3dzczovL25vc3RyLm1vbScsXG4gICd3c3M6Ly9yZWxheS5ub3N0ci5iZycsXG5dO1xuXG50eXBlIE1lc3NhZ2VDYWxsYmFjayA9IChtc2c6IERpcmVjdE1lc3NhZ2UpID0+IHZvaWQ7XG50eXBlIENoYW5uZWxDYWxsYmFjayA9IChjaGFubmVsOiBDaGFubmVsKSA9PiB2b2lkO1xudHlwZSBDaGFubmVsTWVzc2FnZUNhbGxiYWNrID0gKG1zZzogRGlyZWN0TWVzc2FnZSkgPT4gdm9pZDtcbnR5cGUgUHJvZmlsZUNhbGxiYWNrID0gKHB1YmtleTogc3RyaW5nLCBwcm9maWxlOiBOb3N0clByb2ZpbGUpID0+IHZvaWQ7XG50eXBlIENvbm5lY3Rpb25DYWxsYmFjayA9IChyZWxheTogc3RyaW5nLCBzdGF0dXM6ICdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCcgfCAnZXJyb3InKSA9PiB2b2lkO1xudHlwZSBTaWduYWxDYWxsYmFjayA9IChmcm9tOiBzdHJpbmcsIHNpZ25hbDogV2ViUlRDU2lnbmFsKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlJUQ1NpZ25hbCB7XG4gIHR5cGU6IE1lc3NhZ2VUeXBlO1xuICBzZHA/OiBzdHJpbmc7XG4gIGNhbmRpZGF0ZT86IFJUQ0ljZUNhbmRpZGF0ZUluaXQ7XG4gIGNhbGxUeXBlPzogJ2F1ZGlvJyB8ICd2aWRlbyc7XG4gIGNhbGxJZD86IHN0cmluZztcbn1cblxuY2xhc3MgTm9zdHJDbGllbnQge1xuICBwcml2YXRlIF9zazogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9wazogc3RyaW5nID0gJyc7XG4gIHByaXZhdGUgc29ja2V0czogTWFwPHN0cmluZywgV2ViU29ja2V0PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZWxheVN0YXR1czogTWFwPHN0cmluZywgJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyB8ICdjb25uZWN0aW5nJyB8ICdlcnJvcic+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IE1hcDxzdHJpbmcsIHsgZmlsdGVyczogRmlsdGVyW107IHJlbGF5OiBzdHJpbmcgfT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgbWVzc2FnZUNhbGxiYWNrczogU2V0PE1lc3NhZ2VDYWxsYmFjaz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgY2hhbm5lbENhbGxiYWNrczogU2V0PENoYW5uZWxDYWxsYmFjaz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgY2hhbm5lbE1lc3NhZ2VDYWxsYmFja3M6IFNldDxDaGFubmVsTWVzc2FnZUNhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBwcm9maWxlQ2FsbGJhY2tzOiBTZXQ8UHJvZmlsZUNhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBjb25uZWN0aW9uQ2FsbGJhY2tzOiBTZXQ8Q29ubmVjdGlvbkNhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBzaWduYWxDYWxsYmFja3M6IFNldDxTaWduYWxDYWxsYmFjaz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgcHJvZmlsZUNhY2hlOiBNYXA8c3RyaW5nLCBOb3N0clByb2ZpbGU+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHBlbmRpbmdQcm9maWxlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgc2VlbkV2ZW50czogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgX3JlbGF5czogc3RyaW5nW10gPSBbLi4uREVGQVVMVF9SRUxBWVNdO1xuICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlY29ubmVjdFRpbWVyczogTWFwPHN0cmluZywgUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIF9zdG9wcGVkID0gZmFsc2U7XG4gIHByaXZhdGUgX2NoYW5uZWxzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGdldCBwdWJsaWNLZXkoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX3BrOyB9XG4gIGdldCBwcml2YXRlS2V5SGV4KCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9zayA/IGJ5dGVzVG9IZXgodGhpcy5fc2spIDogJyc7IH1cbiAgZ2V0IHJlbGF5cygpOiBzdHJpbmdbXSB7IHJldHVybiBbLi4udGhpcy5fcmVsYXlzXTsgfVxuICBnZXQgY2hhbm5lbHMoKTogc3RyaW5nW10geyByZXR1cm4gWy4uLnRoaXMuX2NoYW5uZWxzXTsgfVxuICBnZXQgc2soKTogVWludDhBcnJheSB8IG51bGwgeyByZXR1cm4gdGhpcy5fc2s7IH1cblxuICBnZXRSZWxheVN0YXR1cyhyZWxheTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheVN0YXR1cy5nZXQocmVsYXkpIHx8ICdkaXNjb25uZWN0ZWQnO1xuICB9XG5cbiAgZ2V0IGNvbm5lY3RlZFJlbGF5Q291bnQoKTogbnVtYmVyIHtcbiAgICBsZXQgYyA9IDA7XG4gICAgdGhpcy5yZWxheVN0YXR1cy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBpZiAocyA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgYysrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgZ2VuZXJhdGVLZXlzKCkge1xuICAgIGNvbnN0IHNrID0gZ2VuZXJhdGVTZWNyZXRLZXkoKTtcbiAgICBjb25zdCBwayA9IGdldFB1YmxpY0tleShzayk7XG4gICAgcmV0dXJuIHsgcHJpdmF0ZUtleTogYnl0ZXNUb0hleChzayksIHB1YmxpY0tleTogcGsgfTtcbiAgfVxuXG4gIGxvZ2luKHByaXZhdGVLZXlIZXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2sgPSBoZXhUb0J5dGVzKHByaXZhdGVLZXlIZXgpO1xuICAgIGNvbnN0IHBrID0gZ2V0UHVibGljS2V5KHNrKTtcbiAgICB0aGlzLl9zayA9IHNrOyB0aGlzLl9wayA9IHBrOyB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ25vc3RyX3NrJywgcHJpdmF0ZUtleUhleCk7XG4gICAgcmV0dXJuIHBrO1xuICB9XG5cbiAgbG9nb3V0KCkge1xuICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlOyB0aGlzLmRpc2Nvbm5lY3RBbGwoKTtcbiAgICB0aGlzLl9zayA9IG51bGw7IHRoaXMuX3BrID0gJyc7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ25vc3RyX3NrJyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ25vc3RyX2NvbnRhY3RzJyk7XG4gIH1cblxuICB0cnlBdXRvTG9naW4oKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc2sgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbm9zdHJfc2snKTtcbiAgICBpZiAoc2s/Lmxlbmd0aCA9PT0gNjQpIHsgdHJ5IHsgdGhpcy5sb2dpbihzayk7IHJldHVybiB0cnVlOyB9IGNhdGNoIHsgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ25vc3RyX3NrJyk7IH0gfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG9uTWVzc2FnZShjYjogTWVzc2FnZUNhbGxiYWNrKSB7IHRoaXMubWVzc2FnZUNhbGxiYWNrcy5hZGQoY2IpOyByZXR1cm4gKCkgPT4geyB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZGVsZXRlKGNiKTsgfTsgfVxuICBvbkNoYW5uZWwoY2I6IENoYW5uZWxDYWxsYmFjaykgeyB0aGlzLmNoYW5uZWxDYWxsYmFja3MuYWRkKGNiKTsgcmV0dXJuICgpID0+IHsgdGhpcy5jaGFubmVsQ2FsbGJhY2tzLmRlbGV0ZShjYik7IH07IH1cbiAgb25DaGFubmVsTWVzc2FnZShjYjogQ2hhbm5lbE1lc3NhZ2VDYWxsYmFjaykgeyB0aGlzLmNoYW5uZWxNZXNzYWdlQ2FsbGJhY2tzLmFkZChjYik7IHJldHVybiAoKSA9PiB7IHRoaXMuY2hhbm5lbE1lc3NhZ2VDYWxsYmFja3MuZGVsZXRlKGNiKTsgfTsgfVxuICBvblByb2ZpbGUoY2I6IFByb2ZpbGVDYWxsYmFjaykgeyB0aGlzLnByb2ZpbGVDYWxsYmFja3MuYWRkKGNiKTsgcmV0dXJuICgpID0+IHsgdGhpcy5wcm9maWxlQ2FsbGJhY2tzLmRlbGV0ZShjYik7IH07IH1cbiAgb25Db25uZWN0aW9uKGNiOiBDb25uZWN0aW9uQ2FsbGJhY2spIHsgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzLmFkZChjYik7IHJldHVybiAoKSA9PiB7IHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcy5kZWxldGUoY2IpOyB9OyB9XG4gIG9uU2lnbmFsKGNiOiBTaWduYWxDYWxsYmFjaykgeyB0aGlzLnNpZ25hbENhbGxiYWNrcy5hZGQoY2IpOyByZXR1cm4gKCkgPT4geyB0aGlzLnNpZ25hbENhbGxiYWNrcy5kZWxldGUoY2IpOyB9OyB9XG5cbiAgYXN5bmMgY29ubmVjdFRvUmVsYXlzKCkgeyBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fcmVsYXlzKSB0aGlzLmNvbm5lY3RUb1JlbGF5KHIpOyB9XG5cbiAgc2V0Q2hhbm5lbHMoY2hhbm5lbElkczogc3RyaW5nW10pIHtcbiAgICB0aGlzLl9jaGFubmVscyA9IFsuLi5uZXcgU2V0KGNoYW5uZWxJZHMuZmlsdGVyKEJvb2xlYW4pKV07XG4gICAgZm9yIChjb25zdCBbcmVsYXksIHdzXSBvZiB0aGlzLnNvY2tldHMpIHtcbiAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWxzKHJlbGF5KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbm5lY3RUb1JlbGF5KHVybDogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX3N0b3BwZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5zb2NrZXRzLmhhcyh1cmwpKSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5zb2NrZXRzLmdldCh1cmwpITtcbiAgICAgIGlmIChlLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOIHx8IGUucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWxheVN0YXR1cy5zZXQodXJsLCAnY29ubmVjdGluZycpO1xuICAgIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHVybCwgJ2Rpc2Nvbm5lY3RlZCcpKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KHVybCk7XG4gICAgICBjb25zdCBjdCA9IHNldFRpbWVvdXQoKCkgPT4geyBpZiAod3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHdzLmNsb3NlKCk7IH0sIDgwMDApO1xuICAgICAgdGhpcy5zb2NrZXRzLnNldCh1cmwsIHdzKTtcbiAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHsgY2xlYXJUaW1lb3V0KGN0KTsgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cy5zZXQodXJsLCAwKTsgdGhpcy5yZWxheVN0YXR1cy5zZXQodXJsLCAnY29ubmVjdGVkJyk7IHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHVybCwgJ2Nvbm5lY3RlZCcpKTsgdGhpcy5zdWJzY3JpYmVUb01lc3NhZ2VzKHVybCk7IH07XG4gICAgICB3cy5vbmNsb3NlID0gKCkgPT4geyBjbGVhclRpbWVvdXQoY3QpOyB0aGlzLnJlbGF5U3RhdHVzLnNldCh1cmwsICdkaXNjb25uZWN0ZWQnKTsgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IodXJsLCAnZGlzY29ubmVjdGVkJykpOyB0aGlzLnNvY2tldHMuZGVsZXRlKHVybCk7IHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QodXJsKTsgfTtcbiAgICAgIHdzLm9uZXJyb3IgPSAoKSA9PiB7IHRoaXMucmVsYXlTdGF0dXMuc2V0KHVybCwgJ2Vycm9yJyk7IHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHVybCwgJ2Vycm9yJykpOyB9O1xuICAgICAgd3Mub25tZXNzYWdlID0gKGUpID0+IHsgdHJ5IHsgdGhpcy5oYW5kbGVSZWxheU1lc3NhZ2UoSlNPTi5wYXJzZShlLmRhdGEpKTsgfSBjYXRjaCB7fSB9O1xuICAgIH0gY2F0Y2ggeyB0aGlzLnJlbGF5U3RhdHVzLnNldCh1cmwsICdlcnJvcicpOyB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KHVybCk7IH1cbiAgfVxuXG4gIHByaXZhdGUgc2NoZWR1bGVSZWNvbm5lY3QodXJsOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5fc3RvcHBlZCkgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLnJlY29ubmVjdFRpbWVycy5nZXQodXJsKTsgaWYgKGUpIGNsZWFyVGltZW91dChlKTtcbiAgICBjb25zdCBhID0gdGhpcy5yZWNvbm5lY3RBdHRlbXB0cy5nZXQodXJsKSB8fCAwO1xuICAgIGNvbnN0IGQgPSBNYXRoLm1pbigzMDAwICogTWF0aC5wb3coMiwgYSksIDYwMDAwKTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzLnNldCh1cmwsIGEgKyAxKTtcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVycy5zZXQodXJsLCBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKCF0aGlzLl9zdG9wcGVkICYmIHRoaXMuX3NrKSB0aGlzLmNvbm5lY3RUb1JlbGF5KHVybCk7IH0sIGQpKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlUmVsYXlNZXNzYWdlKGRhdGE6IHVua25vd25bXSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkgcmV0dXJuO1xuICAgIGlmIChkYXRhWzBdID09PSAnRVZFTlQnKSB7XG4gICAgICBjb25zdCBldiA9IGRhdGFbMl0gYXMgTm9zdHJFdmVudDtcbiAgICAgIGlmICghZXYgfHwgdGhpcy5zZWVuRXZlbnRzLmhhcyhldi5pZCkpIHJldHVybjtcbiAgICAgIHRoaXMuc2VlbkV2ZW50cy5hZGQoZXYuaWQpO1xuICAgICAgaWYgKGV2LmtpbmQgPT09IDQpIHRoaXMuaGFuZGxlRW5jcnlwdGVkRE0oZXYpO1xuICAgICAgZWxzZSBpZiAoZXYua2luZCA9PT0gMCkgdGhpcy5oYW5kbGVQcm9maWxlRXZlbnQoZXYpO1xuICAgICAgZWxzZSBpZiAoZXYua2luZCA9PT0gNDApIHRoaXMuaGFuZGxlQ2hhbm5lbEV2ZW50KGV2KTtcbiAgICAgIGVsc2UgaWYgKGV2LmtpbmQgPT09IDQyKSB0aGlzLmhhbmRsZUNoYW5uZWxNZXNzYWdlRXZlbnQoZXYpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlRW5jcnlwdGVkRE0oZXZlbnQ6IE5vc3RyRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX3NrKSByZXR1cm47XG4gICAgY29uc3QgcFRhZyA9IGV2ZW50LnRhZ3MuZmluZCh0ID0+IHRbMF0gPT09ICdwJyk7IGlmICghcFRhZykgcmV0dXJuO1xuICAgIGNvbnN0IGlzRm9yTWUgPSBwVGFnWzFdID09PSB0aGlzLl9waywgaXNGcm9tTWUgPSBldmVudC5wdWJrZXkgPT09IHRoaXMuX3BrO1xuICAgIGlmICghaXNGb3JNZSAmJiAhaXNGcm9tTWUpIHJldHVybjtcbiAgICBjb25zdCBvdGhlciA9IGlzRnJvbU1lID8gcFRhZ1sxXSA6IGV2ZW50LnB1YmtleTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjID0gYXdhaXQgZGVjcnlwdCh0aGlzLl9zaywgb3RoZXIsIGV2ZW50LmNvbnRlbnQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcCA9IEpTT04ucGFyc2UoZGVjKTtcbiAgICAgICAgICBpZiAocD8uX25vc3RyX21zZ190eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBtdCA9IHAuX25vc3RyX21zZ190eXBlIGFzIE1lc3NhZ2VUeXBlO1xuICAgICAgICAgICAgaWYgKG10ID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2Ioe1xuICAgICAgICAgICAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgICAgICAgICAgICBmcm9tOiBldmVudC5wdWJrZXksXG4gICAgICAgICAgICAgICAgdG86IHBUYWdbMV0sXG4gICAgICAgICAgICAgICAgY29udGVudDogKHAudGV4dCBhcyBzdHJpbmcpIHx8ICcnLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsXG4gICAgICAgICAgICAgICAgbXNnVHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJlcGx5VG86IHAucmVwbHlUbyBhcyBSZXBseVJlZiB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoWyd3ZWJydGMtb2ZmZXInLCd3ZWJydGMtYW5zd2VyJywnd2VicnRjLWljZScsJ2NhbGwtcmVxdWVzdCcsJ2NhbGwtYWNjZXB0JywnY2FsbC1yZWplY3QnLCdjYWxsLWVuZCddLmluY2x1ZGVzKG10KSkge1xuICAgICAgICAgICAgdGhpcy5zaWduYWxDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYihldmVudC5wdWJrZXksIHsgdHlwZTogbXQsIHNkcDogcC5zZHAsIGNhbmRpZGF0ZTogcC5jYW5kaWRhdGUsIGNhbGxUeXBlOiBwLmNhbGxUeXBlLCBjYWxsSWQ6IHAuY2FsbElkIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG10ID09PSAnZmlsZS1jaHVuaycpIHsgdGhpcy5oYW5kbGVGaWxlQ2h1bmsoZXZlbnQuaWQsIGV2ZW50LnB1YmtleSwgcFRhZ1sxXSwgZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsIHApOyByZXR1cm47IH1cbiAgICAgICAgICBpZiAobXQgPT09ICdmaWxlLW1ldGEnKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2ZlcklkID0gKHAudHJhbnNmZXJJZCBhcyBzdHJpbmcpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2ZlcklkKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBmaWxlVHlwZSA9IFsnaW1hZ2UnLCAnYXVkaW8nXS5pbmNsdWRlcyhwLmZpbGVUeXBlIGFzIHN0cmluZykgPyBwLmZpbGVUeXBlIGFzICgnaW1hZ2UnIHwgJ2F1ZGlvJykgOiAnZmlsZSc7XG4gICAgICAgICAgICBhd2FpdCBlbnN1cmVUcmFuc2Zlcih7XG4gICAgICAgICAgICAgIHRyYW5zZmVySWQsXG4gICAgICAgICAgICAgIGZpbGVOYW1lOiAocC5maWxlTmFtZSBhcyBzdHJpbmcpIHx8ICdmaWxlJyxcbiAgICAgICAgICAgICAgbWltZVR5cGU6IChwLm1pbWVUeXBlIGFzIHN0cmluZykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAgIGZpbGVUeXBlLFxuICAgICAgICAgICAgICBzaXplOiAocC5zaXplIGFzIG51bWJlcikgfHwgMCxcbiAgICAgICAgICAgICAgdG90YWxDaHVua3M6IChwLnRvdGFsQ2h1bmtzIGFzIG51bWJlcikgfHwgMCxcbiAgICAgICAgICAgICAgdGV4dDogKHAudGV4dCBhcyBzdHJpbmcpIHx8ICcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtdCA9PT0gJ2ltYWdlJyB8fCBtdCA9PT0gJ2ZpbGUnIHx8IG10ID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYih7IGlkOiBldmVudC5pZCwgZnJvbTogZXZlbnQucHVia2V5LCB0bzogcFRhZ1sxXSwgY29udGVudDogcC50ZXh0IHx8ICcnLCB0aW1lc3RhbXA6IGV2ZW50LmNyZWF0ZWRfYXQgKiAxMDAwLCBtc2dUeXBlOiBtdCwgcmVwbHlUbzogcC5yZXBseVRvIGFzIFJlcGx5UmVmIHwgdW5kZWZpbmVkLCBhdHRhY2htZW50OiB7IHR5cGU6IG10LCBuYW1lOiBwLmZpbGVOYW1lIHx8ICdmaWxlJywgbWltZVR5cGU6IHAubWltZVR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsIGRhdGE6IHAuZGF0YSB8fCAnJywgc2l6ZTogcC5zaXplIHx8IDAgfSB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYih7IGlkOiBldmVudC5pZCwgZnJvbTogZXZlbnQucHVia2V5LCB0bzogcFRhZ1sxXSwgY29udGVudDogZGVjLCB0aW1lc3RhbXA6IGV2ZW50LmNyZWF0ZWRfYXQgKiAxMDAwLCBtc2dUeXBlOiAndGV4dCcgfSkpO1xuICAgIH0gY2F0Y2gge31cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlRmlsZUNodW5rKGV2ZW50SWQ6IHN0cmluZywgZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nLCB0aW1lc3RhbXA6IG51bWJlciwgcDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBjb25zdCB0cmFuc2ZlcklkID0gcC50cmFuc2ZlcklkIGFzIHN0cmluZztcbiAgICBjb25zdCBjaHVua0luZGV4ID0gcC5jaHVua0luZGV4IGFzIG51bWJlcjtcbiAgICBjb25zdCB0b3RhbENodW5rcyA9IHAudG90YWxDaHVua3MgYXMgbnVtYmVyO1xuICAgIGNvbnN0IGRhdGEgPSBwLmRhdGEgYXMgc3RyaW5nO1xuICAgIGlmICghdHJhbnNmZXJJZCB8fCB0eXBlb2YgY2h1bmtJbmRleCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRvdGFsQ2h1bmtzICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHJldHVybjtcblxuICAgIGNvbnN0IGZpbGVUeXBlID0gWydpbWFnZScsICdhdWRpbyddLmluY2x1ZGVzKHAuZmlsZVR5cGUgYXMgc3RyaW5nKSA/IHAuZmlsZVR5cGUgYXMgKCdpbWFnZScgfCAnYXVkaW8nKSA6ICdmaWxlJztcbiAgICBhd2FpdCBlbnN1cmVUcmFuc2Zlcih7XG4gICAgICB0cmFuc2ZlcklkLFxuICAgICAgZmlsZU5hbWU6IChwLmZpbGVOYW1lIGFzIHN0cmluZykgfHwgJ2ZpbGUnLFxuICAgICAgbWltZVR5cGU6IChwLm1pbWVUeXBlIGFzIHN0cmluZykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICBmaWxlVHlwZSxcbiAgICAgIHNpemU6IChwLnNpemUgYXMgbnVtYmVyKSB8fCAwLFxuICAgICAgdG90YWxDaHVua3MsXG4gICAgICB0ZXh0OiAocC50ZXh0IGFzIHN0cmluZykgfHwgJycsXG4gICAgfSk7XG4gICAgYXdhaXQgc3RvcmVDaHVuayh0cmFuc2ZlcklkLCBjaHVua0luZGV4LCB0b3RhbENodW5rcywgZGF0YSk7XG4gICAgY29uc3QgZG9uZSA9IGF3YWl0IGlzVHJhbnNmZXJDb21wbGV0ZSh0cmFuc2ZlcklkKTtcbiAgICBpZiAoIWRvbmUpIHJldHVybjtcblxuICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHtcbiAgICAgIGlkOiBgJHtldmVudElkfS1hc3NlbWJsZWQtJHt0cmFuc2ZlcklkfWAsXG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgICBjb250ZW50OiAocC50ZXh0IGFzIHN0cmluZykgfHwgJycsXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBtc2dUeXBlOiBmaWxlVHlwZSxcbiAgICAgIHJlcGx5VG86IHAucmVwbHlUbyBhcyBSZXBseVJlZiB8IHVuZGVmaW5lZCxcbiAgICAgIGF0dGFjaG1lbnQ6IHtcbiAgICAgICAgdHlwZTogZmlsZVR5cGUsXG4gICAgICAgIG5hbWU6IChwLmZpbGVOYW1lIGFzIHN0cmluZykgfHwgJ2ZpbGUnLFxuICAgICAgICBtaW1lVHlwZTogKHAubWltZVR5cGUgYXMgc3RyaW5nKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgZGF0YTogJycsXG4gICAgICAgIHNpemU6IChwLnNpemUgYXMgbnVtYmVyKSB8fCAwLFxuICAgICAgICB0cmFuc2ZlcklkLFxuICAgICAgICB0b3RhbENodW5rcyxcbiAgICAgICAgY2h1bmtlZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVQcm9maWxlRXZlbnQoZXZlbnQ6IE5vc3RyRXZlbnQpIHtcbiAgICB0cnkgeyBjb25zdCBwID0gSlNPTi5wYXJzZShldmVudC5jb250ZW50KSBhcyBOb3N0clByb2ZpbGU7IHRoaXMucHJvZmlsZUNhY2hlLnNldChldmVudC5wdWJrZXksIHApOyB0aGlzLnBlbmRpbmdQcm9maWxlcy5kZWxldGUoZXZlbnQucHVia2V5KTsgdGhpcy5wcm9maWxlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IoZXZlbnQucHVia2V5LCBwKSk7IH0gY2F0Y2gge31cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ2hhbm5lbEV2ZW50KGV2ZW50OiBOb3N0ckV2ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpIGFzIHsgbmFtZT86IHN0cmluZzsgYWJvdXQ/OiBzdHJpbmcgfTtcbiAgICAgIGNvbnN0IGNoYW5uZWw6IENoYW5uZWwgPSB7XG4gICAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgICAgbmFtZTogcGF5bG9hZC5uYW1lPy50cmltKCkgfHwgYGNoYW5uZWwtJHtldmVudC5pZC5zbGljZSgwLCA4KX1gLFxuICAgICAgICBhYm91dDogcGF5bG9hZC5hYm91dCxcbiAgICAgICAgY3JlYXRlZEJ5OiBldmVudC5wdWJrZXksXG4gICAgICAgIGNyZWF0ZWRBdDogZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsXG4gICAgICB9O1xuICAgICAgdGhpcy5jaGFubmVsQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IoY2hhbm5lbCkpO1xuICAgIH0gY2F0Y2gge31cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ2hhbm5lbE1lc3NhZ2VFdmVudChldmVudDogTm9zdHJFdmVudCkge1xuICAgIGNvbnN0IGVUYWcgPSBldmVudC50YWdzLmZpbmQodCA9PiB0WzBdID09PSAnZScpPy5bMV07XG4gICAgaWYgKCFlVGFnKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpIGFzIHsgdGV4dD86IHN0cmluZzsgcmVwbHlUbz86IFJlcGx5UmVmIH07XG4gICAgICB0aGlzLmNoYW5uZWxNZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2Ioe1xuICAgICAgICBpZDogZXZlbnQuaWQsXG4gICAgICAgIGZyb206IGV2ZW50LnB1YmtleSxcbiAgICAgICAgdG86ICcnLFxuICAgICAgICBjb250ZW50OiBwYXlsb2FkLnRleHQgfHwgJycsXG4gICAgICAgIHRpbWVzdGFtcDogZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsXG4gICAgICAgIG1zZ1R5cGU6ICdjaGFubmVsJyxcbiAgICAgICAgY2hhbm5lbElkOiBlVGFnLFxuICAgICAgICByZXBseVRvOiBwYXlsb2FkLnJlcGx5VG8sXG4gICAgICB9KSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aGlzLmNoYW5uZWxNZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2Ioe1xuICAgICAgICBpZDogZXZlbnQuaWQsXG4gICAgICAgIGZyb206IGV2ZW50LnB1YmtleSxcbiAgICAgICAgdG86ICcnLFxuICAgICAgICBjb250ZW50OiBldmVudC5jb250ZW50IHx8ICcnLFxuICAgICAgICB0aW1lc3RhbXA6IGV2ZW50LmNyZWF0ZWRfYXQgKiAxMDAwLFxuICAgICAgICBtc2dUeXBlOiAnY2hhbm5lbCcsXG4gICAgICAgIGNoYW5uZWxJZDogZVRhZyxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmliZVRvTWVzc2FnZXMocmVsYXlVcmw6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5fcGspIHJldHVybjtcbiAgICBjb25zdCB3cyA9IHRoaXMuc29ja2V0cy5nZXQocmVsYXlVcmwpOyBpZiAoIXdzIHx8IHdzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSByZXR1cm47XG4gICAgY29uc3Qgc3ViSWQgPSAnZG0tJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDgpO1xuICAgIGNvbnN0IHNpbmNlID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgLSA4NjQwMCAqIDMwO1xuICAgIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkoWydSRVEnLCBzdWJJZCwgeyBraW5kczogWzRdLCAnI3AnOiBbdGhpcy5fcGtdLCBzaW5jZSB9LCB7IGtpbmRzOiBbNF0sIGF1dGhvcnM6IFt0aGlzLl9wa10sIHNpbmNlIH1dKSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWJJZCwgeyBmaWx0ZXJzOiBbXSwgcmVsYXk6IHJlbGF5VXJsIH0pO1xuICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVscyhyZWxheVVybCk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmliZVRvQ2hhbm5lbHMocmVsYXlVcmw6IHN0cmluZykge1xuICAgIGNvbnN0IHdzID0gdGhpcy5zb2NrZXRzLmdldChyZWxheVVybCk7XG4gICAgaWYgKCF3cyB8fCB3cy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9jaGFubmVscy5sZW5ndGggPT09IDApIHJldHVybjsgLy8gRG8gbm90IHN1YnNjcmliZSB0byBnbG9iYWwgY2hhbm5lbHNcblxuICAgIGNvbnN0IHN1YklkID0gJ2NoLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCA4KTtcbiAgICBjb25zdCBzaW5jZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gODY0MDAgKiAzMDtcblxuICAgIC8vIE9ubHkgc3Vic2NyaWJlIHRvIGNoYW5uZWxzIHRoZSB1c2VyIGhhcyBqb2luZWRcbiAgICB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KFsnUkVRJywgc3ViSWQsIHsga2luZHM6IFs0MF0sIGlkczogdGhpcy5fY2hhbm5lbHMsIHNpbmNlIH0sIHsga2luZHM6IFs0Ml0sICcjZSc6IHRoaXMuX2NoYW5uZWxzLCBzaW5jZSB9XSkpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoc3ViSWQsIHsgZmlsdGVyczogW10sIHJlbGF5OiByZWxheVVybCB9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRFbmNyeXB0ZWRQYXlsb2FkKHJlY2lwaWVudFB1YmtleTogc3RyaW5nLCBwYXlsb2FkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5fc2spIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhvcml6ZWQnKTtcbiAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBlbmNyeXB0KHRoaXMuX3NrLCByZWNpcGllbnRQdWJrZXksIHBheWxvYWQpO1xuICAgIGNvbnN0IGV2OiBVbnNpZ25lZEV2ZW50ID0geyBraW5kOiA0LCBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSwgdGFnczogW1sncCcsIHJlY2lwaWVudFB1YmtleV1dLCBjb250ZW50OiBlbmNyeXB0ZWQsIHB1YmtleTogdGhpcy5fcGsgfTtcbiAgICBjb25zdCBldmVudCA9IGZpbmFsaXplRXZlbnQoZXYsIHRoaXMuX3NrKTtcbiAgICB0aGlzLnNlZW5FdmVudHMuYWRkKGV2ZW50LmlkKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoWydFVkVOVCcsIGV2ZW50XSk7XG4gICAgY29uc3Qgb3BlbjogV2ViU29ja2V0W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFssIHdzXSBvZiB0aGlzLnNvY2tldHMpIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgb3Blbi5wdXNoKHdzKTtcbiAgICBpZiAoIW9wZW4ubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbm5lY3RlZCByZWxheXMnKTtcbiAgICBvcGVuLmZvckVhY2god3MgPT4geyB0cnkgeyB3cy5zZW5kKGpzb24pOyB9IGNhdGNoIHt9IH0pO1xuICAgIHJldHVybiBldmVudC5pZDtcbiAgfVxuXG4gIHByaXZhdGUgYnl0ZXNUb0Jhc2U2NChieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgbGV0IGJpbiA9ICcnO1xuICAgIGNvbnN0IHN0ZXAgPSAweDgwMDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgYmluICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYnl0ZXMuc3ViYXJyYXkoaSwgaSArIHN0ZXApKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluKTtcbiAgfVxuXG4gIGFzeW5jIHNlbmREaXJlY3RNZXNzYWdlKHJlY2lwaWVudFB1YmtleTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIHJlcGx5VG8/OiBSZXBseVJlZik6IFByb21pc2U8RGlyZWN0TWVzc2FnZT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSByZXBseVRvID8gSlNPTi5zdHJpbmdpZnkoeyBfbm9zdHJfbXNnX3R5cGU6ICd0ZXh0JywgdGV4dDogY29udGVudCwgcmVwbHlUbyB9KSA6IGNvbnRlbnQ7XG4gICAgY29uc3QgaWQgPSBhd2FpdCB0aGlzLnNlbmRFbmNyeXB0ZWRQYXlsb2FkKHJlY2lwaWVudFB1YmtleSwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHsgaWQsIGZyb206IHRoaXMuX3BrLCB0bzogcmVjaXBpZW50UHVia2V5LCBjb250ZW50LCB0aW1lc3RhbXA6IERhdGUubm93KCksIG1zZ1R5cGU6ICd0ZXh0JywgcmVwbHlUbyB9O1xuICB9XG5cbiAgLy8gMjU2S0IgY2h1bmtzLCBwYXJhbGxlbCBzZW5kIGJ5IDNcbiAgcHJpdmF0ZSBzdGF0aWMgQ0hVTktfU0laRSA9IDI2MjE0NDtcbiAgcHJpdmF0ZSBzdGF0aWMgUEFSQUxMRUwgPSAzO1xuXG4gIGFzeW5jIHNlbmRBdHRhY2htZW50KFxuICAgIHJlY2lwaWVudFB1YmtleTogc3RyaW5nLFxuICAgIGF0dGFjaG1lbnQ6IEF0dGFjaG1lbnQsXG4gICAgdGV4dD86IHN0cmluZyxcbiAgICBvblByb2dyZXNzPzogKHNlbnQ6IG51bWJlciwgdG90YWw6IG51bWJlcikgPT4gdm9pZCxcbiAgICByZXBseVRvPzogUmVwbHlSZWYsXG4gICk6IFByb21pc2U8RGlyZWN0TWVzc2FnZT4ge1xuICAgIGNvbnN0IG1heFNpemUgPSAyICogMTAyNCAqIDEwMjQgKiAxMDI0O1xuICAgIGlmIChhdHRhY2htZW50LnNpemUgPiBtYXhTaXplKSB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgaXMgdG9vIGxhcmdlLiBNYXggc2l6ZSBpcyAyR0IuJyk7XG5cbiAgICBpZiAoIWF0dGFjaG1lbnQuZmlsZSkge1xuICAgICAgY29uc3QgYjY0ID0gYXR0YWNobWVudC5kYXRhO1xuICAgICAgaWYgKGI2NC5sZW5ndGggPCA0MDAwMCkge1xuICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMuc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgX25vc3RyX21zZ190eXBlOiBhdHRhY2htZW50LnR5cGUsXG4gICAgICAgICAgZmlsZU5hbWU6IGF0dGFjaG1lbnQubmFtZSxcbiAgICAgICAgICBtaW1lVHlwZTogYXR0YWNobWVudC5taW1lVHlwZSxcbiAgICAgICAgICBkYXRhOiBiNjQsXG4gICAgICAgICAgc2l6ZTogYXR0YWNobWVudC5zaXplLFxuICAgICAgICAgIHRleHQ6IHRleHQgfHwgJycsXG4gICAgICAgICAgcmVwbHlUbyxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4geyBpZCwgZnJvbTogdGhpcy5fcGssIHRvOiByZWNpcGllbnRQdWJrZXksIGNvbnRlbnQ6IHRleHQgfHwgJycsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSwgbXNnVHlwZTogYXR0YWNobWVudC50eXBlLCBhdHRhY2htZW50LCByZXBseVRvIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZSA9IGF0dGFjaG1lbnQuZmlsZTtcbiAgICBjb25zdCB0cmFuc2ZlcklkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbiAgICBjb25zdCBmaWxlU2l6ZSA9IGZpbGUgPyBmaWxlLnNpemUgOiBhdHRhY2htZW50LnNpemU7XG4gICAgY29uc3QgdG90YWxDaHVua3MgPSBNYXRoLmNlaWwoZmlsZVNpemUgLyBOb3N0ckNsaWVudC5DSFVOS19TSVpFKTtcbiAgICBsZXQgbGFzdElkID0gJyc7XG4gICAgbGV0IHNlbnQgPSAwO1xuXG4gICAgYXdhaXQgZW5zdXJlVHJhbnNmZXIoe1xuICAgICAgICB0cmFuc2ZlcklkLFxuICAgICAgICBmaWxlTmFtZTogYXR0YWNobWVudC5uYW1lLFxuICAgICAgICBtaW1lVHlwZTogYXR0YWNobWVudC5taW1lVHlwZSxcbiAgICAgICAgZmlsZVR5cGU6IGF0dGFjaG1lbnQudHlwZSxcbiAgICAgICAgc2l6ZTogZmlsZVNpemUsXG4gICAgICAgIHRvdGFsQ2h1bmtzLFxuICAgICAgICB0ZXh0OiB0ZXh0IHx8ICcnLFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5zZW5kRW5jcnlwdGVkUGF5bG9hZChyZWNpcGllbnRQdWJrZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIF9ub3N0cl9tc2dfdHlwZTogJ2ZpbGUtbWV0YScsXG4gICAgICB0cmFuc2ZlcklkLFxuICAgICAgdG90YWxDaHVua3MsXG4gICAgICBmaWxlTmFtZTogYXR0YWNobWVudC5uYW1lLFxuICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQubWltZVR5cGUsXG4gICAgICBzaXplOiBmaWxlU2l6ZSxcbiAgICAgIHRleHQ6IHRleHQgfHwgJycsXG4gICAgICBmaWxlVHlwZTogYXR0YWNobWVudC50eXBlLFxuICAgICAgcmVwbHlUbyxcbiAgICB9KSk7XG5cbiAgICBmb3IgKGxldCBiYXRjaCA9IDA7IGJhdGNoIDwgdG90YWxDaHVua3M7IGJhdGNoICs9IE5vc3RyQ2xpZW50LlBBUkFMTEVMKSB7XG4gICAgICBjb25zdCBwcm9taXNlczogUHJvbWlzZTxzdHJpbmc+W10gPSBbXTtcbiAgICAgIGNvbnN0IGxvY2FsQ2h1bmtzOiB7aTogbnVtYmVyLCBkYXRhOiBzdHJpbmd9W10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOb3N0ckNsaWVudC5QQVJBTExFTCAmJiBiYXRjaCArIGogPCB0b3RhbENodW5rczsgaisrKSB7XG4gICAgICAgIGNvbnN0IGkgPSBiYXRjaCArIGo7XG4gICAgICAgIGxldCBjaHVua0RhdGE6IHN0cmluZztcblxuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSAqIE5vc3RyQ2xpZW50LkNIVU5LX1NJWkU7XG4gICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBOb3N0ckNsaWVudC5DSFVOS19TSVpFLCBmaWxlU2l6ZSk7XG4gICAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhd2FpdCBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpLmFycmF5QnVmZmVyKCkpO1xuICAgICAgICAgIGNodW5rRGF0YSA9IHRoaXMuYnl0ZXNUb0Jhc2U2NChieXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYmFzZTY0Q2h1bmtTaXplID0gTWF0aC5mbG9vcigoTm9zdHJDbGllbnQuQ0hVTktfU0laRSAvIDMpICogNCk7XG4gICAgICAgICAgY2h1bmtEYXRhID0gYXR0YWNobWVudC5kYXRhLnNsaWNlKGkgKiBiYXNlNjRDaHVua1NpemUsIChpICsgMSkgKiBiYXNlNjRDaHVua1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsb2NhbENodW5rcy5wdXNoKHtpLCBkYXRhOiBjaHVua0RhdGF9KTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBfbm9zdHJfbXNnX3R5cGU6ICdmaWxlLWNodW5rJyxcbiAgICAgICAgICAgIHRyYW5zZmVySWQsXG4gICAgICAgICAgICBjaHVua0luZGV4OiBpLFxuICAgICAgICAgICAgdG90YWxDaHVua3MsXG4gICAgICAgICAgICBkYXRhOiBjaHVua0RhdGEsXG4gICAgICAgICAgICBmaWxlTmFtZTogYXR0YWNobWVudC5uYW1lLFxuICAgICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQubWltZVR5cGUsXG4gICAgICAgICAgICBzaXplOiBmaWxlU2l6ZSxcbiAgICAgICAgICAgIHRleHQ6IHRleHQgfHwgJycsXG4gICAgICAgICAgICBmaWxlVHlwZTogYXR0YWNobWVudC50eXBlLFxuICAgICAgICAgICAgcmVwbHlUbyxcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGxhc3RJZCA9IGlkc1tpZHMubGVuZ3RoIC0gMV0gfHwgbGFzdElkO1xuXG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGxvY2FsQ2h1bmtzKSB7XG4gICAgICAgICAgYXdhaXQgc3RvcmVDaHVuayh0cmFuc2ZlcklkLCBjaHVuay5pLCB0b3RhbENodW5rcywgY2h1bmsuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHNlbnQgKz0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgb25Qcm9ncmVzcz8uKHNlbnQsIHRvdGFsQ2h1bmtzKTtcbiAgICAgIGlmIChzZW50IDwgdG90YWxDaHVua3MpIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCA1MCkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpZDogbGFzdElkIHx8IGBsb2NhbC0ke3RyYW5zZmVySWR9YCxcbiAgICAgIGZyb206IHRoaXMuX3BrLFxuICAgICAgdG86IHJlY2lwaWVudFB1YmtleSxcbiAgICAgIGNvbnRlbnQ6IHRleHQgfHwgJycsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBtc2dUeXBlOiBhdHRhY2htZW50LnR5cGUsXG4gICAgICByZXBseVRvLFxuICAgICAgYXR0YWNobWVudDoge1xuICAgICAgICAuLi5hdHRhY2htZW50LFxuICAgICAgICBkYXRhOiBhdHRhY2htZW50LmZpbGUgPyAnJyA6IGF0dGFjaG1lbnQuZGF0YSxcbiAgICAgICAgdHJhbnNmZXJJZCxcbiAgICAgICAgdG90YWxDaHVua3MsXG4gICAgICAgIGNodW5rZWQ6IHRydWUsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBzZW5kV2ViUlRDU2lnbmFsKHJlY2lwaWVudFB1YmtleTogc3RyaW5nLCBzaWduYWw6IFdlYlJUQ1NpZ25hbCkge1xuICAgIGF3YWl0IHRoaXMuc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5LCBKU09OLnN0cmluZ2lmeSh7IF9ub3N0cl9tc2dfdHlwZTogc2lnbmFsLnR5cGUsIHNkcDogc2lnbmFsLnNkcCwgY2FuZGlkYXRlOiBzaWduYWwuY2FuZGlkYXRlLCBjYWxsVHlwZTogc2lnbmFsLmNhbGxUeXBlLCBjYWxsSWQ6IHNpZ25hbC5jYWxsSWQgfSkpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQ2hhbm5lbChuYW1lOiBzdHJpbmcsIGFib3V0Pzogc3RyaW5nKTogUHJvbWlzZTxDaGFubmVsPiB7XG4gICAgaWYgKCF0aGlzLl9zaykgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aG9yaXplZCcpO1xuICAgIGNvbnN0IGV2OiBVbnNpZ25lZEV2ZW50ID0ge1xuICAgICAga2luZDogNDAsXG4gICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgIHRhZ3M6IFtdLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoeyBuYW1lLCBhYm91dDogYWJvdXQgfHwgJycgfSksXG4gICAgICBwdWJrZXk6IHRoaXMuX3BrLFxuICAgIH07XG4gICAgY29uc3QgZXZlbnQgPSBmaW5hbGl6ZUV2ZW50KGV2LCB0aGlzLl9zayk7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KFsnRVZFTlQnLCBldmVudF0pO1xuICAgIGZvciAoY29uc3QgWywgd3NdIG9mIHRoaXMuc29ja2V0cykgaWYgKHdzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB0cnkgeyB3cy5zZW5kKHBheWxvYWQpOyB9IGNhdGNoIHt9XG4gICAgY29uc3QgY2hhbm5lbDogQ2hhbm5lbCA9IHsgaWQ6IGV2ZW50LmlkLCBuYW1lLCBhYm91dCwgY3JlYXRlZEJ5OiB0aGlzLl9waywgY3JlYXRlZEF0OiBEYXRlLm5vdygpIH07XG4gICAgdGhpcy5jaGFubmVsQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IoY2hhbm5lbCkpO1xuICAgIHJldHVybiBjaGFubmVsO1xuICB9XG5cbiAgYXN5bmMgc2VuZENoYW5uZWxNZXNzYWdlKGNoYW5uZWxJZDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcsIHJlcGx5VG8/OiBSZXBseVJlZik6IFByb21pc2U8RGlyZWN0TWVzc2FnZT4ge1xuICAgIGlmICghdGhpcy5fc2spIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhvcml6ZWQnKTtcbiAgICBjb25zdCBldjogVW5zaWduZWRFdmVudCA9IHtcbiAgICAgIGtpbmQ6IDQyLFxuICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICB0YWdzOiBbWydlJywgY2hhbm5lbElkLCAnJywgJ3Jvb3QnXV0sXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh7IHRleHQsIHJlcGx5VG8gfSksXG4gICAgICBwdWJrZXk6IHRoaXMuX3BrLFxuICAgIH07XG4gICAgY29uc3QgZXZlbnQgPSBmaW5hbGl6ZUV2ZW50KGV2LCB0aGlzLl9zayk7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KFsnRVZFTlQnLCBldmVudF0pO1xuICAgIGxldCBzZW50ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbLCB3c10gb2YgdGhpcy5zb2NrZXRzKSB7XG4gICAgICBpZiAod3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIGNvbnRpbnVlO1xuICAgICAgc2VudCA9IHRydWU7XG4gICAgICB0cnkgeyB3cy5zZW5kKHBheWxvYWQpOyB9IGNhdGNoIHt9XG4gICAgfVxuICAgIGlmICghc2VudCkgdGhyb3cgbmV3IEVycm9yKCdObyBjb25uZWN0ZWQgcmVsYXlzJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgIGZyb206IHRoaXMuX3BrLFxuICAgICAgdG86ICcnLFxuICAgICAgY29udGVudDogdGV4dCxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIG1zZ1R5cGU6ICdjaGFubmVsJyxcbiAgICAgIGNoYW5uZWxJZCxcbiAgICAgIHJlcGx5VG8sXG4gICAgfTtcbiAgfVxuXG4gIHJlcXVlc3RQcm9maWxlKHB1YmtleTogc3RyaW5nKTogTm9zdHJQcm9maWxlIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMucHJvZmlsZUNhY2hlLmhhcyhwdWJrZXkpKSByZXR1cm4gdGhpcy5wcm9maWxlQ2FjaGUuZ2V0KHB1YmtleSkhO1xuICAgIGlmICh0aGlzLnBlbmRpbmdQcm9maWxlcy5oYXMocHVia2V5KSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5wZW5kaW5nUHJvZmlsZXMuYWRkKHB1YmtleSk7XG4gICAgY29uc3Qgc3ViSWQgPSAncC0nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOCk7XG4gICAgZm9yIChjb25zdCBbLCB3c10gb2YgdGhpcy5zb2NrZXRzKSB7IGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgeyB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KFsnUkVRJywgc3ViSWQsIHsga2luZHM6IFswXSwgYXV0aG9yczogW3B1YmtleV0sIGxpbWl0OiAxIH1dKSk7IGJyZWFrOyB9IH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFByb2ZpbGUocHVia2V5OiBzdHJpbmcpIHsgcmV0dXJuIHRoaXMucHJvZmlsZUNhY2hlLmdldChwdWJrZXkpIHx8IG51bGw7IH1cblxuICBhc3luYyB1cGRhdGVQcm9maWxlKHByb2ZpbGU6IE5vc3RyUHJvZmlsZSkge1xuICAgIGlmICghdGhpcy5fc2spIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhvcml6ZWQnKTtcbiAgICBjb25zdCBldjogVW5zaWduZWRFdmVudCA9IHsga2luZDogMCwgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksIHRhZ3M6IFtdLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShwcm9maWxlKSwgcHVia2V5OiB0aGlzLl9wayB9O1xuICAgIGNvbnN0IGV2ZW50ID0gZmluYWxpemVFdmVudChldiwgdGhpcy5fc2spO1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShbJ0VWRU5UJywgZXZlbnRdKTtcbiAgICBmb3IgKGNvbnN0IFssIHdzXSBvZiB0aGlzLnNvY2tldHMpIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgdHJ5IHsgd3Muc2VuZChqc29uKTsgfSBjYXRjaCB7fVxuICAgIHRoaXMucHJvZmlsZUNhY2hlLnNldCh0aGlzLl9waywgcHJvZmlsZSk7XG4gIH1cblxuICBkaXNjb25uZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgWywgdF0gb2YgdGhpcy5yZWNvbm5lY3RUaW1lcnMpIGNsZWFyVGltZW91dCh0KTtcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVycy5jbGVhcigpOyB0aGlzLnJlY29ubmVjdEF0dGVtcHRzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBbLCB3c10gb2YgdGhpcy5zb2NrZXRzKSB3cy5jbG9zZSgpO1xuICAgIHRoaXMuc29ja2V0cy5jbGVhcigpOyB0aGlzLnN1YnNjcmlwdGlvbnMuY2xlYXIoKTsgdGhpcy5yZWxheVN0YXR1cy5jbGVhcigpO1xuICB9XG5cbiAgYWRkUmVsYXkodXJsOiBzdHJpbmcpIHsgaWYgKCF0aGlzLl9yZWxheXMuaW5jbHVkZXModXJsKSkgeyB0aGlzLl9yZWxheXMucHVzaCh1cmwpOyB0aGlzLmNvbm5lY3RUb1JlbGF5KHVybCk7IH0gfVxuICByZW1vdmVSZWxheSh1cmw6IHN0cmluZykge1xuICAgIHRoaXMuX3JlbGF5cyA9IHRoaXMuX3JlbGF5cy5maWx0ZXIociA9PiByICE9PSB1cmwpO1xuICAgIGNvbnN0IHQgPSB0aGlzLnJlY29ubmVjdFRpbWVycy5nZXQodXJsKTsgaWYgKHQpIHsgY2xlYXJUaW1lb3V0KHQpOyB0aGlzLnJlY29ubmVjdFRpbWVycy5kZWxldGUodXJsKTsgfVxuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMuZGVsZXRlKHVybCk7XG4gICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tldHMuZ2V0KHVybCk7IGlmICh3cykgeyB3cy5jbG9zZSgpOyB0aGlzLnNvY2tldHMuZGVsZXRlKHVybCk7IH1cbiAgICB0aGlzLnJlbGF5U3RhdHVzLmRlbGV0ZSh1cmwpO1xuICB9XG5cbiAgc2hvcnRlbktleShrZXk6IHN0cmluZykgeyByZXR1cm4gKCFrZXkgfHwga2V5Lmxlbmd0aCA8IDE2KSA/IGtleSA6IGtleS5zbGljZSgwLCA4KSArICfigKYnICsga2V5LnNsaWNlKC04KTsgfVxuICBpc1ZhbGlkSGV4S2V5KGtleTogc3RyaW5nKSB7IHJldHVybiAvXlswLTlhLWZBLUZdezY0fSQvLnRlc3Qoa2V5KTsgfVxufVxuXG5leHBvcnQgY29uc3Qgbm9zdHJDbGllbnQgPSBuZXcgTm9zdHJDbGllbnQoKTtcbmV4cG9ydCB7IERFRkFVTFRfUkVMQVlTIH07XG4iXSwibmFtZXMiOlsiZ2VuZXJhdGVTZWNyZXRLZXkiLCJnZXRQdWJsaWNLZXkiLCJmaW5hbGl6ZUV2ZW50IiwiZW5jcnlwdCIsImRlY3J5cHQiLCJieXRlc1RvSGV4IiwiaGV4VG9CeXRlcyIsImVuc3VyZVRyYW5zZmVyIiwiaXNUcmFuc2ZlckNvbXBsZXRlIiwic3RvcmVDaHVuayIsIkRFRkFVTFRfUkVMQVlTIiwiTm9zdHJDbGllbnQiLCJwdWJsaWNLZXkiLCJfcGsiLCJwcml2YXRlS2V5SGV4IiwiX3NrIiwicmVsYXlzIiwiX3JlbGF5cyIsImNoYW5uZWxzIiwiX2NoYW5uZWxzIiwic2siLCJnZXRSZWxheVN0YXR1cyIsInJlbGF5IiwicmVsYXlTdGF0dXMiLCJnZXQiLCJjb25uZWN0ZWRSZWxheUNvdW50IiwiYyIsImZvckVhY2giLCJzIiwiZ2VuZXJhdGVLZXlzIiwicGsiLCJwcml2YXRlS2V5IiwibG9naW4iLCJfc3RvcHBlZCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJsb2dvdXQiLCJkaXNjb25uZWN0QWxsIiwicmVtb3ZlSXRlbSIsInRyeUF1dG9Mb2dpbiIsImdldEl0ZW0iLCJsZW5ndGgiLCJvbk1lc3NhZ2UiLCJjYiIsIm1lc3NhZ2VDYWxsYmFja3MiLCJhZGQiLCJkZWxldGUiLCJvbkNoYW5uZWwiLCJjaGFubmVsQ2FsbGJhY2tzIiwib25DaGFubmVsTWVzc2FnZSIsImNoYW5uZWxNZXNzYWdlQ2FsbGJhY2tzIiwib25Qcm9maWxlIiwicHJvZmlsZUNhbGxiYWNrcyIsIm9uQ29ubmVjdGlvbiIsImNvbm5lY3Rpb25DYWxsYmFja3MiLCJvblNpZ25hbCIsInNpZ25hbENhbGxiYWNrcyIsImNvbm5lY3RUb1JlbGF5cyIsInIiLCJjb25uZWN0VG9SZWxheSIsInNldENoYW5uZWxzIiwiY2hhbm5lbElkcyIsIlNldCIsImZpbHRlciIsIkJvb2xlYW4iLCJ3cyIsInNvY2tldHMiLCJyZWFkeVN0YXRlIiwiV2ViU29ja2V0IiwiT1BFTiIsInN1YnNjcmliZVRvQ2hhbm5lbHMiLCJ1cmwiLCJoYXMiLCJlIiwiQ09OTkVDVElORyIsInNldCIsImN0Iiwic2V0VGltZW91dCIsImNsb3NlIiwib25vcGVuIiwiY2xlYXJUaW1lb3V0IiwicmVjb25uZWN0QXR0ZW1wdHMiLCJzdWJzY3JpYmVUb01lc3NhZ2VzIiwib25jbG9zZSIsInNjaGVkdWxlUmVjb25uZWN0Iiwib25lcnJvciIsIm9ubWVzc2FnZSIsImhhbmRsZVJlbGF5TWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJyZWNvbm5lY3RUaW1lcnMiLCJhIiwiZCIsIk1hdGgiLCJtaW4iLCJwb3ciLCJBcnJheSIsImlzQXJyYXkiLCJldiIsInNlZW5FdmVudHMiLCJpZCIsImtpbmQiLCJoYW5kbGVFbmNyeXB0ZWRETSIsImhhbmRsZVByb2ZpbGVFdmVudCIsImhhbmRsZUNoYW5uZWxFdmVudCIsImhhbmRsZUNoYW5uZWxNZXNzYWdlRXZlbnQiLCJldmVudCIsInBUYWciLCJ0YWdzIiwiZmluZCIsInQiLCJpc0Zvck1lIiwiaXNGcm9tTWUiLCJwdWJrZXkiLCJvdGhlciIsImRlYyIsImNvbnRlbnQiLCJwIiwiX25vc3RyX21zZ190eXBlIiwibXQiLCJmcm9tIiwidG8iLCJ0ZXh0IiwidGltZXN0YW1wIiwiY3JlYXRlZF9hdCIsIm1zZ1R5cGUiLCJyZXBseVRvIiwiaW5jbHVkZXMiLCJ0eXBlIiwic2RwIiwiY2FuZGlkYXRlIiwiY2FsbFR5cGUiLCJjYWxsSWQiLCJoYW5kbGVGaWxlQ2h1bmsiLCJ0cmFuc2ZlcklkIiwiZmlsZVR5cGUiLCJmaWxlTmFtZSIsIm1pbWVUeXBlIiwic2l6ZSIsInRvdGFsQ2h1bmtzIiwiYXR0YWNobWVudCIsIm5hbWUiLCJldmVudElkIiwiY2h1bmtJbmRleCIsImRvbmUiLCJjaHVua2VkIiwicHJvZmlsZUNhY2hlIiwicGVuZGluZ1Byb2ZpbGVzIiwicGF5bG9hZCIsImNoYW5uZWwiLCJ0cmltIiwic2xpY2UiLCJhYm91dCIsImNyZWF0ZWRCeSIsImNyZWF0ZWRBdCIsImVUYWciLCJjaGFubmVsSWQiLCJyZWxheVVybCIsInN1YklkIiwicmFuZG9tIiwidG9TdHJpbmciLCJzaW5jZSIsImZsb29yIiwiRGF0ZSIsIm5vdyIsInNlbmQiLCJzdHJpbmdpZnkiLCJraW5kcyIsImF1dGhvcnMiLCJzdWJzY3JpcHRpb25zIiwiZmlsdGVycyIsImlkcyIsInNlbmRFbmNyeXB0ZWRQYXlsb2FkIiwicmVjaXBpZW50UHVia2V5IiwiRXJyb3IiLCJlbmNyeXB0ZWQiLCJqc29uIiwib3BlbiIsInB1c2giLCJieXRlc1RvQmFzZTY0IiwiYnl0ZXMiLCJiaW4iLCJzdGVwIiwiaSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInN1YmFycmF5IiwiYnRvYSIsInNlbmREaXJlY3RNZXNzYWdlIiwic2VuZEF0dGFjaG1lbnQiLCJvblByb2dyZXNzIiwibWF4U2l6ZSIsImZpbGUiLCJiNjQiLCJmaWxlU2l6ZSIsImNlaWwiLCJDSFVOS19TSVpFIiwibGFzdElkIiwic2VudCIsImJhdGNoIiwiUEFSQUxMRUwiLCJwcm9taXNlcyIsImxvY2FsQ2h1bmtzIiwiaiIsImNodW5rRGF0YSIsInN0YXJ0IiwiZW5kIiwiVWludDhBcnJheSIsImFycmF5QnVmZmVyIiwiYmFzZTY0Q2h1bmtTaXplIiwiUHJvbWlzZSIsImFsbCIsImNodW5rIiwic2VuZFdlYlJUQ1NpZ25hbCIsInNpZ25hbCIsImNyZWF0ZUNoYW5uZWwiLCJzZW5kQ2hhbm5lbE1lc3NhZ2UiLCJyZXF1ZXN0UHJvZmlsZSIsImxpbWl0IiwiZ2V0UHJvZmlsZSIsInVwZGF0ZVByb2ZpbGUiLCJwcm9maWxlIiwiY2xlYXIiLCJhZGRSZWxheSIsInJlbW92ZVJlbGF5Iiwic2hvcnRlbktleSIsImtleSIsImlzVmFsaWRIZXhLZXkiLCJ0ZXN0IiwiTWFwIiwibm9zdHJDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/nostr.ts\n"));

/***/ })

});