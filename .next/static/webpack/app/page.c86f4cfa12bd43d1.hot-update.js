"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/fileUtils.ts":
/*!******************************!*\
  !*** ./src/lib/fileUtils.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64ToBlob: function() { return /* binding */ base64ToBlob; },\n/* harmony export */   downloadAttachment: function() { return /* binding */ downloadAttachment; },\n/* harmony export */   fileToBase64: function() { return /* binding */ fileToBase64; },\n/* harmony export */   formatFileSize: function() { return /* binding */ formatFileSize; },\n/* harmony export */   getFileIcon: function() { return /* binding */ getFileIcon; },\n/* harmony export */   isAudioType: function() { return /* binding */ isAudioType; },\n/* harmony export */   isImageType: function() { return /* binding */ isImageType; },\n/* harmony export */   processFile: function() { return /* binding */ processFile; }\n/* harmony export */ });\nconst MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024;\nconst INLINE_LIMIT = 8 * 1024 * 1024;\nconst IMAGE_TYPES = [\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/gif\",\n    \"image/webp\",\n    \"image/svg+xml\"\n];\nconst AUDIO_TYPES = [\n    \"audio/webm\",\n    \"audio/mpeg\",\n    \"audio/ogg\",\n    \"audio/wav\",\n    \"audio/aac\"\n];\nfunction isImageType(mimeType) {\n    return IMAGE_TYPES.includes(mimeType);\n}\nfunction isAudioType(mimeType) {\n    return AUDIO_TYPES.includes(mimeType) || mimeType.startsWith(\"audio/\");\n}\nfunction formatFileSize(bytes) {\n    if (bytes < 1024) return \"\".concat(bytes, \" B\");\n    if (bytes < 1024 * 1024) return \"\".concat((bytes / 1024).toFixed(1), \" KB\");\n    if (bytes < 1024 * 1024 * 1024) return \"\".concat((bytes / (1024 * 1024)).toFixed(1), \" MB\");\n    return \"\".concat((bytes / (1024 * 1024 * 1024)).toFixed(2), \" GB\");\n}\nfunction fileToBase64(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = ()=>{\n            const result = reader.result;\n            const base64 = result.split(\",\")[1];\n            resolve(base64);\n        };\n        reader.onerror = reject;\n        reader.readAsDataURL(file);\n    });\n}\nfunction compressImage(file, maxWidth, maxHeight, quality) {\n    return new Promise((resolve, reject)=>{\n        const img = new window.Image();\n        const url = URL.createObjectURL(file);\n        img.onload = ()=>{\n            URL.revokeObjectURL(url);\n            let w = img.width;\n            let h = img.height;\n            if (w > maxWidth || h > maxHeight) {\n                const ratio = Math.min(maxWidth / w, maxHeight / h);\n                w = Math.round(w * ratio);\n                h = Math.round(h * ratio);\n            }\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = w;\n            canvas.height = h;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) return reject(new Error(\"Canvas context unavailable\"));\n            ctx.drawImage(img, 0, 0, w, h);\n            const dataUrl = canvas.toDataURL(\"image/jpeg\", quality);\n            resolve(dataUrl.split(\",\")[1]);\n        };\n        img.onerror = reject;\n        img.src = url;\n    });\n}\nasync function processFile(file) {\n    if (file.size > MAX_FILE_SIZE) {\n        throw new Error(\"File is too large. Maximum: \".concat(formatFileSize(MAX_FILE_SIZE), \".\"));\n    }\n    const isImage = isImageType(file.type);\n    const isAudio = isAudioType(file.type);\n    let mimeType = file.type || \"application/octet-stream\";\n    let attachmentType = \"file\";\n    if (isImage) {\n        attachmentType = \"image\";\n        mimeType = \"image/jpeg\";\n    } else if (isAudio) {\n        attachmentType = \"audio\";\n    }\n    if (file.size > INLINE_LIMIT) {\n        return {\n            type: attachmentType,\n            name: file.name,\n            mimeType,\n            data: \"\",\n            size: file.size,\n            file,\n            chunked: true\n        };\n    }\n    const base64 = isImage && file.size > 200 * 1024 ? await compressImage(file, 2048, 2048, 0.82) : await fileToBase64(file);\n    return {\n        type: attachmentType,\n        name: file.name,\n        mimeType,\n        data: base64,\n        size: file.size,\n        file\n    };\n}\nfunction base64ToBlob(base64, mimeType) {\n    const byteChars = atob(base64);\n    const byteNumbers = new Uint8Array(byteChars.length);\n    for(let i = 0; i < byteChars.length; i++)byteNumbers[i] = byteChars.charCodeAt(i);\n    return new Blob([\n        byteNumbers.buffer\n    ], {\n        type: mimeType\n    });\n}\nfunction downloadAttachment(attachment) {\n    const blob = base64ToBlob(attachment.data, attachment.mimeType);\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = attachment.name;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n}\nfunction getFileIcon(mimeType) {\n    if (mimeType.startsWith(\"image/\")) return \"\\uD83D\\uDDBC️\";\n    if (mimeType.startsWith(\"video/\")) return \"\\uD83C\\uDFAC\";\n    if (mimeType.startsWith(\"audio/\")) return \"\\uD83C\\uDFB5\";\n    if (mimeType.includes(\"pdf\")) return \"\\uD83D\\uDCC4\";\n    if (mimeType.includes(\"zip\") || mimeType.includes(\"rar\") || mimeType.includes(\"tar\")) return \"\\uD83D\\uDCE6\";\n    if (mimeType.includes(\"text\")) return \"\\uD83D\\uDCDD\";\n    if (mimeType.includes(\"json\") || mimeType.includes(\"xml\")) return \"⚙️\";\n    return \"\\uD83D\\uDCCE\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZmlsZVV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRUEsTUFBTUEsZ0JBQWdCLElBQUksT0FBTyxPQUFPO0FBQ3hDLE1BQU1DLGVBQWUsSUFBSSxPQUFPO0FBQ2hDLE1BQU1DLGNBQWM7SUFBQztJQUFjO0lBQWE7SUFBYTtJQUFjO0NBQWdCO0FBQzNGLE1BQU1DLGNBQWM7SUFBQztJQUFjO0lBQWM7SUFBYTtJQUFhO0NBQVk7QUFFaEYsU0FBU0MsWUFBWUMsUUFBZ0I7SUFDMUMsT0FBT0gsWUFBWUksUUFBUSxDQUFDRDtBQUM5QjtBQUVPLFNBQVNFLFlBQVlGLFFBQWdCO0lBQzFDLE9BQU9GLFlBQVlHLFFBQVEsQ0FBQ0QsYUFBYUEsU0FBU0csVUFBVSxDQUFDO0FBQy9EO0FBRU8sU0FBU0MsZUFBZUMsS0FBYTtJQUMxQyxJQUFJQSxRQUFRLE1BQU0sT0FBTyxHQUFTLE9BQU5BLE9BQU07SUFDbEMsSUFBSUEsUUFBUSxPQUFPLE1BQU0sT0FBTyxHQUE2QixPQUExQixDQUFDQSxRQUFRLElBQUcsRUFBR0MsT0FBTyxDQUFDLElBQUc7SUFDN0QsSUFBSUQsUUFBUSxPQUFPLE9BQU8sTUFBTSxPQUFPLEdBQXNDLE9BQW5DLENBQUNBLFFBQVMsUUFBTyxJQUFHLENBQUMsRUFBR0MsT0FBTyxDQUFDLElBQUc7SUFDN0UsT0FBTyxHQUE2QyxPQUExQyxDQUFDRCxRQUFTLFFBQU8sT0FBTyxJQUFHLENBQUMsRUFBR0MsT0FBTyxDQUFDLElBQUc7QUFDdEQ7QUFFTyxTQUFTQyxhQUFhQyxJQUFVO0lBQ3JDLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUMzQixNQUFNQyxTQUFTLElBQUlDO1FBQ25CRCxPQUFPRSxNQUFNLEdBQUc7WUFDZCxNQUFNQyxTQUFTSCxPQUFPRyxNQUFNO1lBQzVCLE1BQU1DLFNBQVNELE9BQU9FLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNuQ1AsUUFBUU07UUFD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RUFBRTtRQUFFZixNQUFNcEQ7SUFBUztBQUN4RTtBQUVPLFNBQVNvRSxtQkFBbUJDLFVBQXNCO0lBQ3ZELE1BQU1DLE9BQU9aLGFBQWFXLFdBQVdiLElBQUksRUFBRWEsV0FBV3JFLFFBQVE7SUFDOUQsTUFBTTJCLE1BQU1DLElBQUlDLGVBQWUsQ0FBQ3lDO0lBQ2hDLE1BQU1DLElBQUkvQixTQUFTQyxhQUFhLENBQUM7SUFDakM4QixFQUFFQyxJQUFJLEdBQUc3QztJQUNUNEMsRUFBRUUsUUFBUSxHQUFHSixXQUFXZCxJQUFJO0lBQzVCZixTQUFTa0MsSUFBSSxDQUFDQyxXQUFXLENBQUNKO0lBQzFCQSxFQUFFSyxLQUFLO0lBQ1BwQyxTQUFTa0MsSUFBSSxDQUFDRyxXQUFXLENBQUNOO0lBQzFCM0MsSUFBSUUsZUFBZSxDQUFDSDtBQUN0QjtBQUVPLFNBQVNtRCxZQUFZOUUsUUFBZ0I7SUFDMUMsSUFBSUEsU0FBU0csVUFBVSxDQUFDLFdBQVcsT0FBTztJQUMxQyxJQUFJSCxTQUFTRyxVQUFVLENBQUMsV0FBVyxPQUFPO0lBQzFDLElBQUlILFNBQVNHLFVBQVUsQ0FBQyxXQUFXLE9BQU87SUFDMUMsSUFBSUgsU0FBU0MsUUFBUSxDQUFDLFFBQVEsT0FBTztJQUNyQyxJQUFJRCxTQUFTQyxRQUFRLENBQUMsVUFBVUQsU0FBU0MsUUFBUSxDQUFDLFVBQVVELFNBQVNDLFFBQVEsQ0FBQyxRQUFRLE9BQU87SUFDN0YsSUFBSUQsU0FBU0MsUUFBUSxDQUFDLFNBQVMsT0FBTztJQUN0QyxJQUFJRCxTQUFTQyxRQUFRLENBQUMsV0FBV0QsU0FBU0MsUUFBUSxDQUFDLFFBQVEsT0FBTztJQUNsRSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9maWxlVXRpbHMudHM/YzBiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEF0dGFjaG1lbnQgfSBmcm9tICcuL25vc3RyJztcblxuY29uc3QgTUFYX0ZJTEVfU0laRSA9IDIgKiAxMDI0ICogMTAyNCAqIDEwMjQ7XG5jb25zdCBJTkxJTkVfTElNSVQgPSA4ICogMTAyNCAqIDEwMjQ7XG5jb25zdCBJTUFHRV9UWVBFUyA9IFsnaW1hZ2UvanBlZycsICdpbWFnZS9wbmcnLCAnaW1hZ2UvZ2lmJywgJ2ltYWdlL3dlYnAnLCAnaW1hZ2Uvc3ZnK3htbCddO1xuY29uc3QgQVVESU9fVFlQRVMgPSBbJ2F1ZGlvL3dlYm0nLCAnYXVkaW8vbXBlZycsICdhdWRpby9vZ2cnLCAnYXVkaW8vd2F2JywgJ2F1ZGlvL2FhYyddO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbWFnZVR5cGUobWltZVR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gSU1BR0VfVFlQRVMuaW5jbHVkZXMobWltZVR5cGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdWRpb1R5cGUobWltZVR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gQVVESU9fVFlQRVMuaW5jbHVkZXMobWltZVR5cGUpIHx8IG1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2F1ZGlvLycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RmlsZVNpemUoYnl0ZXM6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChieXRlcyA8IDEwMjQpIHJldHVybiBgJHtieXRlc30gQmA7XG4gIGlmIChieXRlcyA8IDEwMjQgKiAxMDI0KSByZXR1cm4gYCR7KGJ5dGVzIC8gMTAyNCkudG9GaXhlZCgxKX0gS0JgO1xuICBpZiAoYnl0ZXMgPCAxMDI0ICogMTAyNCAqIDEwMjQpIHJldHVybiBgJHsoYnl0ZXMgLyAoMTAyNCAqIDEwMjQpKS50b0ZpeGVkKDEpfSBNQmA7XG4gIHJldHVybiBgJHsoYnl0ZXMgLyAoMTAyNCAqIDEwMjQgKiAxMDI0KSkudG9GaXhlZCgyKX0gR0JgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsZVRvQmFzZTY0KGZpbGU6IEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRlci5yZXN1bHQgYXMgc3RyaW5nO1xuICAgICAgY29uc3QgYmFzZTY0ID0gcmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICByZXNvbHZlKGJhc2U2NCk7XG4gICAgfTtcbiAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbXByZXNzSW1hZ2UoZmlsZTogRmlsZSwgbWF4V2lkdGg6IG51bWJlciwgbWF4SGVpZ2h0OiBudW1iZXIsIHF1YWxpdHk6IG51bWJlcik6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IHdpbmRvdy5JbWFnZSgpO1xuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgIGxldCB3ID0gaW1nLndpZHRoO1xuICAgICAgbGV0IGggPSBpbWcuaGVpZ2h0O1xuICAgICAgaWYgKHcgPiBtYXhXaWR0aCB8fCBoID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4V2lkdGggLyB3LCBtYXhIZWlnaHQgLyBoKTtcbiAgICAgICAgdyA9IE1hdGgucm91bmQodyAqIHJhdGlvKTtcbiAgICAgICAgaCA9IE1hdGgucm91bmQoaCAqIHJhdGlvKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gdztcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoIWN0eCkgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0NhbnZhcyBjb250ZXh0IHVuYXZhaWxhYmxlJykpO1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHcsIGgpO1xuICAgICAgY29uc3QgZGF0YVVybCA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCBxdWFsaXR5KTtcbiAgICAgIHJlc29sdmUoZGF0YVVybC5zcGxpdCgnLCcpWzFdKTtcbiAgICB9O1xuICAgIGltZy5vbmVycm9yID0gcmVqZWN0O1xuICAgIGltZy5zcmMgPSB1cmw7XG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ZpbGUoZmlsZTogRmlsZSk6IFByb21pc2U8QXR0YWNobWVudD4ge1xuICBpZiAoZmlsZS5zaXplID4gTUFYX0ZJTEVfU0laRSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSBpcyB0b28gbGFyZ2UuIE1heGltdW06ICR7Zm9ybWF0RmlsZVNpemUoTUFYX0ZJTEVfU0laRSl9LmApO1xuICB9XG5cbiAgY29uc3QgaXNJbWFnZSA9IGlzSW1hZ2VUeXBlKGZpbGUudHlwZSk7XG4gIGNvbnN0IGlzQXVkaW8gPSBpc0F1ZGlvVHlwZShmaWxlLnR5cGUpO1xuICBsZXQgbWltZVR5cGUgPSBmaWxlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gIGxldCBhdHRhY2htZW50VHlwZTogJ2ltYWdlJyB8ICdmaWxlJyB8ICdhdWRpbycgPSAnZmlsZSc7XG5cbiAgaWYgKGlzSW1hZ2UpIHtcbiAgICAgIGF0dGFjaG1lbnRUeXBlID0gJ2ltYWdlJztcbiAgICAgIG1pbWVUeXBlID0gJ2ltYWdlL2pwZWcnO1xuICB9IGVsc2UgaWYgKGlzQXVkaW8pIHtcbiAgICAgIGF0dGFjaG1lbnRUeXBlID0gJ2F1ZGlvJztcbiAgfVxuXG4gIGlmIChmaWxlLnNpemUgPiBJTkxJTkVfTElNSVQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogYXR0YWNobWVudFR5cGUsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICBtaW1lVHlwZSxcbiAgICAgIGRhdGE6ICcnLFxuICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgZmlsZSxcbiAgICAgIGNodW5rZWQ6IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGJhc2U2NCA9IGlzSW1hZ2UgJiYgZmlsZS5zaXplID4gMjAwICogMTAyNFxuICAgID8gYXdhaXQgY29tcHJlc3NJbWFnZShmaWxlLCAyMDQ4LCAyMDQ4LCAwLjgyKVxuICAgIDogYXdhaXQgZmlsZVRvQmFzZTY0KGZpbGUpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogYXR0YWNobWVudFR5cGUsXG4gICAgbmFtZTogZmlsZS5uYW1lLFxuICAgIG1pbWVUeXBlLFxuICAgIGRhdGE6IGJhc2U2NCxcbiAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgZmlsZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQmxvYihiYXNlNjQ6IHN0cmluZywgbWltZVR5cGU6IHN0cmluZyk6IEJsb2Ige1xuICBjb25zdCBieXRlQ2hhcnMgPSBhdG9iKGJhc2U2NCk7XG4gIGNvbnN0IGJ5dGVOdW1iZXJzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUNoYXJzLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUNoYXJzLmxlbmd0aDsgaSsrKSBieXRlTnVtYmVyc1tpXSA9IGJ5dGVDaGFycy5jaGFyQ29kZUF0KGkpO1xuICByZXR1cm4gbmV3IEJsb2IoW2J5dGVOdW1iZXJzLmJ1ZmZlciBhcyBBcnJheUJ1ZmZlcl0sIHsgdHlwZTogbWltZVR5cGUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZEF0dGFjaG1lbnQoYXR0YWNobWVudDogQXR0YWNobWVudCkge1xuICBjb25zdCBibG9iID0gYmFzZTY0VG9CbG9iKGF0dGFjaG1lbnQuZGF0YSwgYXR0YWNobWVudC5taW1lVHlwZSk7XG4gIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGEuaHJlZiA9IHVybDtcbiAgYS5kb3dubG9hZCA9IGF0dGFjaG1lbnQubmFtZTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgYS5jbGljaygpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlSWNvbihtaW1lVHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKG1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSByZXR1cm4gJ/CflrzvuI8nO1xuICBpZiAobWltZVR5cGUuc3RhcnRzV2l0aCgndmlkZW8vJykpIHJldHVybiAn8J+OrCc7XG4gIGlmIChtaW1lVHlwZS5zdGFydHNXaXRoKCdhdWRpby8nKSkgcmV0dXJuICfwn461JztcbiAgaWYgKG1pbWVUeXBlLmluY2x1ZGVzKCdwZGYnKSkgcmV0dXJuICfwn5OEJztcbiAgaWYgKG1pbWVUeXBlLmluY2x1ZGVzKCd6aXAnKSB8fCBtaW1lVHlwZS5pbmNsdWRlcygncmFyJykgfHwgbWltZVR5cGUuaW5jbHVkZXMoJ3RhcicpKSByZXR1cm4gJ/Cfk6YnO1xuICBpZiAobWltZVR5cGUuaW5jbHVkZXMoJ3RleHQnKSkgcmV0dXJuICfwn5OdJztcbiAgaWYgKG1pbWVUeXBlLmluY2x1ZGVzKCdqc29uJykgfHwgbWltZVR5cGUuaW5jbHVkZXMoJ3htbCcpKSByZXR1cm4gJ+Kame+4jyc7XG4gIHJldHVybiAn8J+Tjic7XG59XG4iXSwibmFtZXMiOlsiTUFYX0ZJTEVfU0laRSIsIklOTElORV9MSU1JVCIsIklNQUdFX1RZUEVTIiwiQVVESU9fVFlQRVMiLCJpc0ltYWdlVHlwZSIsIm1pbWVUeXBlIiwiaW5jbHVkZXMiLCJpc0F1ZGlvVHlwZSIsInN0YXJ0c1dpdGgiLCJmb3JtYXRGaWxlU2l6ZSIsImJ5dGVzIiwidG9GaXhlZCIsImZpbGVUb0Jhc2U2NCIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZXN1bHQiLCJiYXNlNjQiLCJzcGxpdCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiY29tcHJlc3NJbWFnZSIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwicXVhbGl0eSIsImltZyIsIndpbmRvdyIsIkltYWdlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmV2b2tlT2JqZWN0VVJMIiwidyIsIndpZHRoIiwiaCIsImhlaWdodCIsInJhdGlvIiwiTWF0aCIsIm1pbiIsInJvdW5kIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsIkVycm9yIiwiZHJhd0ltYWdlIiwiZGF0YVVybCIsInRvRGF0YVVSTCIsInNyYyIsInByb2Nlc3NGaWxlIiwic2l6ZSIsImlzSW1hZ2UiLCJ0eXBlIiwiaXNBdWRpbyIsImF0dGFjaG1lbnRUeXBlIiwibmFtZSIsImRhdGEiLCJjaHVua2VkIiwiYmFzZTY0VG9CbG9iIiwiYnl0ZUNoYXJzIiwiYXRvYiIsImJ5dGVOdW1iZXJzIiwiVWludDhBcnJheSIsImxlbmd0aCIsImkiLCJjaGFyQ29kZUF0IiwiQmxvYiIsImJ1ZmZlciIsImRvd25sb2FkQXR0YWNobWVudCIsImF0dGFjaG1lbnQiLCJibG9iIiwiYSIsImhyZWYiLCJkb3dubG9hZCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwicmVtb3ZlQ2hpbGQiLCJnZXRGaWxlSWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/fileUtils.ts\n"));

/***/ })

});