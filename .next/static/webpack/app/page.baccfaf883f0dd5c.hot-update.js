"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/nostr.ts":
/*!**************************!*\
  !*** ./src/lib/nostr.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_RELAYS: function() { return /* binding */ DEFAULT_RELAYS; },\n/* harmony export */   nostrClient: function() { return /* binding */ nostrClient; }\n/* harmony export */ });\n/* harmony import */ var nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools/pure */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/pure.js\");\n/* harmony import */ var nostr_tools_nip04__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nostr-tools/nip04 */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/nip04.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _chunkStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunkStore */ \"(app-pages-browser)/./src/lib/chunkStore.ts\");\n\n\n\n\nconst DEFAULT_RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://nos.lol\",\n    \"wss://relay.snort.social\",\n    \"wss://relay.primal.net\",\n    \"wss://purplepag.es\",\n    \"wss://nostr.mom\",\n    \"wss://relay.nostr.bg\"\n];\nclass NostrClient {\n    get publicKey() {\n        return this._pk;\n    }\n    get privateKeyHex() {\n        return this._sk ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(this._sk) : \"\";\n    }\n    get relays() {\n        return [\n            ...this._relays\n        ];\n    }\n    get channels() {\n        return [\n            ...this._channels\n        ];\n    }\n    get sk() {\n        return this._sk;\n    }\n    getRelayStatus(relay) {\n        return this.relayStatus.get(relay) || \"disconnected\";\n    }\n    get connectedRelayCount() {\n        let c = 0;\n        this.relayStatus.forEach((s)=>{\n            if (s === \"connected\") {\n                c++;\n            }\n        });\n        return c;\n    }\n    generateKeys() {\n        const sk = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n        const pk = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(sk);\n        return {\n            privateKey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(sk),\n            publicKey: pk\n        };\n    }\n    login(privateKeyHex) {\n        const sk = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(privateKeyHex);\n        const pk = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(sk);\n        this._sk = sk;\n        this._pk = pk;\n        this._stopped = false;\n        localStorage.setItem(\"nostr_sk\", privateKeyHex);\n        return pk;\n    }\n    logout() {\n        this._stopped = true;\n        this.disconnectAll();\n        this._sk = null;\n        this._pk = \"\";\n        localStorage.removeItem(\"nostr_sk\");\n        localStorage.removeItem(\"nostr_contacts\");\n    }\n    tryAutoLogin() {\n        const sk = localStorage.getItem(\"nostr_sk\");\n        if ((sk === null || sk === void 0 ? void 0 : sk.length) === 64) {\n            try {\n                this.login(sk);\n                return true;\n            } catch (e) {\n                localStorage.removeItem(\"nostr_sk\");\n            }\n        }\n        return false;\n    }\n    onMessage(cb) {\n        this.messageCallbacks.add(cb);\n        return ()=>{\n            this.messageCallbacks.delete(cb);\n        };\n    }\n    onChannel(cb) {\n        this.channelCallbacks.add(cb);\n        return ()=>{\n            this.channelCallbacks.delete(cb);\n        };\n    }\n    onChannelMessage(cb) {\n        this.channelMessageCallbacks.add(cb);\n        return ()=>{\n            this.channelMessageCallbacks.delete(cb);\n        };\n    }\n    onProfile(cb) {\n        this.profileCallbacks.add(cb);\n        return ()=>{\n            this.profileCallbacks.delete(cb);\n        };\n    }\n    onConnection(cb) {\n        this.connectionCallbacks.add(cb);\n        return ()=>{\n            this.connectionCallbacks.delete(cb);\n        };\n    }\n    onSignal(cb) {\n        this.signalCallbacks.add(cb);\n        return ()=>{\n            this.signalCallbacks.delete(cb);\n        };\n    }\n    async connectToRelays() {\n        for (const r of this._relays)this.connectToRelay(r);\n    }\n    setChannels(channelIds) {\n        this._channels = [\n            ...new Set(channelIds.filter(Boolean))\n        ];\n        for (const [relay, ws] of this.sockets){\n            if (ws.readyState === WebSocket.OPEN) this.subscribeToChannels(relay);\n        }\n    }\n    connectToRelay(url) {\n        if (this._stopped) return;\n        if (this.sockets.has(url)) {\n            const e = this.sockets.get(url);\n            if (e.readyState === WebSocket.OPEN || e.readyState === WebSocket.CONNECTING) return;\n        }\n        this.relayStatus.set(url, \"connecting\");\n        this.connectionCallbacks.forEach((cb)=>cb(url, \"disconnected\"));\n        try {\n            const ws = new WebSocket(url);\n            const ct = setTimeout(()=>{\n                if (ws.readyState !== WebSocket.OPEN) ws.close();\n            }, 8000);\n            this.sockets.set(url, ws);\n            ws.onopen = ()=>{\n                clearTimeout(ct);\n                this.reconnectAttempts.set(url, 0);\n                this.relayStatus.set(url, \"connected\");\n                this.connectionCallbacks.forEach((cb)=>cb(url, \"connected\"));\n                this.subscribeToMessages(url);\n            };\n            ws.onclose = ()=>{\n                clearTimeout(ct);\n                this.relayStatus.set(url, \"disconnected\");\n                this.connectionCallbacks.forEach((cb)=>cb(url, \"disconnected\"));\n                this.sockets.delete(url);\n                this.scheduleReconnect(url);\n            };\n            ws.onerror = ()=>{\n                this.relayStatus.set(url, \"error\");\n                this.connectionCallbacks.forEach((cb)=>cb(url, \"error\"));\n            };\n            ws.onmessage = (e)=>{\n                try {\n                    this.handleRelayMessage(JSON.parse(e.data));\n                } catch (e) {}\n            };\n        } catch (e) {\n            this.relayStatus.set(url, \"error\");\n            this.scheduleReconnect(url);\n        }\n    }\n    scheduleReconnect(url) {\n        if (this._stopped) return;\n        const e = this.reconnectTimers.get(url);\n        if (e) clearTimeout(e);\n        const a = this.reconnectAttempts.get(url) || 0;\n        const d = Math.min(3000 * Math.pow(2, a), 60000);\n        this.reconnectAttempts.set(url, a + 1);\n        this.reconnectTimers.set(url, setTimeout(()=>{\n            if (!this._stopped && this._sk) this.connectToRelay(url);\n        }, d));\n    }\n    handleRelayMessage(data) {\n        if (!Array.isArray(data)) return;\n        if (data[0] === \"EVENT\") {\n            const ev = data[2];\n            if (!ev || this.seenEvents.has(ev.id)) return;\n            this.seenEvents.add(ev.id);\n            if (ev.kind === 4) this.handleEncryptedDM(ev);\n            else if (ev.kind === 0) this.handleProfileEvent(ev);\n            else if (ev.kind === 40) this.handleChannelEvent(ev);\n            else if (ev.kind === 42) this.handleChannelMessageEvent(ev);\n        }\n    }\n    async handleEncryptedDM(event) {\n        if (!this._sk) return;\n        const pTag = event.tags.find((t)=>t[0] === \"p\");\n        if (!pTag) return;\n        const isForMe = pTag[1] === this._pk, isFromMe = event.pubkey === this._pk;\n        if (!isForMe && !isFromMe) return;\n        const other = isFromMe ? pTag[1] : event.pubkey;\n        try {\n            const dec = await (0,nostr_tools_nip04__WEBPACK_IMPORTED_MODULE_3__.decrypt)(this._sk, other, event.content);\n            try {\n                const p = JSON.parse(dec);\n                if (p === null || p === void 0 ? void 0 : p._nostr_msg_type) {\n                    const mt = p._nostr_msg_type;\n                    if (mt === \"text\") {\n                        this.messageCallbacks.forEach((cb)=>cb({\n                                id: event.id,\n                                from: event.pubkey,\n                                to: pTag[1],\n                                content: p.text || \"\",\n                                timestamp: event.created_at * 1000,\n                                msgType: \"text\",\n                                replyTo: p.replyTo\n                            }));\n                        return;\n                    }\n                    if ([\n                        \"webrtc-offer\",\n                        \"webrtc-answer\",\n                        \"webrtc-ice\",\n                        \"call-request\",\n                        \"call-accept\",\n                        \"call-reject\",\n                        \"call-end\"\n                    ].includes(mt)) {\n                        this.signalCallbacks.forEach((cb)=>cb(event.pubkey, {\n                                type: mt,\n                                sdp: p.sdp,\n                                candidate: p.candidate,\n                                callType: p.callType\n                            }));\n                        return;\n                    }\n                    if (mt === \"file-chunk\") {\n                        this.handleFileChunk(event.id, event.pubkey, pTag[1], event.created_at * 1000, p);\n                        return;\n                    }\n                    if (mt === \"file-meta\") {\n                        const transferId = p.transferId || \"\";\n                        if (!transferId) return;\n                        const fileType = [\n                            \"image\",\n                            \"audio\"\n                        ].includes(p.fileType) ? p.fileType : \"file\";\n                        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.ensureTransfer)({\n                            transferId,\n                            fileName: p.fileName || \"file\",\n                            mimeType: p.mimeType || \"application/octet-stream\",\n                            fileType,\n                            size: p.size || 0,\n                            totalChunks: p.totalChunks || 0,\n                            text: p.text || \"\"\n                        });\n                        return;\n                    }\n                    if (mt === \"image\" || mt === \"file\" || mt === \"audio\") {\n                        this.messageCallbacks.forEach((cb)=>cb({\n                                id: event.id,\n                                from: event.pubkey,\n                                to: pTag[1],\n                                content: p.text || \"\",\n                                timestamp: event.created_at * 1000,\n                                msgType: mt,\n                                replyTo: p.replyTo,\n                                attachment: {\n                                    type: mt,\n                                    name: p.fileName || \"file\",\n                                    mimeType: p.mimeType || \"application/octet-stream\",\n                                    data: p.data || \"\",\n                                    size: p.size || 0\n                                }\n                            }));\n                        return;\n                    }\n                }\n            } catch (e) {}\n            this.messageCallbacks.forEach((cb)=>cb({\n                    id: event.id,\n                    from: event.pubkey,\n                    to: pTag[1],\n                    content: dec,\n                    timestamp: event.created_at * 1000,\n                    msgType: \"text\"\n                }));\n        } catch (e) {}\n    }\n    async handleFileChunk(eventId, from, to, timestamp, p) {\n        const transferId = p.transferId;\n        const chunkIndex = p.chunkIndex;\n        const totalChunks = p.totalChunks;\n        const data = p.data;\n        if (!transferId || typeof chunkIndex !== \"number\" || typeof totalChunks !== \"number\" || typeof data !== \"string\") return;\n        const fileType = [\n            \"image\",\n            \"audio\"\n        ].includes(p.fileType) ? p.fileType : \"file\";\n        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.ensureTransfer)({\n            transferId,\n            fileName: p.fileName || \"file\",\n            mimeType: p.mimeType || \"application/octet-stream\",\n            fileType,\n            size: p.size || 0,\n            totalChunks,\n            text: p.text || \"\"\n        });\n        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.storeChunk)(transferId, chunkIndex, totalChunks, data);\n        const done = await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.isTransferComplete)(transferId);\n        if (!done) return;\n        this.messageCallbacks.forEach((cb)=>cb({\n                id: \"\".concat(eventId, \"-assembled-\").concat(transferId),\n                from,\n                to,\n                content: p.text || \"\",\n                timestamp,\n                msgType: fileType,\n                replyTo: p.replyTo,\n                attachment: {\n                    type: fileType,\n                    name: p.fileName || \"file\",\n                    mimeType: p.mimeType || \"application/octet-stream\",\n                    data: \"\",\n                    size: p.size || 0,\n                    transferId,\n                    totalChunks,\n                    chunked: true\n                }\n            }));\n    }\n    handleProfileEvent(event) {\n        try {\n            const p = JSON.parse(event.content);\n            this.profileCache.set(event.pubkey, p);\n            this.pendingProfiles.delete(event.pubkey);\n            this.profileCallbacks.forEach((cb)=>cb(event.pubkey, p));\n        } catch (e) {}\n    }\n    handleChannelEvent(event) {\n        try {\n            var _payload_name;\n            const payload = JSON.parse(event.content);\n            const channel = {\n                id: event.id,\n                name: ((_payload_name = payload.name) === null || _payload_name === void 0 ? void 0 : _payload_name.trim()) || \"channel-\".concat(event.id.slice(0, 8)),\n                about: payload.about,\n                createdBy: event.pubkey,\n                createdAt: event.created_at * 1000\n            };\n            this.channelCallbacks.forEach((cb)=>cb(channel));\n        } catch (e) {}\n    }\n    handleChannelMessageEvent(event) {\n        var _event_tags_find;\n        const eTag = (_event_tags_find = event.tags.find((t)=>t[0] === \"e\")) === null || _event_tags_find === void 0 ? void 0 : _event_tags_find[1];\n        if (!eTag) return;\n        try {\n            const payload = JSON.parse(event.content);\n            this.channelMessageCallbacks.forEach((cb)=>cb({\n                    id: event.id,\n                    from: event.pubkey,\n                    to: \"\",\n                    content: payload.text || \"\",\n                    timestamp: event.created_at * 1000,\n                    msgType: \"channel\",\n                    channelId: eTag,\n                    replyTo: payload.replyTo\n                }));\n        } catch (e) {\n            this.channelMessageCallbacks.forEach((cb)=>cb({\n                    id: event.id,\n                    from: event.pubkey,\n                    to: \"\",\n                    content: event.content || \"\",\n                    timestamp: event.created_at * 1000,\n                    msgType: \"channel\",\n                    channelId: eTag\n                }));\n        }\n    }\n    subscribeToMessages(relayUrl) {\n        if (!this._pk) return;\n        const ws = this.sockets.get(relayUrl);\n        if (!ws || ws.readyState !== WebSocket.OPEN) return;\n        const subId = \"dm-\" + Math.random().toString(36).slice(2, 8);\n        const since = Math.floor(Date.now() / 1000) - 86400 * 30;\n        ws.send(JSON.stringify([\n            \"REQ\",\n            subId,\n            {\n                kinds: [\n                    4\n                ],\n                \"#p\": [\n                    this._pk\n                ],\n                since\n            },\n            {\n                kinds: [\n                    4\n                ],\n                authors: [\n                    this._pk\n                ],\n                since\n            }\n        ]));\n        this.subscriptions.set(subId, {\n            filters: [],\n            relay: relayUrl\n        });\n        this.subscribeToChannels(relayUrl);\n    }\n    subscribeToChannels(relayUrl) {\n        const ws = this.sockets.get(relayUrl);\n        if (!ws || ws.readyState !== WebSocket.OPEN) return;\n        if (this._channels.length === 0) return; // Do not subscribe to global channels\n        const subId = \"ch-\" + Math.random().toString(36).slice(2, 8);\n        const since = Math.floor(Date.now() / 1000) - 86400 * 30;\n        // Only subscribe to channels the user has joined\n        ws.send(JSON.stringify([\n            \"REQ\",\n            subId,\n            {\n                kinds: [\n                    40\n                ],\n                ids: this._channels,\n                since\n            },\n            {\n                kinds: [\n                    42\n                ],\n                \"#e\": this._channels,\n                since\n            }\n        ]));\n        this.subscriptions.set(subId, {\n            filters: [],\n            relay: relayUrl\n        });\n    }\n    async sendEncryptedPayload(recipientPubkey, payload) {\n        if (!this._sk) throw new Error(\"Не авторизован\");\n        const encrypted = await (0,nostr_tools_nip04__WEBPACK_IMPORTED_MODULE_3__.encrypt)(this._sk, recipientPubkey, payload);\n        const ev = {\n            kind: 4,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [\n                [\n                    \"p\",\n                    recipientPubkey\n                ]\n            ],\n            content: encrypted,\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        this.seenEvents.add(event.id);\n        const json = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        const open = [];\n        for (const [, ws] of this.sockets)if (ws.readyState === WebSocket.OPEN) open.push(ws);\n        if (!open.length) throw new Error(\"Нет подключённых релеев\");\n        open.forEach((ws)=>{\n            try {\n                ws.send(json);\n            } catch (e) {}\n        });\n        return event.id;\n    }\n    bytesToBase64(bytes) {\n        let bin = \"\";\n        const step = 0x8000;\n        for(let i = 0; i < bytes.length; i += step){\n            bin += String.fromCharCode(...bytes.subarray(i, i + step));\n        }\n        return btoa(bin);\n    }\n    async sendDirectMessage(recipientPubkey, content, replyTo) {\n        const payload = replyTo ? JSON.stringify({\n            _nostr_msg_type: \"text\",\n            text: content,\n            replyTo\n        }) : content;\n        const id = await this.sendEncryptedPayload(recipientPubkey, payload);\n        return {\n            id,\n            from: this._pk,\n            to: recipientPubkey,\n            content,\n            timestamp: Date.now(),\n            msgType: \"text\",\n            replyTo\n        };\n    }\n    async sendAttachment(recipientPubkey, attachment, text, onProgress, replyTo) {\n        const maxSize = 2 * 1024 * 1024 * 1024;\n        if (attachment.size > maxSize) throw new Error(\"File is too large. Max size is 2GB.\");\n        if (!attachment.file) {\n            const b64 = attachment.data;\n            if (b64.length < 40000) {\n                const id = await this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n                    _nostr_msg_type: attachment.type,\n                    fileName: attachment.name,\n                    mimeType: attachment.mimeType,\n                    data: b64,\n                    size: attachment.size,\n                    text: text || \"\",\n                    replyTo\n                }));\n                return {\n                    id,\n                    from: this._pk,\n                    to: recipientPubkey,\n                    content: text || \"\",\n                    timestamp: Date.now(),\n                    msgType: attachment.type,\n                    attachment,\n                    replyTo\n                };\n            }\n        }\n        const file = attachment.file;\n        const transferId = Math.random().toString(36).slice(2) + Date.now().toString(36);\n        const fileSize = file ? file.size : attachment.size;\n        const totalChunks = Math.ceil(fileSize / NostrClient.CHUNK_SIZE);\n        let lastId = \"\";\n        let sent = 0;\n        await this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n            _nostr_msg_type: \"file-meta\",\n            transferId,\n            totalChunks,\n            fileName: attachment.name,\n            mimeType: attachment.mimeType,\n            size: fileSize,\n            text: text || \"\",\n            fileType: attachment.type,\n            replyTo\n        }));\n        for(let batch = 0; batch < totalChunks; batch += NostrClient.PARALLEL){\n            const promises = [];\n            for(let j = 0; j < NostrClient.PARALLEL && batch + j < totalChunks; j++){\n                const i = batch + j;\n                if (file) {\n                    const start = i * NostrClient.CHUNK_SIZE;\n                    const end = Math.min(start + NostrClient.CHUNK_SIZE, fileSize);\n                    const bytes = new Uint8Array(await file.slice(start, end).arrayBuffer());\n                    const data = this.bytesToBase64(bytes);\n                    promises.push(this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n                        _nostr_msg_type: \"file-chunk\",\n                        transferId,\n                        chunkIndex: i,\n                        totalChunks,\n                        data,\n                        fileName: attachment.name,\n                        mimeType: attachment.mimeType,\n                        size: fileSize,\n                        text: text || \"\",\n                        fileType: attachment.type,\n                        replyTo\n                    })));\n                } else {\n                    const base64ChunkSize = Math.floor(NostrClient.CHUNK_SIZE / 3 * 4);\n                    const chunk = attachment.data.slice(i * base64ChunkSize, (i + 1) * base64ChunkSize);\n                    promises.push(this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n                        _nostr_msg_type: \"file-chunk\",\n                        transferId,\n                        chunkIndex: i,\n                        totalChunks,\n                        data: chunk,\n                        fileName: attachment.name,\n                        mimeType: attachment.mimeType,\n                        size: fileSize,\n                        text: text || \"\",\n                        fileType: attachment.type,\n                        replyTo\n                    })));\n                }\n            }\n            const ids = await Promise.all(promises);\n            lastId = ids[ids.length - 1] || lastId;\n            sent += promises.length;\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(sent, totalChunks);\n            if (sent < totalChunks) await new Promise((r)=>setTimeout(r, 50));\n        }\n        return {\n            id: lastId || \"local-\".concat(transferId),\n            from: this._pk,\n            to: recipientPubkey,\n            content: text || \"\",\n            timestamp: Date.now(),\n            msgType: attachment.type,\n            replyTo,\n            attachment: {\n                ...attachment,\n                data: attachment.file ? \"\" : attachment.data,\n                transferId,\n                totalChunks,\n                chunked: true\n            }\n        };\n    }\n    async sendWebRTCSignal(recipientPubkey, signal) {\n        await this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n            _nostr_msg_type: signal.type,\n            sdp: signal.sdp,\n            candidate: signal.candidate,\n            callType: signal.callType\n        }));\n    }\n    async createChannel(name, about) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const ev = {\n            kind: 40,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [],\n            content: JSON.stringify({\n                name,\n                about: about || \"\"\n            }),\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        const payload = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        for (const [, ws] of this.sockets)if (ws.readyState === WebSocket.OPEN) try {\n            ws.send(payload);\n        } catch (e) {}\n        const channel = {\n            id: event.id,\n            name,\n            about,\n            createdBy: this._pk,\n            createdAt: Date.now()\n        };\n        this.channelCallbacks.forEach((cb)=>cb(channel));\n        return channel;\n    }\n    async sendChannelMessage(channelId, text, replyTo) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const ev = {\n            kind: 42,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [\n                [\n                    \"e\",\n                    channelId,\n                    \"\",\n                    \"root\"\n                ]\n            ],\n            content: JSON.stringify({\n                text,\n                replyTo\n            }),\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        const payload = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        let sent = false;\n        for (const [, ws] of this.sockets){\n            if (ws.readyState !== WebSocket.OPEN) continue;\n            sent = true;\n            try {\n                ws.send(payload);\n            } catch (e) {}\n        }\n        if (!sent) throw new Error(\"No connected relays\");\n        return {\n            id: event.id,\n            from: this._pk,\n            to: \"\",\n            content: text,\n            timestamp: Date.now(),\n            msgType: \"channel\",\n            channelId,\n            replyTo\n        };\n    }\n    requestProfile(pubkey) {\n        if (this.profileCache.has(pubkey)) return this.profileCache.get(pubkey);\n        if (this.pendingProfiles.has(pubkey)) return null;\n        this.pendingProfiles.add(pubkey);\n        const subId = \"p-\" + Math.random().toString(36).slice(2, 8);\n        for (const [, ws] of this.sockets){\n            if (ws.readyState === WebSocket.OPEN) {\n                ws.send(JSON.stringify([\n                    \"REQ\",\n                    subId,\n                    {\n                        kinds: [\n                            0\n                        ],\n                        authors: [\n                            pubkey\n                        ],\n                        limit: 1\n                    }\n                ]));\n                break;\n            }\n        }\n        return null;\n    }\n    getProfile(pubkey) {\n        return this.profileCache.get(pubkey) || null;\n    }\n    async updateProfile(profile) {\n        if (!this._sk) throw new Error(\"Не авторизован\");\n        const ev = {\n            kind: 0,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [],\n            content: JSON.stringify(profile),\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        const json = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        for (const [, ws] of this.sockets)if (ws.readyState === WebSocket.OPEN) try {\n            ws.send(json);\n        } catch (e) {}\n        this.profileCache.set(this._pk, profile);\n    }\n    disconnectAll() {\n        for (const [, t] of this.reconnectTimers)clearTimeout(t);\n        this.reconnectTimers.clear();\n        this.reconnectAttempts.clear();\n        for (const [, ws] of this.sockets)ws.close();\n        this.sockets.clear();\n        this.subscriptions.clear();\n        this.relayStatus.clear();\n    }\n    addRelay(url) {\n        if (!this._relays.includes(url)) {\n            this._relays.push(url);\n            this.connectToRelay(url);\n        }\n    }\n    removeRelay(url) {\n        this._relays = this._relays.filter((r)=>r !== url);\n        const t = this.reconnectTimers.get(url);\n        if (t) {\n            clearTimeout(t);\n            this.reconnectTimers.delete(url);\n        }\n        this.reconnectAttempts.delete(url);\n        const ws = this.sockets.get(url);\n        if (ws) {\n            ws.close();\n            this.sockets.delete(url);\n        }\n        this.relayStatus.delete(url);\n    }\n    shortenKey(key) {\n        return !key || key.length < 16 ? key : key.slice(0, 8) + \"…\" + key.slice(-8);\n    }\n    isValidHexKey(key) {\n        return /^[0-9a-fA-F]{64}$/.test(key);\n    }\n    constructor(){\n        this._sk = null;\n        this._pk = \"\";\n        this.sockets = new Map();\n        this.relayStatus = new Map();\n        this.subscriptions = new Map();\n        this.messageCallbacks = new Set();\n        this.channelCallbacks = new Set();\n        this.channelMessageCallbacks = new Set();\n        this.profileCallbacks = new Set();\n        this.connectionCallbacks = new Set();\n        this.signalCallbacks = new Set();\n        this.profileCache = new Map();\n        this.pendingProfiles = new Set();\n        this.seenEvents = new Set();\n        this._relays = [\n            ...DEFAULT_RELAYS\n        ];\n        this.reconnectAttempts = new Map();\n        this.reconnectTimers = new Map();\n        this._stopped = false;\n        this._channels = [];\n    }\n}\n// 256KB chunks, parallel send by 3\nNostrClient.CHUNK_SIZE = 262144;\nNostrClient.PARALLEL = 3;\nconst nostrClient = new NostrClient();\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbm9zdHIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNHO0FBQ2pEO0FBQ1E7QUFFaUI7QUFzRjlFLE1BQU1VLGlCQUFpQjtJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBZ0JELE1BQU1DO0lBcUJKLElBQUlDLFlBQW9CO1FBQUUsT0FBTyxJQUFJLENBQUNDLEdBQUc7SUFBRTtJQUMzQyxJQUFJQyxnQkFBd0I7UUFBRSxPQUFPLElBQUksQ0FBQ0MsR0FBRyxHQUFHViwrREFBVUEsQ0FBQyxJQUFJLENBQUNVLEdBQUcsSUFBSTtJQUFJO0lBQzNFLElBQUlDLFNBQW1CO1FBQUUsT0FBTztlQUFJLElBQUksQ0FBQ0MsT0FBTztTQUFDO0lBQUU7SUFDbkQsSUFBSUMsV0FBcUI7UUFBRSxPQUFPO2VBQUksSUFBSSxDQUFDQyxTQUFTO1NBQUM7SUFBRTtJQUN2RCxJQUFJQyxLQUF3QjtRQUFFLE9BQU8sSUFBSSxDQUFDTCxHQUFHO0lBQUU7SUFFL0NNLGVBQWVDLEtBQWEsRUFBVTtRQUNwQyxPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxHQUFHLENBQUNGLFVBQVU7SUFDeEM7SUFFQSxJQUFJRyxzQkFBOEI7UUFDaEMsSUFBSUMsSUFBSTtRQUNSLElBQUksQ0FBQ0gsV0FBVyxDQUFDSSxPQUFPLENBQUMsQ0FBQ0M7WUFDeEIsSUFBSUEsTUFBTSxhQUFhO2dCQUNyQkY7WUFDRjtRQUNGO1FBQ0EsT0FBT0E7SUFDVDtJQUVBRyxlQUFlO1FBQ2IsTUFBTVQsS0FBS3BCLG1FQUFpQkE7UUFDNUIsTUFBTThCLEtBQUs3Qiw4REFBWUEsQ0FBQ21CO1FBQ3hCLE9BQU87WUFBRVcsWUFBWTFCLCtEQUFVQSxDQUFDZTtZQUFLUixXQUFXa0I7UUFBRztJQUNyRDtJQUVBRSxNQUFNbEIsYUFBcUIsRUFBVTtRQUNuQyxNQUFNTSxLQUFLZCwrREFBVUEsQ0FBQ1E7UUFDdEIsTUFBTWdCLEtBQUs3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QjtJQUVBd0osV0FBV0MsR0FBVyxFQUFFO1FBQUUsT0FBTyxDQUFFQSxPQUFPQSxJQUFJdkwsTUFBTSxHQUFHLEtBQU11TCxNQUFNQSxJQUFJekUsS0FBSyxDQUFDLEdBQUcsS0FBSyxNQUFNeUUsSUFBSXpFLEtBQUssQ0FBQyxDQUFDO0lBQUk7SUFDMUcwRSxjQUFjRCxHQUFXLEVBQUU7UUFBRSxPQUFPLG9CQUFvQkUsSUFBSSxDQUFDRjtJQUFNOzthQXhnQjNEak4sTUFBeUI7YUFDekJGLE1BQWM7YUFDZHFELFVBQWtDLElBQUlpSzthQUN0QzVNLGNBQWtGLElBQUk0TTthQUN0RjFELGdCQUFtRSxJQUFJMEQ7YUFDdkV2TCxtQkFBeUMsSUFBSWtCO2FBQzdDZCxtQkFBeUMsSUFBSWM7YUFDN0NaLDBCQUF1RCxJQUFJWTthQUMzRFYsbUJBQXlDLElBQUlVO2FBQzdDUixzQkFBK0MsSUFBSVE7YUFDbkROLGtCQUF1QyxJQUFJTTthQUMzQ29GLGVBQTBDLElBQUlpRjthQUM5Q2hGLGtCQUErQixJQUFJckY7YUFDbkNzQyxhQUEwQixJQUFJdEM7YUFDOUI3QyxVQUFvQjtlQUFJUDtTQUFlO2FBQ3ZDdUUsb0JBQXlDLElBQUlrSjthQUM3Q3hJLGtCQUE4RCxJQUFJd0k7YUFDbEVsTSxXQUFXO2FBQ1hkLFlBQXNCLEVBQUU7O0FBdWZsQztBQTNNRSxtQ0FBbUM7QUEvVC9CUixZQWdVV3lMLGFBQWE7QUFoVXhCekwsWUFpVVc2TCxXQUFXO0FBMk1yQixNQUFNNEIsY0FBYyxJQUFJek4sY0FBYztBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL25vc3RyLnRzP2Y4ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2VuZXJhdGVTZWNyZXRLZXksIGdldFB1YmxpY0tleSwgZmluYWxpemVFdmVudCwgdHlwZSBVbnNpZ25lZEV2ZW50IH0gZnJvbSAnbm9zdHItdG9vbHMvcHVyZSc7XG5pbXBvcnQgeyBlbmNyeXB0LCBkZWNyeXB0IH0gZnJvbSAnbm9zdHItdG9vbHMvbmlwMDQnO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCwgaGV4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXIgfSBmcm9tICdub3N0ci10b29scyc7XG5pbXBvcnQgeyBlbnN1cmVUcmFuc2ZlciwgaXNUcmFuc2ZlckNvbXBsZXRlLCBzdG9yZUNodW5rIH0gZnJvbSAnLi9jaHVua1N0b3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBOb3N0clByb2ZpbGUge1xuICBuYW1lPzogc3RyaW5nO1xuICBhYm91dD86IHN0cmluZztcbiAgcGljdHVyZT86IHN0cmluZztcbiAgbmlwMDU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9zdHJFdmVudCB7XG4gIGlkOiBzdHJpbmc7XG4gIHB1YmtleTogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG4gIGtpbmQ6IG51bWJlcjtcbiAgdGFnczogc3RyaW5nW11bXTtcbiAgY29udGVudDogc3RyaW5nO1xuICBzaWc6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgTWVzc2FnZVR5cGUgPVxuICB8ICd0ZXh0J1xuICB8ICdpbWFnZSdcbiAgfCAnZmlsZSdcbiAgfCAnYXVkaW8nXG4gIHwgJ2ZpbGUtbWV0YSdcbiAgfCAnZmlsZS1jaHVuaydcbiAgfCAnY2hhbm5lbCdcbiAgfCAnd2VicnRjLW9mZmVyJ1xuICB8ICd3ZWJydGMtYW5zd2VyJ1xuICB8ICd3ZWJydGMtaWNlJ1xuICB8ICdjYWxsLXJlcXVlc3QnXG4gIHwgJ2NhbGwtYWNjZXB0J1xuICB8ICdjYWxsLXJlamVjdCdcbiAgfCAnY2FsbC1lbmQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlcGx5UmVmIHtcbiAgaWQ6IHN0cmluZztcbiAgZnJvbTogc3RyaW5nO1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gIHR5cGU6ICdpbWFnZScgfCAnZmlsZScgfCAnYXVkaW8nO1xuICBuYW1lOiBzdHJpbmc7XG4gIG1pbWVUeXBlOiBzdHJpbmc7XG4gIGRhdGE6IHN0cmluZztcbiAgc2l6ZTogbnVtYmVyO1xuICBmaWxlPzogRmlsZTtcbiAgdHJhbnNmZXJJZD86IHN0cmluZztcbiAgdG90YWxDaHVua3M/OiBudW1iZXI7XG4gIGNodW5rZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERpcmVjdE1lc3NhZ2Uge1xuICBpZDogc3RyaW5nO1xuICBmcm9tOiBzdHJpbmc7XG4gIHRvOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIHBlbmRpbmc/OiBib29sZWFuO1xuICBmYWlsZWQ/OiBib29sZWFuO1xuICBtc2dUeXBlPzogTWVzc2FnZVR5cGU7XG4gIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50O1xuICByZXBseVRvPzogUmVwbHlSZWY7XG4gIGNoYW5uZWxJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFubmVsIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBhYm91dD86IHN0cmluZztcbiAgY3JlYXRlZEJ5OiBzdHJpbmc7XG4gIGNyZWF0ZWRBdDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRhY3Qge1xuICBwdWJrZXk6IHN0cmluZztcbiAgbmFtZT86IHN0cmluZztcbiAgYWJvdXQ/OiBzdHJpbmc7XG4gIHBpY3R1cmU/OiBzdHJpbmc7XG4gIGxhc3RNZXNzYWdlPzogc3RyaW5nO1xuICBsYXN0TWVzc2FnZVRpbWU/OiBudW1iZXI7XG4gIHVucmVhZD86IG51bWJlcjtcbiAgb25saW5lPzogYm9vbGVhbjtcbn1cblxuY29uc3QgREVGQVVMVF9SRUxBWVMgPSBbXG4gICd3c3M6Ly9yZWxheS5kYW11cy5pbycsXG4gICd3c3M6Ly9ub3MubG9sJyxcbiAgJ3dzczovL3JlbGF5LnNub3J0LnNvY2lhbCcsXG4gICd3c3M6Ly9yZWxheS5wcmltYWwubmV0JyxcbiAgJ3dzczovL3B1cnBsZXBhZy5lcycsXG4gICd3c3M6Ly9ub3N0ci5tb20nLFxuICAnd3NzOi8vcmVsYXkubm9zdHIuYmcnLFxuXTtcblxudHlwZSBNZXNzYWdlQ2FsbGJhY2sgPSAobXNnOiBEaXJlY3RNZXNzYWdlKSA9PiB2b2lkO1xudHlwZSBDaGFubmVsQ2FsbGJhY2sgPSAoY2hhbm5lbDogQ2hhbm5lbCkgPT4gdm9pZDtcbnR5cGUgQ2hhbm5lbE1lc3NhZ2VDYWxsYmFjayA9IChtc2c6IERpcmVjdE1lc3NhZ2UpID0+IHZvaWQ7XG50eXBlIFByb2ZpbGVDYWxsYmFjayA9IChwdWJrZXk6IHN0cmluZywgcHJvZmlsZTogTm9zdHJQcm9maWxlKSA9PiB2b2lkO1xudHlwZSBDb25uZWN0aW9uQ2FsbGJhY2sgPSAocmVsYXk6IHN0cmluZywgc3RhdHVzOiAnY29ubmVjdGVkJyB8ICdkaXNjb25uZWN0ZWQnIHwgJ2Vycm9yJykgPT4gdm9pZDtcbnR5cGUgU2lnbmFsQ2FsbGJhY2sgPSAoZnJvbTogc3RyaW5nLCBzaWduYWw6IFdlYlJUQ1NpZ25hbCkgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBXZWJSVENTaWduYWwge1xuICB0eXBlOiBNZXNzYWdlVHlwZTtcbiAgc2RwPzogc3RyaW5nO1xuICBjYW5kaWRhdGU/OiBSVENJY2VDYW5kaWRhdGVJbml0O1xuICBjYWxsVHlwZT86ICdhdWRpbycgfCAndmlkZW8nO1xufVxuXG5jbGFzcyBOb3N0ckNsaWVudCB7XG4gIHByaXZhdGUgX3NrOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX3BrOiBzdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBzb2NrZXRzOiBNYXA8c3RyaW5nLCBXZWJTb2NrZXQ+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlbGF5U3RhdHVzOiBNYXA8c3RyaW5nLCAnY29ubmVjdGVkJyB8ICdkaXNjb25uZWN0ZWQnIHwgJ2Nvbm5lY3RpbmcnIHwgJ2Vycm9yJz4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogTWFwPHN0cmluZywgeyBmaWx0ZXJzOiBGaWx0ZXJbXTsgcmVsYXk6IHN0cmluZyB9PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBtZXNzYWdlQ2FsbGJhY2tzOiBTZXQ8TWVzc2FnZUNhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBjaGFubmVsQ2FsbGJhY2tzOiBTZXQ8Q2hhbm5lbENhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBjaGFubmVsTWVzc2FnZUNhbGxiYWNrczogU2V0PENoYW5uZWxNZXNzYWdlQ2FsbGJhY2s+ID0gbmV3IFNldCgpO1xuICBwcml2YXRlIHByb2ZpbGVDYWxsYmFja3M6IFNldDxQcm9maWxlQ2FsbGJhY2s+ID0gbmV3IFNldCgpO1xuICBwcml2YXRlIGNvbm5lY3Rpb25DYWxsYmFja3M6IFNldDxDb25uZWN0aW9uQ2FsbGJhY2s+ID0gbmV3IFNldCgpO1xuICBwcml2YXRlIHNpZ25hbENhbGxiYWNrczogU2V0PFNpZ25hbENhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBwcm9maWxlQ2FjaGU6IE1hcDxzdHJpbmcsIE5vc3RyUHJvZmlsZT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcGVuZGluZ1Byb2ZpbGVzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBzZWVuRXZlbnRzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBfcmVsYXlzOiBzdHJpbmdbXSA9IFsuLi5ERUZBVUxUX1JFTEFZU107XG4gIHByaXZhdGUgcmVjb25uZWN0QXR0ZW1wdHM6IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcmVjb25uZWN0VGltZXJzOiBNYXA8c3RyaW5nLCBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0Pj4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgX3N0b3BwZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfY2hhbm5lbHM6IHN0cmluZ1tdID0gW107XG5cbiAgZ2V0IHB1YmxpY0tleSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fcGs7IH1cbiAgZ2V0IHByaXZhdGVLZXlIZXgoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX3NrID8gYnl0ZXNUb0hleCh0aGlzLl9zaykgOiAnJzsgfVxuICBnZXQgcmVsYXlzKCk6IHN0cmluZ1tdIHsgcmV0dXJuIFsuLi50aGlzLl9yZWxheXNdOyB9XG4gIGdldCBjaGFubmVscygpOiBzdHJpbmdbXSB7IHJldHVybiBbLi4udGhpcy5fY2hhbm5lbHNdOyB9XG4gIGdldCBzaygpOiBVaW50OEFycmF5IHwgbnVsbCB7IHJldHVybiB0aGlzLl9zazsgfVxuXG4gIGdldFJlbGF5U3RhdHVzKHJlbGF5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnJlbGF5U3RhdHVzLmdldChyZWxheSkgfHwgJ2Rpc2Nvbm5lY3RlZCc7XG4gIH1cblxuICBnZXQgY29ubmVjdGVkUmVsYXlDb3VudCgpOiBudW1iZXIge1xuICAgIGxldCBjID0gMDtcbiAgICB0aGlzLnJlbGF5U3RhdHVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGlmIChzID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICBjKys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBnZW5lcmF0ZUtleXMoKSB7XG4gICAgY29uc3Qgc2sgPSBnZW5lcmF0ZVNlY3JldEtleSgpO1xuICAgIGNvbnN0IHBrID0gZ2V0UHVibGljS2V5KHNrKTtcbiAgICByZXR1cm4geyBwcml2YXRlS2V5OiBieXRlc1RvSGV4KHNrKSwgcHVibGljS2V5OiBwayB9O1xuICB9XG5cbiAgbG9naW4ocHJpdmF0ZUtleUhleDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBzayA9IGhleFRvQnl0ZXMocHJpdmF0ZUtleUhleCk7XG4gICAgY29uc3QgcGsgPSBnZXRQdWJsaWNLZXkoc2spO1xuICAgIHRoaXMuX3NrID0gc2s7IHRoaXMuX3BrID0gcGs7IHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbm9zdHJfc2snLCBwcml2YXRlS2V5SGV4KTtcbiAgICByZXR1cm4gcGs7XG4gIH1cblxuICBsb2dvdXQoKSB7XG4gICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7IHRoaXMuZGlzY29ubmVjdEFsbCgpO1xuICAgIHRoaXMuX3NrID0gbnVsbDsgdGhpcy5fcGsgPSAnJztcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnbm9zdHJfc2snKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnbm9zdHJfY29udGFjdHMnKTtcbiAgfVxuXG4gIHRyeUF1dG9Mb2dpbigpOiBib29sZWFuIHtcbiAgICBjb25zdCBzayA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdub3N0cl9zaycpO1xuICAgIGlmIChzaz8ubGVuZ3RoID09PSA2NCkgeyB0cnkgeyB0aGlzLmxvZ2luKHNrKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggeyBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnbm9zdHJfc2snKTsgfSB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgb25NZXNzYWdlKGNiOiBNZXNzYWdlQ2FsbGJhY2spIHsgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmFkZChjYik7IHJldHVybiAoKSA9PiB7IHRoaXMubWVzc2FnZUNhbGxiYWNrcy5kZWxldGUoY2IpOyB9OyB9XG4gIG9uQ2hhbm5lbChjYjogQ2hhbm5lbENhbGxiYWNrKSB7IHRoaXMuY2hhbm5lbENhbGxiYWNrcy5hZGQoY2IpOyByZXR1cm4gKCkgPT4geyB0aGlzLmNoYW5uZWxDYWxsYmFja3MuZGVsZXRlKGNiKTsgfTsgfVxuICBvbkNoYW5uZWxNZXNzYWdlKGNiOiBDaGFubmVsTWVzc2FnZUNhbGxiYWNrKSB7IHRoaXMuY2hhbm5lbE1lc3NhZ2VDYWxsYmFja3MuYWRkKGNiKTsgcmV0dXJuICgpID0+IHsgdGhpcy5jaGFubmVsTWVzc2FnZUNhbGxiYWNrcy5kZWxldGUoY2IpOyB9OyB9XG4gIG9uUHJvZmlsZShjYjogUHJvZmlsZUNhbGxiYWNrKSB7IHRoaXMucHJvZmlsZUNhbGxiYWNrcy5hZGQoY2IpOyByZXR1cm4gKCkgPT4geyB0aGlzLnByb2ZpbGVDYWxsYmFja3MuZGVsZXRlKGNiKTsgfTsgfVxuICBvbkNvbm5lY3Rpb24oY2I6IENvbm5lY3Rpb25DYWxsYmFjaykgeyB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3MuYWRkKGNiKTsgcmV0dXJuICgpID0+IHsgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzLmRlbGV0ZShjYik7IH07IH1cbiAgb25TaWduYWwoY2I6IFNpZ25hbENhbGxiYWNrKSB7IHRoaXMuc2lnbmFsQ2FsbGJhY2tzLmFkZChjYik7IHJldHVybiAoKSA9PiB7IHRoaXMuc2lnbmFsQ2FsbGJhY2tzLmRlbGV0ZShjYik7IH07IH1cblxuICBhc3luYyBjb25uZWN0VG9SZWxheXMoKSB7IGZvciAoY29uc3QgciBvZiB0aGlzLl9yZWxheXMpIHRoaXMuY29ubmVjdFRvUmVsYXkocik7IH1cblxuICBzZXRDaGFubmVscyhjaGFubmVsSWRzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuX2NoYW5uZWxzID0gWy4uLm5ldyBTZXQoY2hhbm5lbElkcy5maWx0ZXIoQm9vbGVhbikpXTtcbiAgICBmb3IgKGNvbnN0IFtyZWxheSwgd3NdIG9mIHRoaXMuc29ja2V0cykge1xuICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB0aGlzLnN1YnNjcmliZVRvQ2hhbm5lbHMocmVsYXkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29ubmVjdFRvUmVsYXkodXJsOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5fc3RvcHBlZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnNvY2tldHMuaGFzKHVybCkpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLnNvY2tldHMuZ2V0KHVybCkhO1xuICAgICAgaWYgKGUucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4gfHwgZS5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlbGF5U3RhdHVzLnNldCh1cmwsICdjb25uZWN0aW5nJyk7XG4gICAgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IodXJsLCAnZGlzY29ubmVjdGVkJykpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICAgIGNvbnN0IGN0ID0gc2V0VGltZW91dCgoKSA9PiB7IGlmICh3cy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikgd3MuY2xvc2UoKTsgfSwgODAwMCk7XG4gICAgICB0aGlzLnNvY2tldHMuc2V0KHVybCwgd3MpO1xuICAgICAgd3Mub25vcGVuID0gKCkgPT4geyBjbGVhclRpbWVvdXQoY3QpOyB0aGlzLnJlY29ubmVjdEF0dGVtcHRzLnNldCh1cmwsIDApOyB0aGlzLnJlbGF5U3RhdHVzLnNldCh1cmwsICdjb25uZWN0ZWQnKTsgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IodXJsLCAnY29ubmVjdGVkJykpOyB0aGlzLnN1YnNjcmliZVRvTWVzc2FnZXModXJsKTsgfTtcbiAgICAgIHdzLm9uY2xvc2UgPSAoKSA9PiB7IGNsZWFyVGltZW91dChjdCk7IHRoaXMucmVsYXlTdGF0dXMuc2V0KHVybCwgJ2Rpc2Nvbm5lY3RlZCcpOyB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYih1cmwsICdkaXNjb25uZWN0ZWQnKSk7IHRoaXMuc29ja2V0cy5kZWxldGUodXJsKTsgdGhpcy5zY2hlZHVsZVJlY29ubmVjdCh1cmwpOyB9O1xuICAgICAgd3Mub25lcnJvciA9ICgpID0+IHsgdGhpcy5yZWxheVN0YXR1cy5zZXQodXJsLCAnZXJyb3InKTsgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IodXJsLCAnZXJyb3InKSk7IH07XG4gICAgICB3cy5vbm1lc3NhZ2UgPSAoZSkgPT4geyB0cnkgeyB0aGlzLmhhbmRsZVJlbGF5TWVzc2FnZShKU09OLnBhcnNlKGUuZGF0YSkpOyB9IGNhdGNoIHt9IH07XG4gICAgfSBjYXRjaCB7IHRoaXMucmVsYXlTdGF0dXMuc2V0KHVybCwgJ2Vycm9yJyk7IHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QodXJsKTsgfVxuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZVJlY29ubmVjdCh1cmw6IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9zdG9wcGVkKSByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMucmVjb25uZWN0VGltZXJzLmdldCh1cmwpOyBpZiAoZSkgY2xlYXJUaW1lb3V0KGUpO1xuICAgIGNvbnN0IGEgPSB0aGlzLnJlY29ubmVjdEF0dGVtcHRzLmdldCh1cmwpIHx8IDA7XG4gICAgY29uc3QgZCA9IE1hdGgubWluKDMwMDAgKiBNYXRoLnBvdygyLCBhKSwgNjAwMDApO1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMuc2V0KHVybCwgYSArIDEpO1xuICAgIHRoaXMucmVjb25uZWN0VGltZXJzLnNldCh1cmwsIHNldFRpbWVvdXQoKCkgPT4geyBpZiAoIXRoaXMuX3N0b3BwZWQgJiYgdGhpcy5fc2spIHRoaXMuY29ubmVjdFRvUmVsYXkodXJsKTsgfSwgZCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSZWxheU1lc3NhZ2UoZGF0YTogdW5rbm93bltdKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSByZXR1cm47XG4gICAgaWYgKGRhdGFbMF0gPT09ICdFVkVOVCcpIHtcbiAgICAgIGNvbnN0IGV2ID0gZGF0YVsyXSBhcyBOb3N0ckV2ZW50O1xuICAgICAgaWYgKCFldiB8fCB0aGlzLnNlZW5FdmVudHMuaGFzKGV2LmlkKSkgcmV0dXJuO1xuICAgICAgdGhpcy5zZWVuRXZlbnRzLmFkZChldi5pZCk7XG4gICAgICBpZiAoZXYua2luZCA9PT0gNCkgdGhpcy5oYW5kbGVFbmNyeXB0ZWRETShldik7XG4gICAgICBlbHNlIGlmIChldi5raW5kID09PSAwKSB0aGlzLmhhbmRsZVByb2ZpbGVFdmVudChldik7XG4gICAgICBlbHNlIGlmIChldi5raW5kID09PSA0MCkgdGhpcy5oYW5kbGVDaGFubmVsRXZlbnQoZXYpO1xuICAgICAgZWxzZSBpZiAoZXYua2luZCA9PT0gNDIpIHRoaXMuaGFuZGxlQ2hhbm5lbE1lc3NhZ2VFdmVudChldik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVFbmNyeXB0ZWRETShldmVudDogTm9zdHJFdmVudCkge1xuICAgIGlmICghdGhpcy5fc2spIHJldHVybjtcbiAgICBjb25zdCBwVGFnID0gZXZlbnQudGFncy5maW5kKHQgPT4gdFswXSA9PT0gJ3AnKTsgaWYgKCFwVGFnKSByZXR1cm47XG4gICAgY29uc3QgaXNGb3JNZSA9IHBUYWdbMV0gPT09IHRoaXMuX3BrLCBpc0Zyb21NZSA9IGV2ZW50LnB1YmtleSA9PT0gdGhpcy5fcGs7XG4gICAgaWYgKCFpc0Zvck1lICYmICFpc0Zyb21NZSkgcmV0dXJuO1xuICAgIGNvbnN0IG90aGVyID0gaXNGcm9tTWUgPyBwVGFnWzFdIDogZXZlbnQucHVia2V5O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWMgPSBhd2FpdCBkZWNyeXB0KHRoaXMuX3NrLCBvdGhlciwgZXZlbnQuY29udGVudCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwID0gSlNPTi5wYXJzZShkZWMpO1xuICAgICAgICAgIGlmIChwPy5fbm9zdHJfbXNnX3R5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG10ID0gcC5fbm9zdHJfbXNnX3R5cGUgYXMgTWVzc2FnZVR5cGU7XG4gICAgICAgICAgICBpZiAobXQgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYih7XG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmlkLFxuICAgICAgICAgICAgICAgIGZyb206IGV2ZW50LnB1YmtleSxcbiAgICAgICAgICAgICAgICB0bzogcFRhZ1sxXSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAocC50ZXh0IGFzIHN0cmluZykgfHwgJycsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBldmVudC5jcmVhdGVkX2F0ICogMTAwMCxcbiAgICAgICAgICAgICAgICBtc2dUeXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmVwbHlUbzogcC5yZXBseVRvIGFzIFJlcGx5UmVmIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChbJ3dlYnJ0Yy1vZmZlcicsJ3dlYnJ0Yy1hbnN3ZXInLCd3ZWJydGMtaWNlJywnY2FsbC1yZXF1ZXN0JywnY2FsbC1hY2NlcHQnLCdjYWxsLXJlamVjdCcsJ2NhbGwtZW5kJ10uaW5jbHVkZXMobXQpKSB7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbENhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKGV2ZW50LnB1YmtleSwgeyB0eXBlOiBtdCwgc2RwOiBwLnNkcCwgY2FuZGlkYXRlOiBwLmNhbmRpZGF0ZSwgY2FsbFR5cGU6IHAuY2FsbFR5cGUgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobXQgPT09ICdmaWxlLWNodW5rJykgeyB0aGlzLmhhbmRsZUZpbGVDaHVuayhldmVudC5pZCwgZXZlbnQucHVia2V5LCBwVGFnWzFdLCBldmVudC5jcmVhdGVkX2F0ICogMTAwMCwgcCk7IHJldHVybjsgfVxuICAgICAgICAgIGlmIChtdCA9PT0gJ2ZpbGUtbWV0YScpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVySWQgPSAocC50cmFuc2ZlcklkIGFzIHN0cmluZykgfHwgJyc7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZmVySWQpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVUeXBlID0gWydpbWFnZScsICdhdWRpbyddLmluY2x1ZGVzKHAuZmlsZVR5cGUgYXMgc3RyaW5nKSA/IHAuZmlsZVR5cGUgYXMgKCdpbWFnZScgfCAnYXVkaW8nKSA6ICdmaWxlJztcbiAgICAgICAgICAgIGF3YWl0IGVuc3VyZVRyYW5zZmVyKHtcbiAgICAgICAgICAgICAgdHJhbnNmZXJJZCxcbiAgICAgICAgICAgICAgZmlsZU5hbWU6IChwLmZpbGVOYW1lIGFzIHN0cmluZykgfHwgJ2ZpbGUnLFxuICAgICAgICAgICAgICBtaW1lVHlwZTogKHAubWltZVR5cGUgYXMgc3RyaW5nKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgZmlsZVR5cGUsXG4gICAgICAgICAgICAgIHNpemU6IChwLnNpemUgYXMgbnVtYmVyKSB8fCAwLFxuICAgICAgICAgICAgICB0b3RhbENodW5rczogKHAudG90YWxDaHVua3MgYXMgbnVtYmVyKSB8fCAwLFxuICAgICAgICAgICAgICB0ZXh0OiAocC50ZXh0IGFzIHN0cmluZykgfHwgJycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG10ID09PSAnaW1hZ2UnIHx8IG10ID09PSAnZmlsZScgfHwgbXQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHsgaWQ6IGV2ZW50LmlkLCBmcm9tOiBldmVudC5wdWJrZXksIHRvOiBwVGFnWzFdLCBjb250ZW50OiBwLnRleHQgfHwgJycsIHRpbWVzdGFtcDogZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsIG1zZ1R5cGU6IG10LCByZXBseVRvOiBwLnJlcGx5VG8gYXMgUmVwbHlSZWYgfCB1bmRlZmluZWQsIGF0dGFjaG1lbnQ6IHsgdHlwZTogbXQsIG5hbWU6IHAuZmlsZU5hbWUgfHwgJ2ZpbGUnLCBtaW1lVHlwZTogcC5taW1lVHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJywgZGF0YTogcC5kYXRhIHx8ICcnLCBzaXplOiBwLnNpemUgfHwgMCB9IH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge31cbiAgICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHsgaWQ6IGV2ZW50LmlkLCBmcm9tOiBldmVudC5wdWJrZXksIHRvOiBwVGFnWzFdLCBjb250ZW50OiBkZWMsIHRpbWVzdGFtcDogZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsIG1zZ1R5cGU6ICd0ZXh0JyB9KSk7XG4gICAgfSBjYXRjaCB7fVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVGaWxlQ2h1bmsoZXZlbnRJZDogc3RyaW5nLCBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIHRpbWVzdGFtcDogbnVtYmVyLCBwOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIGNvbnN0IHRyYW5zZmVySWQgPSBwLnRyYW5zZmVySWQgYXMgc3RyaW5nO1xuICAgIGNvbnN0IGNodW5rSW5kZXggPSBwLmNodW5rSW5kZXggYXMgbnVtYmVyO1xuICAgIGNvbnN0IHRvdGFsQ2h1bmtzID0gcC50b3RhbENodW5rcyBhcyBudW1iZXI7XG4gICAgY29uc3QgZGF0YSA9IHAuZGF0YSBhcyBzdHJpbmc7XG4gICAgaWYgKCF0cmFuc2ZlcklkIHx8IHR5cGVvZiBjaHVua0luZGV4ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdG90YWxDaHVua3MgIT09ICdudW1iZXInIHx8IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuXG4gICAgY29uc3QgZmlsZVR5cGUgPSBbJ2ltYWdlJywgJ2F1ZGlvJ10uaW5jbHVkZXMocC5maWxlVHlwZSBhcyBzdHJpbmcpID8gcC5maWxlVHlwZSBhcyAoJ2ltYWdlJyB8ICdhdWRpbycpIDogJ2ZpbGUnO1xuICAgIGF3YWl0IGVuc3VyZVRyYW5zZmVyKHtcbiAgICAgIHRyYW5zZmVySWQsXG4gICAgICBmaWxlTmFtZTogKHAuZmlsZU5hbWUgYXMgc3RyaW5nKSB8fCAnZmlsZScsXG4gICAgICBtaW1lVHlwZTogKHAubWltZVR5cGUgYXMgc3RyaW5nKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgIGZpbGVUeXBlLFxuICAgICAgc2l6ZTogKHAuc2l6ZSBhcyBudW1iZXIpIHx8IDAsXG4gICAgICB0b3RhbENodW5rcyxcbiAgICAgIHRleHQ6IChwLnRleHQgYXMgc3RyaW5nKSB8fCAnJyxcbiAgICB9KTtcbiAgICBhd2FpdCBzdG9yZUNodW5rKHRyYW5zZmVySWQsIGNodW5rSW5kZXgsIHRvdGFsQ2h1bmtzLCBkYXRhKTtcbiAgICBjb25zdCBkb25lID0gYXdhaXQgaXNUcmFuc2ZlckNvbXBsZXRlKHRyYW5zZmVySWQpO1xuICAgIGlmICghZG9uZSkgcmV0dXJuO1xuXG4gICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2Ioe1xuICAgICAgaWQ6IGAke2V2ZW50SWR9LWFzc2VtYmxlZC0ke3RyYW5zZmVySWR9YCxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIGNvbnRlbnQ6IChwLnRleHQgYXMgc3RyaW5nKSB8fCAnJyxcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIG1zZ1R5cGU6IGZpbGVUeXBlLFxuICAgICAgcmVwbHlUbzogcC5yZXBseVRvIGFzIFJlcGx5UmVmIHwgdW5kZWZpbmVkLFxuICAgICAgYXR0YWNobWVudDoge1xuICAgICAgICB0eXBlOiBmaWxlVHlwZSxcbiAgICAgICAgbmFtZTogKHAuZmlsZU5hbWUgYXMgc3RyaW5nKSB8fCAnZmlsZScsXG4gICAgICAgIG1pbWVUeXBlOiAocC5taW1lVHlwZSBhcyBzdHJpbmcpIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICBkYXRhOiAnJyxcbiAgICAgICAgc2l6ZTogKHAuc2l6ZSBhcyBudW1iZXIpIHx8IDAsXG4gICAgICAgIHRyYW5zZmVySWQsXG4gICAgICAgIHRvdGFsQ2h1bmtzLFxuICAgICAgICBjaHVua2VkOiB0cnVlLFxuICAgICAgfSxcbiAgICB9KSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVByb2ZpbGVFdmVudChldmVudDogTm9zdHJFdmVudCkge1xuICAgIHRyeSB7IGNvbnN0IHAgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpIGFzIE5vc3RyUHJvZmlsZTsgdGhpcy5wcm9maWxlQ2FjaGUuc2V0KGV2ZW50LnB1YmtleSwgcCk7IHRoaXMucGVuZGluZ1Byb2ZpbGVzLmRlbGV0ZShldmVudC5wdWJrZXkpOyB0aGlzLnByb2ZpbGVDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYihldmVudC5wdWJrZXksIHApKTsgfSBjYXRjaCB7fVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVDaGFubmVsRXZlbnQoZXZlbnQ6IE5vc3RyRXZlbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuY29udGVudCkgYXMgeyBuYW1lPzogc3RyaW5nOyBhYm91dD86IHN0cmluZyB9O1xuICAgICAgY29uc3QgY2hhbm5lbDogQ2hhbm5lbCA9IHtcbiAgICAgICAgaWQ6IGV2ZW50LmlkLFxuICAgICAgICBuYW1lOiBwYXlsb2FkLm5hbWU/LnRyaW0oKSB8fCBgY2hhbm5lbC0ke2V2ZW50LmlkLnNsaWNlKDAsIDgpfWAsXG4gICAgICAgIGFib3V0OiBwYXlsb2FkLmFib3V0LFxuICAgICAgICBjcmVhdGVkQnk6IGV2ZW50LnB1YmtleSxcbiAgICAgICAgY3JlYXRlZEF0OiBldmVudC5jcmVhdGVkX2F0ICogMTAwMCxcbiAgICAgIH07XG4gICAgICB0aGlzLmNoYW5uZWxDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYihjaGFubmVsKSk7XG4gICAgfSBjYXRjaCB7fVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVDaGFubmVsTWVzc2FnZUV2ZW50KGV2ZW50OiBOb3N0ckV2ZW50KSB7XG4gICAgY29uc3QgZVRhZyA9IGV2ZW50LnRhZ3MuZmluZCh0ID0+IHRbMF0gPT09ICdlJyk/LlsxXTtcbiAgICBpZiAoIWVUYWcpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuY29udGVudCkgYXMgeyB0ZXh0Pzogc3RyaW5nOyByZXBseVRvPzogUmVwbHlSZWYgfTtcbiAgICAgIHRoaXMuY2hhbm5lbE1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYih7XG4gICAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgICAgZnJvbTogZXZlbnQucHVia2V5LFxuICAgICAgICB0bzogJycsXG4gICAgICAgIGNvbnRlbnQ6IHBheWxvYWQudGV4dCB8fCAnJyxcbiAgICAgICAgdGltZXN0YW1wOiBldmVudC5jcmVhdGVkX2F0ICogMTAwMCxcbiAgICAgICAgbXNnVHlwZTogJ2NoYW5uZWwnLFxuICAgICAgICBjaGFubmVsSWQ6IGVUYWcsXG4gICAgICAgIHJlcGx5VG86IHBheWxvYWQucmVwbHlUbyxcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMuY2hhbm5lbE1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYih7XG4gICAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgICAgZnJvbTogZXZlbnQucHVia2V5LFxuICAgICAgICB0bzogJycsXG4gICAgICAgIGNvbnRlbnQ6IGV2ZW50LmNvbnRlbnQgfHwgJycsXG4gICAgICAgIHRpbWVzdGFtcDogZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsXG4gICAgICAgIG1zZ1R5cGU6ICdjaGFubmVsJyxcbiAgICAgICAgY2hhbm5lbElkOiBlVGFnLFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaWJlVG9NZXNzYWdlcyhyZWxheVVybDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLl9waykgcmV0dXJuO1xuICAgIGNvbnN0IHdzID0gdGhpcy5zb2NrZXRzLmdldChyZWxheVVybCk7IGlmICghd3MgfHwgd3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHJldHVybjtcbiAgICBjb25zdCBzdWJJZCA9ICdkbS0nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOCk7XG4gICAgY29uc3Qgc2luY2UgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAtIDg2NDAwICogMzA7XG4gICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeShbJ1JFUScsIHN1YklkLCB7IGtpbmRzOiBbNF0sICcjcCc6IFt0aGlzLl9wa10sIHNpbmNlIH0sIHsga2luZHM6IFs0XSwgYXV0aG9yczogW3RoaXMuX3BrXSwgc2luY2UgfV0pKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc2V0KHN1YklkLCB7IGZpbHRlcnM6IFtdLCByZWxheTogcmVsYXlVcmwgfSk7XG4gICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWxzKHJlbGF5VXJsKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaWJlVG9DaGFubmVscyhyZWxheVVybDogc3RyaW5nKSB7XG4gICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tldHMuZ2V0KHJlbGF5VXJsKTtcbiAgICBpZiAoIXdzIHx8IHdzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSByZXR1cm47XG4gICAgaWYgKHRoaXMuX2NoYW5uZWxzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBEbyBub3Qgc3Vic2NyaWJlIHRvIGdsb2JhbCBjaGFubmVsc1xuXG4gICAgY29uc3Qgc3ViSWQgPSAnY2gtJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDgpO1xuICAgIGNvbnN0IHNpbmNlID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgLSA4NjQwMCAqIDMwO1xuXG4gICAgLy8gT25seSBzdWJzY3JpYmUgdG8gY2hhbm5lbHMgdGhlIHVzZXIgaGFzIGpvaW5lZFxuICAgIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkoWydSRVEnLCBzdWJJZCwgeyBraW5kczogWzQwXSwgaWRzOiB0aGlzLl9jaGFubmVscywgc2luY2UgfSwgeyBraW5kczogWzQyXSwgJyNlJzogdGhpcy5fY2hhbm5lbHMsIHNpbmNlIH1dKSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWJJZCwgeyBmaWx0ZXJzOiBbXSwgcmVsYXk6IHJlbGF5VXJsIH0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5OiBzdHJpbmcsIHBheWxvYWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLl9zaykgdGhyb3cgbmV3IEVycm9yKCfQndC1INCw0LLRgtC+0YDQuNC30L7QstCw0L0nKTtcbiAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBlbmNyeXB0KHRoaXMuX3NrLCByZWNpcGllbnRQdWJrZXksIHBheWxvYWQpO1xuICAgIGNvbnN0IGV2OiBVbnNpZ25lZEV2ZW50ID0geyBraW5kOiA0LCBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSwgdGFnczogW1sncCcsIHJlY2lwaWVudFB1YmtleV1dLCBjb250ZW50OiBlbmNyeXB0ZWQsIHB1YmtleTogdGhpcy5fcGsgfTtcbiAgICBjb25zdCBldmVudCA9IGZpbmFsaXplRXZlbnQoZXYsIHRoaXMuX3NrKTtcbiAgICB0aGlzLnNlZW5FdmVudHMuYWRkKGV2ZW50LmlkKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoWydFVkVOVCcsIGV2ZW50XSk7XG4gICAgY29uc3Qgb3BlbjogV2ViU29ja2V0W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFssIHdzXSBvZiB0aGlzLnNvY2tldHMpIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgb3Blbi5wdXNoKHdzKTtcbiAgICBpZiAoIW9wZW4ubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ9Cd0LXRgiDQv9C+0LTQutC70Y7Rh9GR0L3QvdGL0YUg0YDQtdC70LXQtdCyJyk7XG4gICAgb3Blbi5mb3JFYWNoKHdzID0+IHsgdHJ5IHsgd3Muc2VuZChqc29uKTsgfSBjYXRjaCB7fSB9KTtcbiAgICByZXR1cm4gZXZlbnQuaWQ7XG4gIH1cblxuICBwcml2YXRlIGJ5dGVzVG9CYXNlNjQoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICAgIGxldCBiaW4gPSAnJztcbiAgICBjb25zdCBzdGVwID0gMHg4MDAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGJpbiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJ5dGVzLnN1YmFycmF5KGksIGkgKyBzdGVwKSk7XG4gICAgfVxuICAgIHJldHVybiBidG9hKGJpbik7XG4gIH1cblxuICBhc3luYyBzZW5kRGlyZWN0TWVzc2FnZShyZWNpcGllbnRQdWJrZXk6IHN0cmluZywgY29udGVudDogc3RyaW5nLCByZXBseVRvPzogUmVwbHlSZWYpOiBQcm9taXNlPERpcmVjdE1lc3NhZ2U+IHtcbiAgICBjb25zdCBwYXlsb2FkID0gcmVwbHlUbyA/IEpTT04uc3RyaW5naWZ5KHsgX25vc3RyX21zZ190eXBlOiAndGV4dCcsIHRleHQ6IGNvbnRlbnQsIHJlcGx5VG8gfSkgOiBjb250ZW50O1xuICAgIGNvbnN0IGlkID0gYXdhaXQgdGhpcy5zZW5kRW5jcnlwdGVkUGF5bG9hZChyZWNpcGllbnRQdWJrZXksIHBheWxvYWQpO1xuICAgIHJldHVybiB7IGlkLCBmcm9tOiB0aGlzLl9waywgdG86IHJlY2lwaWVudFB1YmtleSwgY29udGVudCwgdGltZXN0YW1wOiBEYXRlLm5vdygpLCBtc2dUeXBlOiAndGV4dCcsIHJlcGx5VG8gfTtcbiAgfVxuXG4gIC8vIDI1NktCIGNodW5rcywgcGFyYWxsZWwgc2VuZCBieSAzXG4gIHByaXZhdGUgc3RhdGljIENIVU5LX1NJWkUgPSAyNjIxNDQ7XG4gIHByaXZhdGUgc3RhdGljIFBBUkFMTEVMID0gMztcblxuICBhc3luYyBzZW5kQXR0YWNobWVudChcbiAgICByZWNpcGllbnRQdWJrZXk6IHN0cmluZyxcbiAgICBhdHRhY2htZW50OiBBdHRhY2htZW50LFxuICAgIHRleHQ/OiBzdHJpbmcsXG4gICAgb25Qcm9ncmVzcz86IChzZW50OiBudW1iZXIsIHRvdGFsOiBudW1iZXIpID0+IHZvaWQsXG4gICAgcmVwbHlUbz86IFJlcGx5UmVmLFxuICApOiBQcm9taXNlPERpcmVjdE1lc3NhZ2U+IHtcbiAgICBjb25zdCBtYXhTaXplID0gMiAqIDEwMjQgKiAxMDI0ICogMTAyNDtcbiAgICBpZiAoYXR0YWNobWVudC5zaXplID4gbWF4U2l6ZSkgdGhyb3cgbmV3IEVycm9yKCdGaWxlIGlzIHRvbyBsYXJnZS4gTWF4IHNpemUgaXMgMkdCLicpO1xuXG4gICAgaWYgKCFhdHRhY2htZW50LmZpbGUpIHtcbiAgICAgIGNvbnN0IGI2NCA9IGF0dGFjaG1lbnQuZGF0YTtcbiAgICAgIGlmIChiNjQubGVuZ3RoIDwgNDAwMDApIHtcbiAgICAgICAgY29uc3QgaWQgPSBhd2FpdCB0aGlzLnNlbmRFbmNyeXB0ZWRQYXlsb2FkKHJlY2lwaWVudFB1YmtleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIF9ub3N0cl9tc2dfdHlwZTogYXR0YWNobWVudC50eXBlLFxuICAgICAgICAgIGZpbGVOYW1lOiBhdHRhY2htZW50Lm5hbWUsXG4gICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQubWltZVR5cGUsXG4gICAgICAgICAgZGF0YTogYjY0LFxuICAgICAgICAgIHNpemU6IGF0dGFjaG1lbnQuc2l6ZSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0IHx8ICcnLFxuICAgICAgICAgIHJlcGx5VG8sXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHsgaWQsIGZyb206IHRoaXMuX3BrLCB0bzogcmVjaXBpZW50UHVia2V5LCBjb250ZW50OiB0ZXh0IHx8ICcnLCB0aW1lc3RhbXA6IERhdGUubm93KCksIG1zZ1R5cGU6IGF0dGFjaG1lbnQudHlwZSwgYXR0YWNobWVudCwgcmVwbHlUbyB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpbGUgPSBhdHRhY2htZW50LmZpbGU7XG4gICAgY29uc3QgdHJhbnNmZXJJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpICsgRGF0ZS5ub3coKS50b1N0cmluZygzNik7XG4gICAgY29uc3QgZmlsZVNpemUgPSBmaWxlID8gZmlsZS5zaXplIDogYXR0YWNobWVudC5zaXplO1xuICAgIGNvbnN0IHRvdGFsQ2h1bmtzID0gTWF0aC5jZWlsKGZpbGVTaXplIC8gTm9zdHJDbGllbnQuQ0hVTktfU0laRSk7XG4gICAgbGV0IGxhc3RJZCA9ICcnO1xuICAgIGxldCBzZW50ID0gMDtcblxuICAgIGF3YWl0IHRoaXMuc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBfbm9zdHJfbXNnX3R5cGU6ICdmaWxlLW1ldGEnLFxuICAgICAgdHJhbnNmZXJJZCxcbiAgICAgIHRvdGFsQ2h1bmtzLFxuICAgICAgZmlsZU5hbWU6IGF0dGFjaG1lbnQubmFtZSxcbiAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50Lm1pbWVUeXBlLFxuICAgICAgc2l6ZTogZmlsZVNpemUsXG4gICAgICB0ZXh0OiB0ZXh0IHx8ICcnLFxuICAgICAgZmlsZVR5cGU6IGF0dGFjaG1lbnQudHlwZSxcbiAgICAgIHJlcGx5VG8sXG4gICAgfSkpO1xuXG4gICAgZm9yIChsZXQgYmF0Y2ggPSAwOyBiYXRjaCA8IHRvdGFsQ2h1bmtzOyBiYXRjaCArPSBOb3N0ckNsaWVudC5QQVJBTExFTCkge1xuICAgICAgY29uc3QgcHJvbWlzZXM6IFByb21pc2U8c3RyaW5nPltdID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE5vc3RyQ2xpZW50LlBBUkFMTEVMICYmIGJhdGNoICsgaiA8IHRvdGFsQ2h1bmtzOyBqKyspIHtcbiAgICAgICAgY29uc3QgaSA9IGJhdGNoICsgajtcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IGkgKiBOb3N0ckNsaWVudC5DSFVOS19TSVpFO1xuICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgTm9zdHJDbGllbnQuQ0hVTktfU0laRSwgZmlsZVNpemUpO1xuICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgZmlsZS5zbGljZShzdGFydCwgZW5kKS5hcnJheUJ1ZmZlcigpKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5ieXRlc1RvQmFzZTY0KGJ5dGVzKTtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBfbm9zdHJfbXNnX3R5cGU6ICdmaWxlLWNodW5rJyxcbiAgICAgICAgICAgIHRyYW5zZmVySWQsXG4gICAgICAgICAgICBjaHVua0luZGV4OiBpLFxuICAgICAgICAgICAgdG90YWxDaHVua3MsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGF0dGFjaG1lbnQubmFtZSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50Lm1pbWVUeXBlLFxuICAgICAgICAgICAgc2l6ZTogZmlsZVNpemUsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0IHx8ICcnLFxuICAgICAgICAgICAgZmlsZVR5cGU6IGF0dGFjaG1lbnQudHlwZSxcbiAgICAgICAgICAgIHJlcGx5VG8sXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlNjRDaHVua1NpemUgPSBNYXRoLmZsb29yKChOb3N0ckNsaWVudC5DSFVOS19TSVpFIC8gMykgKiA0KTtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IGF0dGFjaG1lbnQuZGF0YS5zbGljZShpICogYmFzZTY0Q2h1bmtTaXplLCAoaSArIDEpICogYmFzZTY0Q2h1bmtTaXplKTtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBfbm9zdHJfbXNnX3R5cGU6ICdmaWxlLWNodW5rJyxcbiAgICAgICAgICAgIHRyYW5zZmVySWQsXG4gICAgICAgICAgICBjaHVua0luZGV4OiBpLFxuICAgICAgICAgICAgdG90YWxDaHVua3MsXG4gICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBhdHRhY2htZW50Lm5hbWUsXG4gICAgICAgICAgICBtaW1lVHlwZTogYXR0YWNobWVudC5taW1lVHlwZSxcbiAgICAgICAgICAgIHNpemU6IGZpbGVTaXplLFxuICAgICAgICAgICAgdGV4dDogdGV4dCB8fCAnJyxcbiAgICAgICAgICAgIGZpbGVUeXBlOiBhdHRhY2htZW50LnR5cGUsXG4gICAgICAgICAgICByZXBseVRvLFxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGxhc3RJZCA9IGlkc1tpZHMubGVuZ3RoIC0gMV0gfHwgbGFzdElkO1xuICAgICAgc2VudCArPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgICBvblByb2dyZXNzPy4oc2VudCwgdG90YWxDaHVua3MpO1xuICAgICAgaWYgKHNlbnQgPCB0b3RhbENodW5rcykgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDUwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBsYXN0SWQgfHwgYGxvY2FsLSR7dHJhbnNmZXJJZH1gLFxuICAgICAgZnJvbTogdGhpcy5fcGssXG4gICAgICB0bzogcmVjaXBpZW50UHVia2V5LFxuICAgICAgY29udGVudDogdGV4dCB8fCAnJyxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIG1zZ1R5cGU6IGF0dGFjaG1lbnQudHlwZSxcbiAgICAgIHJlcGx5VG8sXG4gICAgICBhdHRhY2htZW50OiB7XG4gICAgICAgIC4uLmF0dGFjaG1lbnQsXG4gICAgICAgIGRhdGE6IGF0dGFjaG1lbnQuZmlsZSA/ICcnIDogYXR0YWNobWVudC5kYXRhLFxuICAgICAgICB0cmFuc2ZlcklkLFxuICAgICAgICB0b3RhbENodW5rcyxcbiAgICAgICAgY2h1bmtlZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRXZWJSVENTaWduYWwocmVjaXBpZW50UHVia2V5OiBzdHJpbmcsIHNpZ25hbDogV2ViUlRDU2lnbmFsKSB7XG4gICAgYXdhaXQgdGhpcy5zZW5kRW5jcnlwdGVkUGF5bG9hZChyZWNpcGllbnRQdWJrZXksIEpTT04uc3RyaW5naWZ5KHsgX25vc3RyX21zZ190eXBlOiBzaWduYWwudHlwZSwgc2RwOiBzaWduYWwuc2RwLCBjYW5kaWRhdGU6IHNpZ25hbC5jYW5kaWRhdGUsIGNhbGxUeXBlOiBzaWduYWwuY2FsbFR5cGUgfSkpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQ2hhbm5lbChuYW1lOiBzdHJpbmcsIGFib3V0Pzogc3RyaW5nKTogUHJvbWlzZTxDaGFubmVsPiB7XG4gICAgaWYgKCF0aGlzLl9zaykgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aG9yaXplZCcpO1xuICAgIGNvbnN0IGV2OiBVbnNpZ25lZEV2ZW50ID0ge1xuICAgICAga2luZDogNDAsXG4gICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgIHRhZ3M6IFtdLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoeyBuYW1lLCBhYm91dDogYWJvdXQgfHwgJycgfSksXG4gICAgICBwdWJrZXk6IHRoaXMuX3BrLFxuICAgIH07XG4gICAgY29uc3QgZXZlbnQgPSBmaW5hbGl6ZUV2ZW50KGV2LCB0aGlzLl9zayk7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KFsnRVZFTlQnLCBldmVudF0pO1xuICAgIGZvciAoY29uc3QgWywgd3NdIG9mIHRoaXMuc29ja2V0cykgaWYgKHdzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB0cnkgeyB3cy5zZW5kKHBheWxvYWQpOyB9IGNhdGNoIHt9XG4gICAgY29uc3QgY2hhbm5lbDogQ2hhbm5lbCA9IHsgaWQ6IGV2ZW50LmlkLCBuYW1lLCBhYm91dCwgY3JlYXRlZEJ5OiB0aGlzLl9waywgY3JlYXRlZEF0OiBEYXRlLm5vdygpIH07XG4gICAgdGhpcy5jaGFubmVsQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IoY2hhbm5lbCkpO1xuICAgIHJldHVybiBjaGFubmVsO1xuICB9XG5cbiAgYXN5bmMgc2VuZENoYW5uZWxNZXNzYWdlKGNoYW5uZWxJZDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcsIHJlcGx5VG8/OiBSZXBseVJlZik6IFByb21pc2U8RGlyZWN0TWVzc2FnZT4ge1xuICAgIGlmICghdGhpcy5fc2spIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhvcml6ZWQnKTtcbiAgICBjb25zdCBldjogVW5zaWduZWRFdmVudCA9IHtcbiAgICAgIGtpbmQ6IDQyLFxuICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICB0YWdzOiBbWydlJywgY2hhbm5lbElkLCAnJywgJ3Jvb3QnXV0sXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh7IHRleHQsIHJlcGx5VG8gfSksXG4gICAgICBwdWJrZXk6IHRoaXMuX3BrLFxuICAgIH07XG4gICAgY29uc3QgZXZlbnQgPSBmaW5hbGl6ZUV2ZW50KGV2LCB0aGlzLl9zayk7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KFsnRVZFTlQnLCBldmVudF0pO1xuICAgIGxldCBzZW50ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbLCB3c10gb2YgdGhpcy5zb2NrZXRzKSB7XG4gICAgICBpZiAod3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIGNvbnRpbnVlO1xuICAgICAgc2VudCA9IHRydWU7XG4gICAgICB0cnkgeyB3cy5zZW5kKHBheWxvYWQpOyB9IGNhdGNoIHt9XG4gICAgfVxuICAgIGlmICghc2VudCkgdGhyb3cgbmV3IEVycm9yKCdObyBjb25uZWN0ZWQgcmVsYXlzJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgIGZyb206IHRoaXMuX3BrLFxuICAgICAgdG86ICcnLFxuICAgICAgY29udGVudDogdGV4dCxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIG1zZ1R5cGU6ICdjaGFubmVsJyxcbiAgICAgIGNoYW5uZWxJZCxcbiAgICAgIHJlcGx5VG8sXG4gICAgfTtcbiAgfVxuXG4gIHJlcXVlc3RQcm9maWxlKHB1YmtleTogc3RyaW5nKTogTm9zdHJQcm9maWxlIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMucHJvZmlsZUNhY2hlLmhhcyhwdWJrZXkpKSByZXR1cm4gdGhpcy5wcm9maWxlQ2FjaGUuZ2V0KHB1YmtleSkhO1xuICAgIGlmICh0aGlzLnBlbmRpbmdQcm9maWxlcy5oYXMocHVia2V5KSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5wZW5kaW5nUHJvZmlsZXMuYWRkKHB1YmtleSk7XG4gICAgY29uc3Qgc3ViSWQgPSAncC0nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOCk7XG4gICAgZm9yIChjb25zdCBbLCB3c10gb2YgdGhpcy5zb2NrZXRzKSB7IGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgeyB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KFsnUkVRJywgc3ViSWQsIHsga2luZHM6IFswXSwgYXV0aG9yczogW3B1YmtleV0sIGxpbWl0OiAxIH1dKSk7IGJyZWFrOyB9IH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFByb2ZpbGUocHVia2V5OiBzdHJpbmcpIHsgcmV0dXJuIHRoaXMucHJvZmlsZUNhY2hlLmdldChwdWJrZXkpIHx8IG51bGw7IH1cblxuICBhc3luYyB1cGRhdGVQcm9maWxlKHByb2ZpbGU6IE5vc3RyUHJvZmlsZSkge1xuICAgIGlmICghdGhpcy5fc2spIHRocm93IG5ldyBFcnJvcign0J3QtSDQsNCy0YLQvtGA0LjQt9C+0LLQsNC9Jyk7XG4gICAgY29uc3QgZXY6IFVuc2lnbmVkRXZlbnQgPSB7IGtpbmQ6IDAsIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLCB0YWdzOiBbXSwgY29udGVudDogSlNPTi5zdHJpbmdpZnkocHJvZmlsZSksIHB1YmtleTogdGhpcy5fcGsgfTtcbiAgICBjb25zdCBldmVudCA9IGZpbmFsaXplRXZlbnQoZXYsIHRoaXMuX3NrKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoWydFVkVOVCcsIGV2ZW50XSk7XG4gICAgZm9yIChjb25zdCBbLCB3c10gb2YgdGhpcy5zb2NrZXRzKSBpZiAod3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHRyeSB7IHdzLnNlbmQoanNvbik7IH0gY2F0Y2gge31cbiAgICB0aGlzLnByb2ZpbGVDYWNoZS5zZXQodGhpcy5fcGssIHByb2ZpbGUpO1xuICB9XG5cbiAgZGlzY29ubmVjdEFsbCgpIHtcbiAgICBmb3IgKGNvbnN0IFssIHRdIG9mIHRoaXMucmVjb25uZWN0VGltZXJzKSBjbGVhclRpbWVvdXQodCk7XG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lcnMuY2xlYXIoKTsgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgWywgd3NdIG9mIHRoaXMuc29ja2V0cykgd3MuY2xvc2UoKTtcbiAgICB0aGlzLnNvY2tldHMuY2xlYXIoKTsgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7IHRoaXMucmVsYXlTdGF0dXMuY2xlYXIoKTtcbiAgfVxuXG4gIGFkZFJlbGF5KHVybDogc3RyaW5nKSB7IGlmICghdGhpcy5fcmVsYXlzLmluY2x1ZGVzKHVybCkpIHsgdGhpcy5fcmVsYXlzLnB1c2godXJsKTsgdGhpcy5jb25uZWN0VG9SZWxheSh1cmwpOyB9IH1cbiAgcmVtb3ZlUmVsYXkodXJsOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9yZWxheXMgPSB0aGlzLl9yZWxheXMuZmlsdGVyKHIgPT4gciAhPT0gdXJsKTtcbiAgICBjb25zdCB0ID0gdGhpcy5yZWNvbm5lY3RUaW1lcnMuZ2V0KHVybCk7IGlmICh0KSB7IGNsZWFyVGltZW91dCh0KTsgdGhpcy5yZWNvbm5lY3RUaW1lcnMuZGVsZXRlKHVybCk7IH1cbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzLmRlbGV0ZSh1cmwpO1xuICAgIGNvbnN0IHdzID0gdGhpcy5zb2NrZXRzLmdldCh1cmwpOyBpZiAod3MpIHsgd3MuY2xvc2UoKTsgdGhpcy5zb2NrZXRzLmRlbGV0ZSh1cmwpOyB9XG4gICAgdGhpcy5yZWxheVN0YXR1cy5kZWxldGUodXJsKTtcbiAgfVxuXG4gIHNob3J0ZW5LZXkoa2V5OiBzdHJpbmcpIHsgcmV0dXJuICgha2V5IHx8IGtleS5sZW5ndGggPCAxNikgPyBrZXkgOiBrZXkuc2xpY2UoMCwgOCkgKyAn4oCmJyArIGtleS5zbGljZSgtOCk7IH1cbiAgaXNWYWxpZEhleEtleShrZXk6IHN0cmluZykgeyByZXR1cm4gL15bMC05YS1mQS1GXXs2NH0kLy50ZXN0KGtleSk7IH1cbn1cblxuZXhwb3J0IGNvbnN0IG5vc3RyQ2xpZW50ID0gbmV3IE5vc3RyQ2xpZW50KCk7XG5leHBvcnQgeyBERUZBVUxUX1JFTEFZUyB9O1xuIl0sIm5hbWVzIjpbImdlbmVyYXRlU2VjcmV0S2V5IiwiZ2V0UHVibGljS2V5IiwiZmluYWxpemVFdmVudCIsImVuY3J5cHQiLCJkZWNyeXB0IiwiYnl0ZXNUb0hleCIsImhleFRvQnl0ZXMiLCJlbnN1cmVUcmFuc2ZlciIsImlzVHJhbnNmZXJDb21wbGV0ZSIsInN0b3JlQ2h1bmsiLCJERUZBVUxUX1JFTEFZUyIsIk5vc3RyQ2xpZW50IiwicHVibGljS2V5IiwiX3BrIiwicHJpdmF0ZUtleUhleCIsIl9zayIsInJlbGF5cyIsIl9yZWxheXMiLCJjaGFubmVscyIsIl9jaGFubmVscyIsInNrIiwiZ2V0UmVsYXlTdGF0dXMiLCJyZWxheSIsInJlbGF5U3RhdHVzIiwiZ2V0IiwiY29ubmVjdGVkUmVsYXlDb3VudCIsImMiLCJmb3JFYWNoIiwicyIsImdlbmVyYXRlS2V5cyIsInBrIiwicHJpdmF0ZUtleSIsImxvZ2luIiwiX3N0b3BwZWQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwibG9nb3V0IiwiZGlzY29ubmVjdEFsbCIsInJlbW92ZUl0ZW0iLCJ0cnlBdXRvTG9naW4iLCJnZXRJdGVtIiwibGVuZ3RoIiwib25NZXNzYWdlIiwiY2IiLCJtZXNzYWdlQ2FsbGJhY2tzIiwiYWRkIiwiZGVsZXRlIiwib25DaGFubmVsIiwiY2hhbm5lbENhbGxiYWNrcyIsIm9uQ2hhbm5lbE1lc3NhZ2UiLCJjaGFubmVsTWVzc2FnZUNhbGxiYWNrcyIsIm9uUHJvZmlsZSIsInByb2ZpbGVDYWxsYmFja3MiLCJvbkNvbm5lY3Rpb24iLCJjb25uZWN0aW9uQ2FsbGJhY2tzIiwib25TaWduYWwiLCJzaWduYWxDYWxsYmFja3MiLCJjb25uZWN0VG9SZWxheXMiLCJyIiwiY29ubmVjdFRvUmVsYXkiLCJzZXRDaGFubmVscyIsImNoYW5uZWxJZHMiLCJTZXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwid3MiLCJzb2NrZXRzIiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJzdWJzY3JpYmVUb0NoYW5uZWxzIiwidXJsIiwiaGFzIiwiZSIsIkNPTk5FQ1RJTkciLCJzZXQiLCJjdCIsInNldFRpbWVvdXQiLCJjbG9zZSIsIm9ub3BlbiIsImNsZWFyVGltZW91dCIsInJlY29ubmVjdEF0dGVtcHRzIiwic3Vic2NyaWJlVG9NZXNzYWdlcyIsIm9uY2xvc2UiLCJzY2hlZHVsZVJlY29ubmVjdCIsIm9uZXJyb3IiLCJvbm1lc3NhZ2UiLCJoYW5kbGVSZWxheU1lc3NhZ2UiLCJKU09OIiwicGFyc2UiLCJkYXRhIiwicmVjb25uZWN0VGltZXJzIiwiYSIsImQiLCJNYXRoIiwibWluIiwicG93IiwiQXJyYXkiLCJpc0FycmF5IiwiZXYiLCJzZWVuRXZlbnRzIiwiaWQiLCJraW5kIiwiaGFuZGxlRW5jcnlwdGVkRE0iLCJoYW5kbGVQcm9maWxlRXZlbnQiLCJoYW5kbGVDaGFubmVsRXZlbnQiLCJoYW5kbGVDaGFubmVsTWVzc2FnZUV2ZW50IiwiZXZlbnQiLCJwVGFnIiwidGFncyIsImZpbmQiLCJ0IiwiaXNGb3JNZSIsImlzRnJvbU1lIiwicHVia2V5Iiwib3RoZXIiLCJkZWMiLCJjb250ZW50IiwicCIsIl9ub3N0cl9tc2dfdHlwZSIsIm10IiwiZnJvbSIsInRvIiwidGV4dCIsInRpbWVzdGFtcCIsImNyZWF0ZWRfYXQiLCJtc2dUeXBlIiwicmVwbHlUbyIsImluY2x1ZGVzIiwidHlwZSIsInNkcCIsImNhbmRpZGF0ZSIsImNhbGxUeXBlIiwiaGFuZGxlRmlsZUNodW5rIiwidHJhbnNmZXJJZCIsImZpbGVUeXBlIiwiZmlsZU5hbWUiLCJtaW1lVHlwZSIsInNpemUiLCJ0b3RhbENodW5rcyIsImF0dGFjaG1lbnQiLCJuYW1lIiwiZXZlbnRJZCIsImNodW5rSW5kZXgiLCJkb25lIiwiY2h1bmtlZCIsInByb2ZpbGVDYWNoZSIsInBlbmRpbmdQcm9maWxlcyIsInBheWxvYWQiLCJjaGFubmVsIiwidHJpbSIsInNsaWNlIiwiYWJvdXQiLCJjcmVhdGVkQnkiLCJjcmVhdGVkQXQiLCJlVGFnIiwiY2hhbm5lbElkIiwicmVsYXlVcmwiLCJzdWJJZCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2luY2UiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJzZW5kIiwic3RyaW5naWZ5Iiwia2luZHMiLCJhdXRob3JzIiwic3Vic2NyaXB0aW9ucyIsImZpbHRlcnMiLCJpZHMiLCJzZW5kRW5jcnlwdGVkUGF5bG9hZCIsInJlY2lwaWVudFB1YmtleSIsIkVycm9yIiwiZW5jcnlwdGVkIiwianNvbiIsIm9wZW4iLCJwdXNoIiwiYnl0ZXNUb0Jhc2U2NCIsImJ5dGVzIiwiYmluIiwic3RlcCIsImkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdWJhcnJheSIsImJ0b2EiLCJzZW5kRGlyZWN0TWVzc2FnZSIsInNlbmRBdHRhY2htZW50Iiwib25Qcm9ncmVzcyIsIm1heFNpemUiLCJmaWxlIiwiYjY0IiwiZmlsZVNpemUiLCJjZWlsIiwiQ0hVTktfU0laRSIsImxhc3RJZCIsInNlbnQiLCJiYXRjaCIsIlBBUkFMTEVMIiwicHJvbWlzZXMiLCJqIiwic3RhcnQiLCJlbmQiLCJVaW50OEFycmF5IiwiYXJyYXlCdWZmZXIiLCJiYXNlNjRDaHVua1NpemUiLCJjaHVuayIsIlByb21pc2UiLCJhbGwiLCJzZW5kV2ViUlRDU2lnbmFsIiwic2lnbmFsIiwiY3JlYXRlQ2hhbm5lbCIsInNlbmRDaGFubmVsTWVzc2FnZSIsInJlcXVlc3RQcm9maWxlIiwibGltaXQiLCJnZXRQcm9maWxlIiwidXBkYXRlUHJvZmlsZSIsInByb2ZpbGUiLCJjbGVhciIsImFkZFJlbGF5IiwicmVtb3ZlUmVsYXkiLCJzaG9ydGVuS2V5Iiwia2V5IiwiaXNWYWxpZEhleEtleSIsInRlc3QiLCJNYXAiLCJub3N0ckNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/nostr.ts\n"));

/***/ })

});