"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/chunkStore.ts":
/*!*******************************!*\
  !*** ./src/lib/chunkStore.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadChunkedTransfer: function() { return /* binding */ downloadChunkedTransfer; },\n/* harmony export */   ensureTransfer: function() { return /* binding */ ensureTransfer; },\n/* harmony export */   getTransfer: function() { return /* binding */ getTransfer; },\n/* harmony export */   isTransferComplete: function() { return /* binding */ isTransferComplete; },\n/* harmony export */   storeChunk: function() { return /* binding */ storeChunk; }\n/* harmony export */ });\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb */ \"(app-pages-browser)/./node_modules/idb/build/index.js\");\n\nconst DB_NAME = \"nostr-p2p-files\";\nconst DB_VERSION = 1;\nlet dbPromise = null;\nconst getDb = ()=>{\n    if ( false || !window.indexedDB) {\n        return null;\n    }\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_0__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade (db) {\n                if (!db.objectStoreNames.contains(\"transfers\")) {\n                    db.createObjectStore(\"transfers\", {\n                        keyPath: \"transferId\"\n                    });\n                }\n                if (!db.objectStoreNames.contains(\"chunks\")) {\n                    db.createObjectStore(\"chunks\", {\n                        keyPath: [\n                            \"transferId\",\n                            \"index\"\n                        ]\n                    });\n                }\n            }\n        });\n    }\n    return dbPromise;\n};\nfunction base64ToBytes(base64) {\n    const bin = atob(base64);\n    const out = new Uint8Array(bin.length);\n    for(let i = 0; i < bin.length; i++)out[i] = bin.charCodeAt(i);\n    return out;\n}\nasync function ensureTransfer(meta) {\n    const db = await getDb();\n    if (!db) return null;\n    const existing = await db.get(\"transfers\", meta.transferId);\n    var _existing_receivedChunks, _ref;\n    const row = {\n        ...meta,\n        receivedChunks: (_ref = (_existing_receivedChunks = existing === null || existing === void 0 ? void 0 : existing.receivedChunks) !== null && _existing_receivedChunks !== void 0 ? _existing_receivedChunks : meta.receivedChunks) !== null && _ref !== void 0 ? _ref : 0\n    };\n    await db.put(\"transfers\", row);\n    return row;\n}\nasync function storeChunk(transferId, index, totalChunks, data) {\n    const db = await getDb();\n    if (!db) return;\n    const tx = db.transaction([\n        \"chunks\",\n        \"transfers\"\n    ], \"readwrite\");\n    const key = [\n        transferId,\n        index\n    ];\n    const existing = await tx.objectStore(\"chunks\").get(key);\n    if (!existing) {\n        await tx.objectStore(\"chunks\").put({\n            transferId,\n            index,\n            data\n        });\n        const transfer = await tx.objectStore(\"transfers\").get(transferId);\n        if (transfer) {\n            transfer.receivedChunks = Math.min(transfer.totalChunks, transfer.receivedChunks + 1);\n            await tx.objectStore(\"transfers\").put(transfer);\n        } else {\n            await tx.objectStore(\"transfers\").put({\n                transferId,\n                fileName: \"file\",\n                mimeType: \"application/octet-stream\",\n                fileType: \"file\",\n                size: 0,\n                totalChunks,\n                receivedChunks: 1\n            });\n        }\n    }\n    await tx.done;\n}\nasync function getTransfer(transferId) {\n    const db = await getDb();\n    if (!db) return undefined;\n    return await db.get(\"transfers\", transferId);\n}\nasync function isTransferComplete(transferId) {\n    if ( false || !window.indexedDB) {\n        return false;\n    }\n    const transfer = await getTransfer(transferId);\n    if (!transfer) return false;\n    return transfer.totalChunks > 0 && transfer.receivedChunks >= transfer.totalChunks;\n}\nasync function downloadChunkedTransfer(transferId, fallbackName, fallbackMime) {\n    let returnBlob = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    const db = await getDb();\n    if (!db) return returnBlob ? null : undefined;\n    const transfer = await db.get(\"transfers\", transferId);\n    if (!transfer) {\n        console.error(\"Transfer not found:\", transferId);\n        return returnBlob ? null : undefined;\n    }\n    const fileName = fallbackName || transfer.fileName || \"file\";\n    const mimeType = fallbackMime || transfer.mimeType || \"application/octet-stream\";\n    const range = IDBKeyRange.bound([\n        transferId,\n        0\n    ], [\n        transferId,\n        Number.MAX_SAFE_INTEGER\n    ]);\n    const store = db.transaction(\"chunks\", \"readonly\").objectStore(\"chunks\");\n    const parts = [];\n    let cursor = await store.openCursor(range);\n    while(cursor){\n        const row = cursor.value;\n        parts.push(base64ToBytes(row.data));\n        cursor = await cursor.continue();\n    }\n    if (parts.length === 0) {\n        console.error(\"No chunks found for transfer:\", transferId);\n        return returnBlob ? null : undefined;\n    }\n    const blob = new Blob(parts, {\n        type: mimeType\n    });\n    if (returnBlob) {\n        return blob;\n    }\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = fileName;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY2h1bmtTdG9yZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Q7QUFtQmhELE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsYUFBYTtBQUVuQixJQUFJQyxZQUEwQztBQUU5QyxNQUFNQyxRQUFRO0lBQ1osSUFBSSxNQUFrQixJQUFlLENBQUNDLE9BQU9DLFNBQVMsRUFBRTtRQUN0RCxPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUNILFdBQVc7UUFDZEEsWUFBWUgsMkNBQU1BLENBQUNDLFNBQVNDLFlBQVk7WUFDdENLLFNBQVFDLEVBQUU7Z0JBQ1IsSUFBSSxDQUFDQSxHQUFHQyxnQkFBZ0IsQ0FBQ0MsUUFBUSxDQUFDLGNBQWM7b0JBQzlDRixHQUFHRyxpQkFBaUIsQ0FBQyxhQUFhO3dCQUFFQyxTQUFTO29CQUFhO2dCQUM1RDtnQkFDQSxJQUFJLENBQUNKLEdBQUdDLGdCQUFnQixDQUFDQyxRQUFRLENBQUMsV0FBVztvQkFDM0NGLEdBQUdHLGlCQUFpQixDQUFDLFVBQVU7d0JBQUVDLFNBQVM7NEJBQUM7NEJBQWM7eUJBQVE7b0JBQUM7Z0JBQ3BFO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT1Q7QUFDVDtBQUVBLFNBQVNVLGNBQWNDLE1BQWM7SUFDbkMsTUFBTUMsTUFBTUMsS0FBS0Y7SUFDakIsTUFBTUcsTUFBTSxJQUFJQyxXQUFXSCxJQUFJSSxNQUFNO0lBQ3JDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxJQUFJSSxNQUFNLEVBQUVDLElBQUtILEdBQUcsQ0FBQ0csRUFBRSxHQUFHTCxJQUFJTSxVQUFVLENBQUNEO0lBQzdELE9BQU9IO0FBQ1Q7QUFFTyxlQUFlSyxlQUFlQyxJQUF1RTtJQUMxRyxNQUFNZixLQUFLLE1BQU1KO0lBQ2pCLElBQUksQ0FBQ0ksSUFBSSxPQUFPO0lBQ2hCLE1BQU1nQixXQUFZLE1BQU1oQixHQUFHaUIsR0FBRyxDQUFDLGFBQWFGLEtBQUtHLFVBQVU7UUFHekNGLDBC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VUFBVSxDQUFDUjtJQUNwQyxNQUFPTyxPQUFRO1FBQ2IsTUFBTW5DLE1BQU1tQyxPQUFPRSxLQUFLO1FBQ3hCSCxNQUFNSSxJQUFJLENBQUNwRCxjQUFjYyxJQUFJTSxJQUFJO1FBQ2pDNkIsU0FBUyxNQUFNQSxPQUFPSSxRQUFRO0lBQ2hDO0lBRUEsSUFBSUwsTUFBTTFDLE1BQU0sS0FBSyxHQUFHO1FBQ3RCa0MsUUFBUUMsS0FBSyxDQUFDLGlDQUFpQzVCO1FBQy9DLE9BQU8wQixhQUFhLE9BQU9MO0lBQzdCO0lBRUEsTUFBTW9CLE9BQU8sSUFBSUMsS0FBS1AsT0FBTztRQUFFUSxNQUFNM0I7SUFBUztJQUU5QyxJQUFJVSxZQUFZO1FBQ2QsT0FBT2U7SUFDVDtJQUVBLE1BQU1HLE1BQU1DLElBQUlDLGVBQWUsQ0FBQ0w7SUFDaEMsTUFBTU0sSUFBSUMsU0FBU0MsYUFBYSxDQUFDO0lBQ2pDRixFQUFFRyxJQUFJLEdBQUdOO0lBQ1RHLEVBQUVJLFFBQVEsR0FBR3BDO0lBQ2JpQyxTQUFTSSxJQUFJLENBQUNDLFdBQVcsQ0FBQ047SUFDMUJBLEVBQUVPLEtBQUs7SUFDUE4sU0FBU0ksSUFBSSxDQUFDRyxXQUFXLENBQUNSO0lBQzFCRixJQUFJVyxlQUFlLENBQUNaO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvY2h1bmtTdG9yZS50cz9lYjdhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9wZW5EQiwgdHlwZSBJREJQRGF0YWJhc2UgfSBmcm9tICdpZGInO1xuXG5pbnRlcmZhY2UgQ2h1bmtSb3cge1xuICB0cmFuc2ZlcklkOiBzdHJpbmc7XG4gIGluZGV4OiBudW1iZXI7XG4gIGRhdGE6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zZmVyUm93IHtcbiAgdHJhbnNmZXJJZDogc3RyaW5nO1xuICBmaWxlTmFtZTogc3RyaW5nO1xuICBtaW1lVHlwZTogc3RyaW5nO1xuICBmaWxlVHlwZTogJ2ltYWdlJyB8ICdmaWxlJyB8ICdhdWRpbyc7XG4gIHNpemU6IG51bWJlcjtcbiAgdG90YWxDaHVua3M6IG51bWJlcjtcbiAgcmVjZWl2ZWRDaHVua3M6IG51bWJlcjtcbiAgdGV4dD86IHN0cmluZztcbn1cblxuY29uc3QgREJfTkFNRSA9ICdub3N0ci1wMnAtZmlsZXMnO1xuY29uc3QgREJfVkVSU0lPTiA9IDE7XG5cbmxldCBkYlByb21pc2U6IFByb21pc2U8SURCUERhdGFiYXNlPiB8IG51bGwgPSBudWxsO1xuXG5jb25zdCBnZXREYiA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuaW5kZXhlZERCKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFkYlByb21pc2UpIHtcbiAgICBkYlByb21pc2UgPSBvcGVuREIoREJfTkFNRSwgREJfVkVSU0lPTiwge1xuICAgICAgdXBncmFkZShkYikge1xuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ3RyYW5zZmVycycpKSB7XG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ3RyYW5zZmVycycsIHsga2V5UGF0aDogJ3RyYW5zZmVySWQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnY2h1bmtzJykpIHtcbiAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZSgnY2h1bmtzJywgeyBrZXlQYXRoOiBbJ3RyYW5zZmVySWQnLCAnaW5kZXgnXSB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGJQcm9taXNlO1xufTtcblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhiYXNlNjQ6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBiaW4gPSBhdG9iKGJhc2U2NCk7XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7IGkrKykgb3V0W2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbnN1cmVUcmFuc2ZlcihtZXRhOiBPbWl0PFRyYW5zZmVyUm93LCAncmVjZWl2ZWRDaHVua3MnPiAmIHsgcmVjZWl2ZWRDaHVua3M/OiBudW1iZXIgfSkge1xuICBjb25zdCBkYiA9IGF3YWl0IGdldERiKCk7XG4gIGlmICghZGIpIHJldHVybiBudWxsO1xuICBjb25zdCBleGlzdGluZyA9IChhd2FpdCBkYi5nZXQoJ3RyYW5zZmVycycsIG1ldGEudHJhbnNmZXJJZCkpIGFzIFRyYW5zZmVyUm93IHwgdW5kZWZpbmVkO1xuICBjb25zdCByb3c6IFRyYW5zZmVyUm93ID0ge1xuICAgIC4uLm1ldGEsXG4gICAgcmVjZWl2ZWRDaHVua3M6IGV4aXN0aW5nPy5yZWNlaXZlZENodW5rcyA/PyBtZXRhLnJlY2VpdmVkQ2h1bmtzID8/IDAsXG4gIH07XG4gIGF3YWl0IGRiLnB1dCgndHJhbnNmZXJzJywgcm93KTtcbiAgcmV0dXJuIHJvdztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0b3JlQ2h1bmsodHJhbnNmZXJJZDogc3RyaW5nLCBpbmRleDogbnVtYmVyLCB0b3RhbENodW5rczogbnVtYmVyLCBkYXRhOiBzdHJpbmcpIHtcbiAgY29uc3QgZGIgPSBhd2FpdCBnZXREYigpO1xuICBpZiAoIWRiKSByZXR1cm47XG4gIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oWydjaHVua3MnLCAndHJhbnNmZXJzJ10sICdyZWFkd3JpdGUnKTtcbiAgY29uc3Qga2V5ID0gW3RyYW5zZmVySWQsIGluZGV4XSBhcyBbc3RyaW5nLCBudW1iZXJdO1xuICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHR4Lm9iamVjdFN0b3JlKCdjaHVua3MnKS5nZXQoa2V5KTtcbiAgaWYgKCFleGlzdGluZykge1xuICAgIGF3YWl0IHR4Lm9iamVjdFN0b3JlKCdjaHVua3MnKS5wdXQoeyB0cmFuc2ZlcklkLCBpbmRleCwgZGF0YSB9IGFzIENodW5rUm93KTtcbiAgICBjb25zdCB0cmFuc2ZlciA9IChhd2FpdCB0eC5vYmplY3RTdG9yZSgndHJhbnNmZXJzJykuZ2V0KHRyYW5zZmVySWQpKSBhcyBUcmFuc2ZlclJvdyB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHJhbnNmZXIpIHtcbiAgICAgIHRyYW5zZmVyLnJlY2VpdmVkQ2h1bmtzID0gTWF0aC5taW4odHJhbnNmZXIudG90YWxDaHVua3MsIHRyYW5zZmVyLnJlY2VpdmVkQ2h1bmtzICsgMSk7XG4gICAgICBhd2FpdCB0eC5vYmplY3RTdG9yZSgndHJhbnNmZXJzJykucHV0KHRyYW5zZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdHgub2JqZWN0U3RvcmUoJ3RyYW5zZmVycycpLnB1dCh7XG4gICAgICAgIHRyYW5zZmVySWQsXG4gICAgICAgIGZpbGVOYW1lOiAnZmlsZScsXG4gICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgZmlsZVR5cGU6ICdmaWxlJyxcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgdG90YWxDaHVua3MsXG4gICAgICAgIHJlY2VpdmVkQ2h1bmtzOiAxLFxuICAgICAgfSBhcyBUcmFuc2ZlclJvdyk7XG4gICAgfVxuICB9XG4gIGF3YWl0IHR4LmRvbmU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc2Zlcih0cmFuc2ZlcklkOiBzdHJpbmcpIHtcbiAgY29uc3QgZGIgPSBhd2FpdCBnZXREYigpO1xuICBpZiAoIWRiKSByZXR1cm4gdW5kZWZpbmVkO1xuICByZXR1cm4gKGF3YWl0IGRiLmdldCgndHJhbnNmZXJzJywgdHJhbnNmZXJJZCkpIGFzIFRyYW5zZmVyUm93IHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNUcmFuc2ZlckNvbXBsZXRlKHRyYW5zZmVySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5pbmRleGVkREIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdHJhbnNmZXIgPSBhd2FpdCBnZXRUcmFuc2Zlcih0cmFuc2ZlcklkKTtcbiAgaWYgKCF0cmFuc2ZlcikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJhbnNmZXIudG90YWxDaHVua3MgPiAwICYmIHRyYW5zZmVyLnJlY2VpdmVkQ2h1bmtzID49IHRyYW5zZmVyLnRvdGFsQ2h1bmtzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRDaHVua2VkVHJhbnNmZXIoXG4gIHRyYW5zZmVySWQ6IHN0cmluZyxcbiAgZmFsbGJhY2tOYW1lPzogc3RyaW5nLFxuICBmYWxsYmFja01pbWU/OiBzdHJpbmcsXG4pOiBQcm9taXNlPHZvaWQ+O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkQ2h1bmtlZFRyYW5zZmVyKFxuICB0cmFuc2ZlcklkOiBzdHJpbmcsXG4gIGZhbGxiYWNrTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBmYWxsYmFja01pbWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgcmV0dXJuQmxvYjogdHJ1ZSxcbik6IFByb21pc2U8QmxvYiB8IG51bGw+O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkQ2h1bmtlZFRyYW5zZmVyKFxuICB0cmFuc2ZlcklkOiBzdHJpbmcsXG4gIGZhbGxiYWNrTmFtZT86IHN0cmluZyxcbiAgZmFsbGJhY2tNaW1lPzogc3RyaW5nLFxuICByZXR1cm5CbG9iID0gZmFsc2UsXG4pOiBQcm9taXNlPEJsb2IgfCBudWxsIHwgdm9pZD4ge1xuICBjb25zdCBkYiA9IGF3YWl0IGdldERiKCk7XG4gIGlmICghZGIpIHJldHVybiByZXR1cm5CbG9iID8gbnVsbCA6IHVuZGVmaW5lZDtcblxuICBjb25zdCB0cmFuc2ZlciA9IChhd2FpdCBkYi5nZXQoJ3RyYW5zZmVycycsIHRyYW5zZmVySWQpKSBhcyBUcmFuc2ZlclJvdyB8IHVuZGVmaW5lZDtcbiAgaWYgKCF0cmFuc2Zlcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1RyYW5zZmVyIG5vdCBmb3VuZDonLCB0cmFuc2ZlcklkKTtcbiAgICByZXR1cm4gcmV0dXJuQmxvYiA/IG51bGwgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBmaWxlTmFtZSA9IGZhbGxiYWNrTmFtZSB8fCB0cmFuc2Zlci5maWxlTmFtZSB8fCAnZmlsZSc7XG4gIGNvbnN0IG1pbWVUeXBlID0gZmFsbGJhY2tNaW1lIHx8IHRyYW5zZmVyLm1pbWVUeXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuXG4gIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RyYW5zZmVySWQsIDBdLCBbdHJhbnNmZXJJZCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJdKTtcbiAgY29uc3Qgc3RvcmUgPSBkYi50cmFuc2FjdGlvbignY2h1bmtzJywgJ3JlYWRvbmx5Jykub2JqZWN0U3RvcmUoJ2NodW5rcycpO1xuXG4gIGNvbnN0IHBhcnRzOiBVaW50OEFycmF5W10gPSBbXTtcbiAgbGV0IGN1cnNvciA9IGF3YWl0IHN0b3JlLm9wZW5DdXJzb3IocmFuZ2UpO1xuICB3aGlsZSAoY3Vyc29yKSB7XG4gICAgY29uc3Qgcm93ID0gY3Vyc29yLnZhbHVlIGFzIENodW5rUm93O1xuICAgIHBhcnRzLnB1c2goYmFzZTY0VG9CeXRlcyhyb3cuZGF0YSkpO1xuICAgIGN1cnNvciA9IGF3YWl0IGN1cnNvci5jb250aW51ZSgpO1xuICB9XG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIGNodW5rcyBmb3VuZCBmb3IgdHJhbnNmZXI6JywgdHJhbnNmZXJJZCk7XG4gICAgcmV0dXJuIHJldHVybkJsb2IgPyBudWxsIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKHBhcnRzLCB7IHR5cGU6IG1pbWVUeXBlIH0pO1xuXG4gIGlmIChyZXR1cm5CbG9iKSB7XG4gICAgcmV0dXJuIGJsb2I7XG4gIH1cblxuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhLmhyZWYgPSB1cmw7XG4gIGEuZG93bmxvYWQgPSBmaWxlTmFtZTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgYS5jbGljaygpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG59XG5cbiJdLCJuYW1lcyI6WyJvcGVuREIiLCJEQl9OQU1FIiwiREJfVkVSU0lPTiIsImRiUHJvbWlzZSIsImdldERiIiwid2luZG93IiwiaW5kZXhlZERCIiwidXBncmFkZSIsImRiIiwib2JqZWN0U3RvcmVOYW1lcyIsImNvbnRhaW5zIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJrZXlQYXRoIiwiYmFzZTY0VG9CeXRlcyIsImJhc2U2NCIsImJpbiIsImF0b2IiLCJvdXQiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiaSIsImNoYXJDb2RlQXQiLCJlbnN1cmVUcmFuc2ZlciIsIm1ldGEiLCJleGlzdGluZyIsImdldCIsInRyYW5zZmVySWQiLCJyb3ciLCJyZWNlaXZlZENodW5rcyIsInB1dCIsInN0b3JlQ2h1bmsiLCJpbmRleCIsInRvdGFsQ2h1bmtzIiwiZGF0YSIsInR4IiwidHJhbnNhY3Rpb24iLCJrZXkiLCJvYmplY3RTdG9yZSIsInRyYW5zZmVyIiwiTWF0aCIsIm1pbiIsImZpbGVOYW1lIiwibWltZVR5cGUiLCJmaWxlVHlwZSIsInNpemUiLCJkb25lIiwiZ2V0VHJhbnNmZXIiLCJ1bmRlZmluZWQiLCJpc1RyYW5zZmVyQ29tcGxldGUiLCJkb3dubG9hZENodW5rZWRUcmFuc2ZlciIsImZhbGxiYWNrTmFtZSIsImZhbGxiYWNrTWltZSIsInJldHVybkJsb2IiLCJjb25zb2xlIiwiZXJyb3IiLCJyYW5nZSIsIklEQktleVJhbmdlIiwiYm91bmQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwic3RvcmUiLCJwYXJ0cyIsImN1cnNvciIsIm9wZW5DdXJzb3IiLCJ2YWx1ZSIsInB1c2giLCJjb250aW51ZSIsImJsb2IiLCJCbG9iIiwidHlwZSIsInVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZUNoaWxkIiwicmV2b2tlT2JqZWN0VVJMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/chunkStore.ts\n"));

/***/ })

});