"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/store.ts":
/*!**************************!*\
  !*** ./src/lib/store.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addChannel: function() { return /* binding */ addChannel; },\n/* harmony export */   addChannelMessage: function() { return /* binding */ addChannelMessage; },\n/* harmony export */   addContact: function() { return /* binding */ addContact; },\n/* harmony export */   addMessage: function() { return /* binding */ addMessage; },\n/* harmony export */   getChannelMessages: function() { return /* binding */ getChannelMessages; },\n/* harmony export */   getMessages: function() { return /* binding */ getMessages; },\n/* harmony export */   loadChannels: function() { return /* binding */ loadChannels; },\n/* harmony export */   loadContacts: function() { return /* binding */ loadContacts; },\n/* harmony export */   removeContact: function() { return /* binding */ removeContact; },\n/* harmony export */   setActiveChat: function() { return /* binding */ setActiveChat; },\n/* harmony export */   setLoggedIn: function() { return /* binding */ setLoggedIn; },\n/* harmony export */   toggleSidebar: function() { return /* binding */ toggleSidebar; },\n/* harmony export */   updateContactProfile: function() { return /* binding */ updateContactProfile; },\n/* harmony export */   useAppState: function() { return /* binding */ useAppState; },\n/* harmony export */   useRelayStatuses: function() { return /* binding */ useRelayStatuses; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _nostr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nostr */ \"(app-pages-browser)/./src/lib/nostr.ts\");\n\n\nlet state = {\n    contacts: [],\n    channels: [],\n    messages: new Map(),\n    channelMessages: new Map(),\n    activeChat: null,\n    isLoggedIn: false,\n    showSidebar: true\n};\nconst listeners = new Set();\nfunction notify() {\n    listeners.forEach((l)=>l());\n}\nfunction getSnapshot() {\n    return state;\n}\nfunction subscribe(listener) {\n    listeners.add(listener);\n    return ()=>listeners.delete(listener);\n}\nfunction useAppState() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot);\n}\nfunction setActiveChat(pubkey) {\n    state = {\n        ...state,\n        activeChat: pubkey\n    };\n    if (pubkey && !pubkey.startsWith(\"channel:\")) {\n        const contacts = state.contacts.map((c)=>c.pubkey === pubkey ? {\n                ...c,\n                unread: 0\n            } : c);\n        state = {\n            ...state,\n            contacts\n        };\n    }\n    notify();\n}\nfunction setLoggedIn(value) {\n    state = {\n        ...state,\n        isLoggedIn: value\n    };\n    notify();\n}\nfunction toggleSidebar() {\n    state = {\n        ...state,\n        showSidebar: !state.showSidebar\n    };\n    notify();\n}\nfunction addContact(pubkey, name) {\n    if (state.contacts.find((c)=>c.pubkey === pubkey)) return;\n    const contact = {\n        pubkey,\n        name: name || _nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.shortenKey(pubkey),\n        unread: 0\n    };\n    state = {\n        ...state,\n        contacts: [\n            ...state.contacts,\n            contact\n        ]\n    };\n    saveContacts();\n    _nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.requestProfile(pubkey);\n    notify();\n}\nfunction removeContact(pubkey) {\n    state = {\n        ...state,\n        contacts: state.contacts.filter((c)=>c.pubkey !== pubkey),\n        activeChat: state.activeChat === pubkey ? null : state.activeChat\n    };\n    saveContacts();\n    notify();\n}\nfunction updateContactProfile(pubkey, name, picture, about) {\n    state = {\n        ...state,\n        contacts: state.contacts.map((c)=>c.pubkey === pubkey ? {\n                ...c,\n                name: name || c.name,\n                picture,\n                about\n            } : c)\n    };\n    notify();\n}\nfunction getLastMessagePreview(msg) {\n    var _msg_attachment;\n    if (msg.msgType === \"image\") return \"\\uD83D\\uDDBCï¸ Photo\";\n    if (msg.msgType === \"file\") return \"\\uD83D\\uDCCE \".concat(((_msg_attachment = msg.attachment) === null || _msg_attachment === void 0 ? void 0 : _msg_attachment.name) || \"File\");\n    return msg.content;\n}\nfunction addMessage(msg) {\n    const otherPubkey = msg.from === _nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.publicKey ? msg.to : msg.from;\n    const existing = state.messages.get(otherPubkey) || [];\n    if (existing.find((m)=>m.id === msg.id)) return;\n    const updated = [\n        ...existing,\n        msg\n    ].sort((a, b)=>a.timestamp - b.timestamp);\n    const newMessages = new Map(state.messages);\n    newMessages.set(otherPubkey, updated);\n    const preview = getLastMessagePreview(msg);\n    const contacts = state.contacts.map((c)=>{\n        if (c.pubkey === otherPubkey) {\n            return {\n                ...c,\n                lastMessage: preview,\n                lastMessageTime: msg.timestamp,\n                unread: state.activeChat === otherPubkey ? 0 : (c.unread || 0) + (msg.from !== _nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.publicKey ? 1 : 0)\n            };\n        }\n        return c;\n    });\n    const hasContact = contacts.find((c)=>c.pubkey === otherPubkey);\n    if (!hasContact && msg.from !== _nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.publicKey) {\n        contacts.push({\n            pubkey: otherPubkey,\n            name: _nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.shortenKey(otherPubkey),\n            lastMessage: preview,\n            lastMessageTime: msg.timestamp,\n            unread: state.activeChat === otherPubkey ? 0 : 1\n        });\n        _nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.requestProfile(otherPubkey);\n        saveContacts();\n    }\n    state = {\n        ...state,\n        messages: newMessages,\n        contacts\n    };\n    notify();\n}\nfunction addChannel(channel) {\n    if (state.channels.find((c)=>c.id === channel.id)) return;\n    state = {\n        ...state,\n        channels: [\n            channel,\n            ...state.channels\n        ]\n    };\n    saveChannels();\n    _nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.setChannels(state.channels.map((c)=>c.id));\n    notify();\n}\nfunction addChannelMessage(msg) {\n    const channelId = msg.channelId;\n    if (!channelId) return;\n    const existing = state.channelMessages.get(channelId) || [];\n    if (existing.find((m)=>m.id === msg.id)) return;\n    const updated = [\n        ...existing,\n        msg\n    ].sort((a, b)=>a.timestamp - b.timestamp);\n    const map = new Map(state.channelMessages);\n    map.set(channelId, updated);\n    state = {\n        ...state,\n        channelMessages: map\n    };\n    notify();\n}\nfunction getChannelMessages(channelId) {\n    return state.channelMessages.get(channelId) || [];\n}\nfunction getMessages(pubkey) {\n    return state.messages.get(pubkey) || [];\n}\nfunction saveContacts() {\n    const data = state.contacts.map((c)=>({\n            pubkey: c.pubkey,\n            name: c.name\n        }));\n    localStorage.setItem(\"nostr_contacts\", JSON.stringify(data));\n}\nfunction saveChannels() {\n    localStorage.setItem(\"nostr_channels\", JSON.stringify(state.channels));\n}\nfunction loadContacts() {\n    try {\n        const raw = localStorage.getItem(\"nostr_contacts\");\n        if (raw) {\n            const data = JSON.parse(raw);\n            const contacts = data.map((d)=>({\n                    pubkey: d.pubkey,\n                    name: d.name || _nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.shortenKey(d.pubkey),\n                    unread: 0\n                }));\n            state = {\n                ...state,\n                contacts\n            };\n            notify();\n            contacts.forEach((c)=>_nostr__WEBPACK_IMPORTED_MODULE_1__.nostrClient.requestProfile(c.pubkey));\n        }\n    } catch (e) {\n    // ignore\n    }\n}\nfunction loadChannels() {\n// No-op. Channels are now added dynamically.\n}\nfunction useRelayStatuses() {\n    const [, setTick] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const refresh = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>setTick((t)=>t + 1), []);\n    return {\n        refresh\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b0JBQy9DSSxRQUFRO2dCQUNWO1lBQ0F6QixRQUFRO2dCQUFFLEdBQUdBLEtBQUs7Z0JBQUVDO1lBQVM7WUFDN0JVO1lBQ0FWLFNBQVNXLE9BQU8sQ0FBQ1ksQ0FBQUEsSUFBS3pCLCtDQUFXQSxDQUFDb0MsY0FBYyxDQUFDWCxFQUFFSCxNQUFNO1FBQzNEO0lBQ0YsRUFBRSxVQUFNO0lBQ04sU0FBUztJQUNYO0FBQ0Y7QUFFTyxTQUFTZ0U7QUFDZCw2Q0FBNkM7QUFDL0M7QUFFTyxTQUFTQztJQUNkLE1BQU0sR0FBR0MsUUFBUSxHQUFHM0YsK0NBQVFBLENBQUM7SUFDN0IsTUFBTTRGLFVBQVUzRixrREFBV0EsQ0FBQyxJQUFNMEYsUUFBUUUsQ0FBQUEsSUFBS0EsSUFBSSxJQUFJLEVBQUU7SUFDekQsT0FBTztRQUFFRDtJQUFRO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3RvcmUudHM/YWQzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbm9zdHJDbGllbnQsIHR5cGUgQ29udGFjdCwgdHlwZSBEaXJlY3RNZXNzYWdlLCB0eXBlIENoYW5uZWwgfSBmcm9tICcuL25vc3RyJztcblxuaW50ZXJmYWNlIEFwcFN0YXRlIHtcbiAgY29udGFjdHM6IENvbnRhY3RbXTtcbiAgY2hhbm5lbHM6IENoYW5uZWxbXTtcbiAgbWVzc2FnZXM6IE1hcDxzdHJpbmcsIERpcmVjdE1lc3NhZ2VbXT47XG4gIGNoYW5uZWxNZXNzYWdlczogTWFwPHN0cmluZywgRGlyZWN0TWVzc2FnZVtdPjtcbiAgYWN0aXZlQ2hhdDogc3RyaW5nIHwgbnVsbDtcbiAgaXNMb2dnZWRJbjogYm9vbGVhbjtcbiAgc2hvd1NpZGViYXI6IGJvb2xlYW47XG59XG5cbmxldCBzdGF0ZTogQXBwU3RhdGUgPSB7XG4gIGNvbnRhY3RzOiBbXSxcbiAgY2hhbm5lbHM6IFtdLFxuICBtZXNzYWdlczogbmV3IE1hcCgpLFxuICBjaGFubmVsTWVzc2FnZXM6IG5ldyBNYXAoKSxcbiAgYWN0aXZlQ2hhdDogbnVsbCxcbiAgaXNMb2dnZWRJbjogZmFsc2UsXG4gIHNob3dTaWRlYmFyOiB0cnVlLFxufTtcblxuY29uc3QgbGlzdGVuZXJzID0gbmV3IFNldDwoKSA9PiB2b2lkPigpO1xuXG5mdW5jdGlvbiBub3RpZnkoKSB7XG4gIGxpc3RlbmVycy5mb3JFYWNoKGwgPT4gbCgpKTtcbn1cblxuZnVuY3Rpb24gZ2V0U25hcHNob3QoKSB7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyOiAoKSA9PiB2b2lkKSB7XG4gIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcHBTdGF0ZSgpIHtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QWN0aXZlQ2hhdChwdWJrZXk6IHN0cmluZyB8IG51bGwpIHtcbiAgc3RhdGUgPSB7IC4uLnN0YXRlLCBhY3RpdmVDaGF0OiBwdWJrZXkgfTtcbiAgaWYgKHB1YmtleSAmJiAhcHVia2V5LnN0YXJ0c1dpdGgoJ2NoYW5uZWw6JykpIHtcbiAgICBjb25zdCBjb250YWN0cyA9IHN0YXRlLmNvbnRhY3RzLm1hcChjID0+XG4gICAgICBjLnB1YmtleSA9PT0gcHVia2V5ID8geyAuLi5jLCB1bnJlYWQ6IDAgfSA6IGNcbiAgICApO1xuICAgIHN0YXRlID0geyAuLi5zdGF0ZSwgY29udGFjdHMgfTtcbiAgfVxuICBub3RpZnkoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExvZ2dlZEluKHZhbHVlOiBib29sZWFuKSB7XG4gIHN0YXRlID0geyAuLi5zdGF0ZSwgaXNMb2dnZWRJbjogdmFsdWUgfTtcbiAgbm90aWZ5KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVTaWRlYmFyKCkge1xuICBzdGF0ZSA9IHsgLi4uc3RhdGUsIHNob3dTaWRlYmFyOiAhc3RhdGUuc2hvd1NpZGViYXIgfTtcbiAgbm90aWZ5KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb250YWN0KHB1YmtleTogc3RyaW5nLCBuYW1lPzogc3RyaW5nKSB7XG4gIGlmIChzdGF0ZS5jb250YWN0cy5maW5kKGMgPT4gYy5wdWJrZXkgPT09IHB1YmtleSkpIHJldHVybjtcbiAgY29uc3QgY29udGFjdDogQ29udGFjdCA9IHtcbiAgICBwdWJrZXksXG4gICAgbmFtZTogbmFtZSB8fCBub3N0ckNsaWVudC5zaG9ydGVuS2V5KHB1YmtleSksXG4gICAgdW5yZWFkOiAwLFxuICB9O1xuICBzdGF0ZSA9IHsgLi4uc3RhdGUsIGNvbnRhY3RzOiBbLi4uc3RhdGUuY29udGFjdHMsIGNvbnRhY3RdIH07XG4gIHNhdmVDb250YWN0cygpO1xuICBub3N0ckNsaWVudC5yZXF1ZXN0UHJvZmlsZShwdWJrZXkpO1xuICBub3RpZnkoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNvbnRhY3QocHVia2V5OiBzdHJpbmcpIHtcbiAgc3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgY29udGFjdHM6IHN0YXRlLmNvbnRhY3RzLmZpbHRlcihjID0+IGMucHVia2V5ICE9PSBwdWJrZXkpLFxuICAgIGFjdGl2ZUNoYXQ6IHN0YXRlLmFjdGl2ZUNoYXQgPT09IHB1YmtleSA/IG51bGwgOiBzdGF0ZS5hY3RpdmVDaGF0LFxuICB9O1xuICBzYXZlQ29udGFjdHMoKTtcbiAgbm90aWZ5KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDb250YWN0UHJvZmlsZShwdWJrZXk6IHN0cmluZywgbmFtZT86IHN0cmluZywgcGljdHVyZT86IHN0cmluZywgYWJvdXQ/OiBzdHJpbmcpIHtcbiAgc3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgY29udGFjdHM6IHN0YXRlLmNvbnRhY3RzLm1hcChjID0+XG4gICAgICBjLnB1YmtleSA9PT0gcHVia2V5ID8geyAuLi5jLCBuYW1lOiBuYW1lIHx8IGMubmFtZSwgcGljdHVyZSwgYWJvdXQgfSA6IGNcbiAgICApLFxuICB9O1xuICBub3RpZnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFzdE1lc3NhZ2VQcmV2aWV3KG1zZzogRGlyZWN0TWVzc2FnZSk6IHN0cmluZyB7XG4gIGlmIChtc2cubXNnVHlwZSA9PT0gJ2ltYWdlJykgcmV0dXJuICfwn5a877iPIFBob3RvJztcbiAgaWYgKG1zZy5tc2dUeXBlID09PSAnZmlsZScpIHJldHVybiBg8J+TjiAke21zZy5hdHRhY2htZW50Py5uYW1lIHx8ICdGaWxlJ31gO1xuICByZXR1cm4gbXNnLmNvbnRlbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRNZXNzYWdlKG1zZzogRGlyZWN0TWVzc2FnZSkge1xuICBjb25zdCBvdGhlclB1YmtleSA9IG1zZy5mcm9tID09PSBub3N0ckNsaWVudC5wdWJsaWNLZXkgPyBtc2cudG8gOiBtc2cuZnJvbTtcbiAgY29uc3QgZXhpc3RpbmcgPSBzdGF0ZS5tZXNzYWdlcy5nZXQob3RoZXJQdWJrZXkpIHx8IFtdO1xuXG4gIGlmIChleGlzdGluZy5maW5kKG0gPT4gbS5pZCA9PT0gbXNnLmlkKSkgcmV0dXJuO1xuXG4gIGNvbnN0IHVwZGF0ZWQgPSBbLi4uZXhpc3RpbmcsIG1zZ10uc29ydCgoYSwgYikgPT4gYS50aW1lc3RhbXAgLSBiLnRpbWVzdGFtcCk7XG4gIGNvbnN0IG5ld01lc3NhZ2VzID0gbmV3IE1hcChzdGF0ZS5tZXNzYWdlcyk7XG4gIG5ld01lc3NhZ2VzLnNldChvdGhlclB1YmtleSwgdXBkYXRlZCk7XG5cbiAgY29uc3QgcHJldmlldyA9IGdldExhc3RNZXNzYWdlUHJldmlldyhtc2cpO1xuXG4gIGNvbnN0IGNvbnRhY3RzID0gc3RhdGUuY29udGFjdHMubWFwKGMgPT4ge1xuICAgIGlmIChjLnB1YmtleSA9PT0gb3RoZXJQdWJrZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmMsXG4gICAgICAgIGxhc3RNZXNzYWdlOiBwcmV2aWV3LFxuICAgICAgICBsYXN0TWVzc2FnZVRpbWU6IG1zZy50aW1lc3RhbXAsXG4gICAgICAgIHVucmVhZDogc3RhdGUuYWN0aXZlQ2hhdCA9PT0gb3RoZXJQdWJrZXkgPyAwIDogKGMudW5yZWFkIHx8IDApICsgKG1zZy5mcm9tICE9PSBub3N0ckNsaWVudC5wdWJsaWNLZXkgPyAxIDogMCksXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSk7XG5cbiAgY29uc3QgaGFzQ29udGFjdCA9IGNvbnRhY3RzLmZpbmQoYyA9PiBjLnB1YmtleSA9PT0gb3RoZXJQdWJrZXkpO1xuICBpZiAoIWhhc0NvbnRhY3QgJiYgbXNnLmZyb20gIT09IG5vc3RyQ2xpZW50LnB1YmxpY0tleSkge1xuICAgIGNvbnRhY3RzLnB1c2goe1xuICAgICAgcHVia2V5OiBvdGhlclB1YmtleSxcbiAgICAgIG5hbWU6IG5vc3RyQ2xpZW50LnNob3J0ZW5LZXkob3RoZXJQdWJrZXkpLFxuICAgICAgbGFzdE1lc3NhZ2U6IHByZXZpZXcsXG4gICAgICBsYXN0TWVzc2FnZVRpbWU6IG1zZy50aW1lc3RhbXAsXG4gICAgICB1bnJlYWQ6IHN0YXRlLmFjdGl2ZUNoYXQgPT09IG90aGVyUHVia2V5ID8gMCA6IDEsXG4gICAgfSk7XG4gICAgbm9zdHJDbGllbnQucmVxdWVzdFByb2ZpbGUob3RoZXJQdWJrZXkpO1xuICAgIHNhdmVDb250YWN0cygpO1xuICB9XG5cbiAgc3RhdGUgPSB7IC4uLnN0YXRlLCBtZXNzYWdlczogbmV3TWVzc2FnZXMsIGNvbnRhY3RzIH07XG4gIG5vdGlmeSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2hhbm5lbChjaGFubmVsOiBDaGFubmVsKSB7XG4gIGlmIChzdGF0ZS5jaGFubmVscy5maW5kKGMgPT4gYy5pZCA9PT0gY2hhbm5lbC5pZCkpIHJldHVybjtcbiAgc3RhdGUgPSB7IC4uLnN0YXRlLCBjaGFubmVsczogW2NoYW5uZWwsIC4uLnN0YXRlLmNoYW5uZWxzXSB9O1xuICBzYXZlQ2hhbm5lbHMoKTtcbiAgbm9zdHJDbGllbnQuc2V0Q2hhbm5lbHMoc3RhdGUuY2hhbm5lbHMubWFwKGMgPT4gYy5pZCkpO1xuICBub3RpZnkoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENoYW5uZWxNZXNzYWdlKG1zZzogRGlyZWN0TWVzc2FnZSkge1xuICBjb25zdCBjaGFubmVsSWQgPSBtc2cuY2hhbm5lbElkO1xuICBpZiAoIWNoYW5uZWxJZCkgcmV0dXJuO1xuICBjb25zdCBleGlzdGluZyA9IHN0YXRlLmNoYW5uZWxNZXNzYWdlcy5nZXQoY2hhbm5lbElkKSB8fCBbXTtcbiAgaWYgKGV4aXN0aW5nLmZpbmQobSA9PiBtLmlkID09PSBtc2cuaWQpKSByZXR1cm47XG4gIGNvbnN0IHVwZGF0ZWQgPSBbLi4uZXhpc3RpbmcsIG1zZ10uc29ydCgoYSwgYikgPT4gYS50aW1lc3RhbXAgLSBiLnRpbWVzdGFtcCk7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoc3RhdGUuY2hhbm5lbE1lc3NhZ2VzKTtcbiAgbWFwLnNldChjaGFubmVsSWQsIHVwZGF0ZWQpO1xuICBzdGF0ZSA9IHsgLi4uc3RhdGUsIGNoYW5uZWxNZXNzYWdlczogbWFwIH07XG4gIG5vdGlmeSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbm5lbE1lc3NhZ2VzKGNoYW5uZWxJZDogc3RyaW5nKTogRGlyZWN0TWVzc2FnZVtdIHtcbiAgcmV0dXJuIHN0YXRlLmNoYW5uZWxNZXNzYWdlcy5nZXQoY2hhbm5lbElkKSB8fCBbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc3NhZ2VzKHB1YmtleTogc3RyaW5nKTogRGlyZWN0TWVzc2FnZVtdIHtcbiAgcmV0dXJuIHN0YXRlLm1lc3NhZ2VzLmdldChwdWJrZXkpIHx8IFtdO1xufVxuXG5mdW5jdGlvbiBzYXZlQ29udGFjdHMoKSB7XG4gIGNvbnN0IGRhdGEgPSBzdGF0ZS5jb250YWN0cy5tYXAoYyA9PiAoeyBwdWJrZXk6IGMucHVia2V5LCBuYW1lOiBjLm5hbWUgfSkpO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbm9zdHJfY29udGFjdHMnLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVDaGFubmVscygpIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ25vc3RyX2NoYW5uZWxzJywgSlNPTi5zdHJpbmdpZnkoc3RhdGUuY2hhbm5lbHMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRDb250YWN0cygpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbm9zdHJfY29udGFjdHMnKTtcbiAgICBpZiAocmF3KSB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyYXcpIGFzIHsgcHVia2V5OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmcgfVtdO1xuICAgICAgY29uc3QgY29udGFjdHM6IENvbnRhY3RbXSA9IGRhdGEubWFwKGQgPT4gKHtcbiAgICAgICAgcHVia2V5OiBkLnB1YmtleSxcbiAgICAgICAgbmFtZTogZC5uYW1lIHx8IG5vc3RyQ2xpZW50LnNob3J0ZW5LZXkoZC5wdWJrZXkpLFxuICAgICAgICB1bnJlYWQ6IDAsXG4gICAgICB9KSk7XG4gICAgICBzdGF0ZSA9IHsgLi4uc3RhdGUsIGNvbnRhY3RzIH07XG4gICAgICBub3RpZnkoKTtcbiAgICAgIGNvbnRhY3RzLmZvckVhY2goYyA9PiBub3N0ckNsaWVudC5yZXF1ZXN0UHJvZmlsZShjLnB1YmtleSkpO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gaWdub3JlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRDaGFubmVscygpIHtcbiAgLy8gTm8tb3AuIENoYW5uZWxzIGFyZSBub3cgYWRkZWQgZHluYW1pY2FsbHkuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWxheVN0YXR1c2VzKCkge1xuICBjb25zdCBbLCBzZXRUaWNrXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCByZWZyZXNoID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0VGljayh0ID0+IHQgKyAxKSwgW10pO1xuICByZXR1cm4geyByZWZyZXNoIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwibm9zdHJDbGllbnQiLCJzdGF0ZSIsImNvbnRhY3RzIiwiY2hhbm5lbHMiLCJtZXNzYWdlcyIsIk1hcCIsImNoYW5uZWxNZXNzYWdlcyIsImFjdGl2ZUNoYXQiLCJpc0xvZ2dlZEluIiwic2hvd1NpZGViYXIiLCJsaXN0ZW5lcnMiLCJTZXQiLCJub3RpZnkiLCJmb3JFYWNoIiwibCIsImdldFNuYXBzaG90Iiwic3Vic2NyaWJlIiwibGlzdGVuZXIiLCJhZGQiLCJkZWxldGUiLCJ1c2VBcHBTdGF0ZSIsInNldEFjdGl2ZUNoYXQiLCJwdWJrZXkiLCJzdGFydHNXaXRoIiwibWFwIiwiYyIsInVucmVhZCIsInNldExvZ2dlZEluIiwidmFsdWUiLCJ0b2dnbGVTaWRlYmFyIiwiYWRkQ29udGFjdCIsIm5hbWUiLCJmaW5kIiwiY29udGFjdCIsInNob3J0ZW5LZXkiLCJzYXZlQ29udGFjdHMiLCJyZXF1ZXN0UHJvZmlsZSIsInJlbW92ZUNvbnRhY3QiLCJmaWx0ZXIiLCJ1cGRhdGVDb250YWN0UHJvZmlsZSIsInBpY3R1cmUiLCJhYm91dCIsImdldExhc3RNZXNzYWdlUHJldmlldyIsIm1zZyIsIm1zZ1R5cGUiLCJhdHRhY2htZW50IiwiY29udGVudCIsImFkZE1lc3NhZ2UiLCJvdGhlclB1YmtleSIsImZyb20iLCJwdWJsaWNLZXkiLCJ0byIsImV4aXN0aW5nIiwiZ2V0IiwibSIsImlkIiwidXBkYXRlZCIsInNvcnQiLCJhIiwiYiIsInRpbWVzdGFtcCIsIm5ld01lc3NhZ2VzIiwic2V0IiwicHJldmlldyIsImxhc3RNZXNzYWdlIiwibGFzdE1lc3NhZ2VUaW1lIiwiaGFzQ29udGFjdCIsInB1c2giLCJhZGRDaGFubmVsIiwiY2hhbm5lbCIsInNhdmVDaGFubmVscyIsInNldENoYW5uZWxzIiwiYWRkQ2hhbm5lbE1lc3NhZ2UiLCJjaGFubmVsSWQiLCJnZXRDaGFubmVsTWVzc2FnZXMiLCJnZXRNZXNzYWdlcyIsImRhdGEiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImxvYWRDb250YWN0cyIsInJhdyIsImdldEl0ZW0iLCJwYXJzZSIsImQiLCJsb2FkQ2hhbm5lbHMiLCJ1c2VSZWxheVN0YXR1c2VzIiwic2V0VGljayIsInJlZnJlc2giLCJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/store.ts\n"));

/***/ })

});