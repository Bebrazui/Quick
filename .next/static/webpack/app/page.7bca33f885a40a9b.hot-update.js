"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/nostr.ts":
/*!**************************!*\
  !*** ./src/lib/nostr.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_RELAYS: function() { return /* binding */ DEFAULT_RELAYS; },\n/* harmony export */   nostrClient: function() { return /* binding */ nostrClient; }\n/* harmony export */ });\n/* harmony import */ var nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools/pure */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/pure.js\");\n/* harmony import */ var nostr_tools_nip04__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nostr-tools/nip04 */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/nip04.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _chunkStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunkStore */ \"(app-pages-browser)/./src/lib/chunkStore.ts\");\n\n\n\n\nconst DEFAULT_RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://nos.lol\",\n    \"wss://relay.snort.social\",\n    \"wss://relay.primal.net\",\n    \"wss://purplepag.es\",\n    \"wss://nostr.mom\",\n    \"wss://relay.nostr.bg\"\n];\nclass NostrClient {\n    get publicKey() {\n        return this._pk;\n    }\n    get privateKeyHex() {\n        return this._sk ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(this._sk) : \"\";\n    }\n    get relays() {\n        return [\n            ...this._relays\n        ];\n    }\n    get channels() {\n        return [\n            ...this._channels\n        ];\n    }\n    get sk() {\n        return this._sk;\n    }\n    getRelayStatus(relay) {\n        return this.relayStatus.get(relay) || \"disconnected\";\n    }\n    get connectedRelayCount() {\n        let c = 0;\n        this.relayStatus.forEach((s)=>{\n            if (s === \"connected\") {\n                c++;\n            }\n        });\n        return c;\n    }\n    generateKeys() {\n        const sk = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n        const pk = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(sk);\n        return {\n            privateKey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(sk),\n            publicKey: pk\n        };\n    }\n    login(privateKeyHex) {\n        const sk = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(privateKeyHex);\n        const pk = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(sk);\n        this._sk = sk;\n        this._pk = pk;\n        this._stopped = false;\n        localStorage.setItem(\"nostr_sk\", privateKeyHex);\n        return pk;\n    }\n    logout() {\n        this._stopped = true;\n        this.disconnectAll();\n        this._sk = null;\n        this._pk = \"\";\n        localStorage.removeItem(\"nostr_sk\");\n        localStorage.removeItem(\"nostr_contacts\");\n    }\n    tryAutoLogin() {\n        const sk = localStorage.getItem(\"nostr_sk\");\n        if ((sk === null || sk === void 0 ? void 0 : sk.length) === 64) {\n            try {\n                this.login(sk);\n                return true;\n            } catch (e) {\n                localStorage.removeItem(\"nostr_sk\");\n            }\n        }\n        return false;\n    }\n    onMessage(cb) {\n        this.messageCallbacks.add(cb);\n        return ()=>{\n            this.messageCallbacks.delete(cb);\n        };\n    }\n    onChannel(cb) {\n        this.channelCallbacks.add(cb);\n        return ()=>{\n            this.channelCallbacks.delete(cb);\n        };\n    }\n    onChannelMessage(cb) {\n        this.channelMessageCallbacks.add(cb);\n        return ()=>{\n            this.channelMessageCallbacks.delete(cb);\n        };\n    }\n    onProfile(cb) {\n        this.profileCallbacks.add(cb);\n        return ()=>{\n            this.profileCallbacks.delete(cb);\n        };\n    }\n    onConnection(cb) {\n        this.connectionCallbacks.add(cb);\n        return ()=>{\n            this.connectionCallbacks.delete(cb);\n        };\n    }\n    onSignal(cb) {\n        this.signalCallbacks.add(cb);\n        return ()=>{\n            this.signalCallbacks.delete(cb);\n        };\n    }\n    async connectToRelays() {\n        for (const r of this._relays)this.connectToRelay(r);\n    }\n    setChannels(channelIds) {\n        this._channels = [\n            ...new Set(channelIds.filter(Boolean))\n        ];\n        for (const [relay, ws] of this.sockets){\n            if (ws.readyState === WebSocket.OPEN) this.subscribeToChannels(relay);\n        }\n    }\n    connectToRelay(url) {\n        if (this._stopped) return;\n        if (this.sockets.has(url)) {\n            const e = this.sockets.get(url);\n            if (e.readyState === WebSocket.OPEN || e.readyState === WebSocket.CONNECTING) return;\n        }\n        this.relayStatus.set(url, \"connecting\");\n        this.connectionCallbacks.forEach((cb)=>cb(url, \"disconnected\"));\n        try {\n            const ws = new WebSocket(url);\n            const ct = setTimeout(()=>{\n                if (ws.readyState !== WebSocket.OPEN) ws.close();\n            }, 8000);\n            this.sockets.set(url, ws);\n            ws.onopen = ()=>{\n                clearTimeout(ct);\n                this.reconnectAttempts.set(url, 0);\n                this.relayStatus.set(url, \"connected\");\n                this.connectionCallbacks.forEach((cb)=>cb(url, \"connected\"));\n                this.subscribeToMessages(url);\n            };\n            ws.onclose = ()=>{\n                clearTimeout(ct);\n                this.relayStatus.set(url, \"disconnected\");\n                this.connectionCallbacks.forEach((cb)=>cb(url, \"disconnected\"));\n                this.sockets.delete(url);\n                this.scheduleReconnect(url);\n            };\n            ws.onerror = ()=>{\n                this.relayStatus.set(url, \"error\");\n                this.connectionCallbacks.forEach((cb)=>cb(url, \"error\"));\n            };\n            ws.onmessage = (e)=>{\n                try {\n                    this.handleRelayMessage(JSON.parse(e.data));\n                } catch (e) {}\n            };\n        } catch (e) {\n            this.relayStatus.set(url, \"error\");\n            this.scheduleReconnect(url);\n        }\n    }\n    scheduleReconnect(url) {\n        if (this._stopped) return;\n        const e = this.reconnectTimers.get(url);\n        if (e) clearTimeout(e);\n        const a = this.reconnectAttempts.get(url) || 0;\n        const d = Math.min(3000 * Math.pow(2, a), 60000);\n        this.reconnectAttempts.set(url, a + 1);\n        this.reconnectTimers.set(url, setTimeout(()=>{\n            if (!this._stopped && this._sk) this.connectToRelay(url);\n        }, d));\n    }\n    handleRelayMessage(data) {\n        if (!Array.isArray(data)) return;\n        if (data[0] === \"EVENT\") {\n            const ev = data[2];\n            if (!ev || this.seenEvents.has(ev.id)) return;\n            this.seenEvents.add(ev.id);\n            if (ev.kind === 4) this.handleEncryptedDM(ev);\n            else if (ev.kind === 0) this.handleProfileEvent(ev);\n            else if (ev.kind === 40) this.handleChannelEvent(ev);\n            else if (ev.kind === 42) this.handleChannelMessageEvent(ev);\n        }\n    }\n    async handleEncryptedDM(event) {\n        if (!this._sk) return;\n        const pTag = event.tags.find((t)=>t[0] === \"p\");\n        if (!pTag) return;\n        const isForMe = pTag[1] === this._pk, isFromMe = event.pubkey === this._pk;\n        if (!isForMe && !isFromMe) return;\n        const other = isFromMe ? pTag[1] : event.pubkey;\n        try {\n            const dec = await (0,nostr_tools_nip04__WEBPACK_IMPORTED_MODULE_3__.decrypt)(this._sk, other, event.content);\n            try {\n                const p = JSON.parse(dec);\n                if (p === null || p === void 0 ? void 0 : p._nostr_msg_type) {\n                    const mt = p._nostr_msg_type;\n                    if (mt === \"text\") {\n                        this.messageCallbacks.forEach((cb)=>cb({\n                                id: event.id,\n                                from: event.pubkey,\n                                to: pTag[1],\n                                content: p.text || \"\",\n                                timestamp: event.created_at * 1000,\n                                msgType: \"text\",\n                                replyTo: p.replyTo\n                            }));\n                        return;\n                    }\n                    if ([\n                        \"webrtc-offer\",\n                        \"webrtc-answer\",\n                        \"webrtc-ice\",\n                        \"call-request\",\n                        \"call-accept\",\n                        \"call-reject\",\n                        \"call-end\"\n                    ].includes(mt)) {\n                        this.signalCallbacks.forEach((cb)=>cb(event.pubkey, {\n                                type: mt,\n                                sdp: p.sdp,\n                                candidate: p.candidate,\n                                callType: p.callType\n                            }));\n                        return;\n                    }\n                    if (mt === \"file-chunk\") {\n                        this.handleFileChunk(event.id, event.pubkey, pTag[1], event.created_at * 1000, p);\n                        return;\n                    }\n                    if (mt === \"file-meta\") {\n                        const transferId = p.transferId || \"\";\n                        if (!transferId) return;\n                        const fileType = [\n                            \"image\",\n                            \"audio\"\n                        ].includes(p.fileType) ? p.fileType : \"file\";\n                        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.ensureTransfer)({\n                            transferId,\n                            fileName: p.fileName || \"file\",\n                            mimeType: p.mimeType || \"application/octet-stream\",\n                            fileType,\n                            size: p.size || 0,\n                            totalChunks: p.totalChunks || 0,\n                            text: p.text || \"\"\n                        });\n                        return;\n                    }\n                    if (mt === \"image\" || mt === \"file\" || mt === \"audio\") {\n                        this.messageCallbacks.forEach((cb)=>cb({\n                                id: event.id,\n                                from: event.pubkey,\n                                to: pTag[1],\n                                content: p.text || \"\",\n                                timestamp: event.created_at * 1000,\n                                msgType: mt,\n                                replyTo: p.replyTo,\n                                attachment: {\n                                    type: mt,\n                                    name: p.fileName || \"file\",\n                                    mimeType: p.mimeType || \"application/octet-stream\",\n                                    data: p.data || \"\",\n                                    size: p.size || 0\n                                }\n                            }));\n                        return;\n                    }\n                }\n            } catch (e) {}\n            this.messageCallbacks.forEach((cb)=>cb({\n                    id: event.id,\n                    from: event.pubkey,\n                    to: pTag[1],\n                    content: dec,\n                    timestamp: event.created_at * 1000,\n                    msgType: \"text\"\n                }));\n        } catch (e) {}\n    }\n    async handleFileChunk(eventId, from, to, timestamp, p) {\n        const transferId = p.transferId;\n        const chunkIndex = p.chunkIndex;\n        const totalChunks = p.totalChunks;\n        const data = p.data;\n        if (!transferId || typeof chunkIndex !== \"number\" || typeof totalChunks !== \"number\" || typeof data !== \"string\") return;\n        const fileType = [\n            \"image\",\n            \"audio\"\n        ].includes(p.fileType) ? p.fileType : \"file\";\n        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.ensureTransfer)({\n            transferId,\n            fileName: p.fileName || \"file\",\n            mimeType: p.mimeType || \"application/octet-stream\",\n            fileType,\n            size: p.size || 0,\n            totalChunks,\n            text: p.text || \"\"\n        });\n        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.storeChunk)(transferId, chunkIndex, totalChunks, data);\n        const done = await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.isTransferComplete)(transferId);\n        if (!done) return;\n        this.messageCallbacks.forEach((cb)=>cb({\n                id: \"\".concat(eventId, \"-assembled-\").concat(transferId),\n                from,\n                to,\n                content: p.text || \"\",\n                timestamp,\n                msgType: fileType,\n                replyTo: p.replyTo,\n                attachment: {\n                    type: fileType,\n                    name: p.fileName || \"file\",\n                    mimeType: p.mimeType || \"application/octet-stream\",\n                    data: \"\",\n                    size: p.size || 0,\n                    transferId,\n                    totalChunks,\n                    chunked: true\n                }\n            }));\n    }\n    handleProfileEvent(event) {\n        try {\n            const p = JSON.parse(event.content);\n            this.profileCache.set(event.pubkey, p);\n            this.pendingProfiles.delete(event.pubkey);\n            this.profileCallbacks.forEach((cb)=>cb(event.pubkey, p));\n        } catch (e) {}\n    }\n    handleChannelEvent(event) {\n        try {\n            var _payload_name;\n            const payload = JSON.parse(event.content);\n            const channel = {\n                id: event.id,\n                name: ((_payload_name = payload.name) === null || _payload_name === void 0 ? void 0 : _payload_name.trim()) || \"channel-\".concat(event.id.slice(0, 8)),\n                about: payload.about,\n                createdBy: event.pubkey,\n                createdAt: event.created_at * 1000\n            };\n            this.channelCallbacks.forEach((cb)=>cb(channel));\n        } catch (e) {}\n    }\n    handleChannelMessageEvent(event) {\n        var _event_tags_find;\n        const eTag = (_event_tags_find = event.tags.find((t)=>t[0] === \"e\")) === null || _event_tags_find === void 0 ? void 0 : _event_tags_find[1];\n        if (!eTag) return;\n        try {\n            const payload = JSON.parse(event.content);\n            this.channelMessageCallbacks.forEach((cb)=>cb({\n                    id: event.id,\n                    from: event.pubkey,\n                    to: \"\",\n                    content: payload.text || \"\",\n                    timestamp: event.created_at * 1000,\n                    msgType: \"channel\",\n                    channelId: eTag,\n                    replyTo: payload.replyTo\n                }));\n        } catch (e) {\n            this.channelMessageCallbacks.forEach((cb)=>cb({\n                    id: event.id,\n                    from: event.pubkey,\n                    to: \"\",\n                    content: event.content || \"\",\n                    timestamp: event.created_at * 1000,\n                    msgType: \"channel\",\n                    channelId: eTag\n                }));\n        }\n    }\n    subscribeToMessages(relayUrl) {\n        if (!this._pk) return;\n        const ws = this.sockets.get(relayUrl);\n        if (!ws || ws.readyState !== WebSocket.OPEN) return;\n        const subId = \"dm-\" + Math.random().toString(36).slice(2, 8);\n        const since = Math.floor(Date.now() / 1000) - 86400 * 30;\n        ws.send(JSON.stringify([\n            \"REQ\",\n            subId,\n            {\n                kinds: [\n                    4\n                ],\n                \"#p\": [\n                    this._pk\n                ],\n                since\n            },\n            {\n                kinds: [\n                    4\n                ],\n                authors: [\n                    this._pk\n                ],\n                since\n            }\n        ]));\n        this.subscriptions.set(subId, {\n            filters: [],\n            relay: relayUrl\n        });\n        this.subscribeToChannels(relayUrl);\n    }\n    subscribeToChannels(relayUrl) {\n        const ws = this.sockets.get(relayUrl);\n        if (!ws || ws.readyState !== WebSocket.OPEN) return;\n        if (this._channels.length === 0) return; // Do not subscribe to global channels\n        const subId = \"ch-\" + Math.random().toString(36).slice(2, 8);\n        const since = Math.floor(Date.now() / 1000) - 86400 * 30;\n        // Only subscribe to channels the user has joined\n        ws.send(JSON.stringify([\n            \"REQ\",\n            subId,\n            {\n                kinds: [\n                    40\n                ],\n                ids: this._channels,\n                since\n            },\n            {\n                kinds: [\n                    42\n                ],\n                \"#e\": this._channels,\n                since\n            }\n        ]));\n        this.subscriptions.set(subId, {\n            filters: [],\n            relay: relayUrl\n        });\n    }\n    async sendEncryptedPayload(recipientPubkey, payload) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const encrypted = await (0,nostr_tools_nip04__WEBPACK_IMPORTED_MODULE_3__.encrypt)(this._sk, recipientPubkey, payload);\n        const ev = {\n            kind: 4,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [\n                [\n                    \"p\",\n                    recipientPubkey\n                ]\n            ],\n            content: encrypted,\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        this.seenEvents.add(event.id);\n        const json = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        const open = [];\n        for (const [, ws] of this.sockets)if (ws.readyState === WebSocket.OPEN) open.push(ws);\n        if (!open.length) throw new Error(\"No connected relays\");\n        open.forEach((ws)=>{\n            try {\n                ws.send(json);\n            } catch (e) {}\n        });\n        return event.id;\n    }\n    bytesToBase64(bytes) {\n        let bin = \"\";\n        const step = 0x8000;\n        for(let i = 0; i < bytes.length; i += step){\n            bin += String.fromCharCode(...bytes.subarray(i, i + step));\n        }\n        return btoa(bin);\n    }\n    async sendDirectMessage(recipientPubkey, content, replyTo) {\n        const payload = replyTo ? JSON.stringify({\n            _nostr_msg_type: \"text\",\n            text: content,\n            replyTo\n        }) : content;\n        const id = await this.sendEncryptedPayload(recipientPubkey, payload);\n        return {\n            id,\n            from: this._pk,\n            to: recipientPubkey,\n            content,\n            timestamp: Date.now(),\n            msgType: \"text\",\n            replyTo\n        };\n    }\n    async sendAttachment(recipientPubkey, attachment, text, onProgress, replyTo) {\n        const maxSize = 2 * 1024 * 1024 * 1024;\n        if (attachment.size > maxSize) throw new Error(\"File is too large. Max size is 2GB.\");\n        if (!attachment.file) {\n            const b64 = attachment.data;\n            if (b64.length < 40000) {\n                const id = await this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n                    _nostr_msg_type: attachment.type,\n                    fileName: attachment.name,\n                    mimeType: attachment.mimeType,\n                    data: b64,\n                    size: attachment.size,\n                    text: text || \"\",\n                    replyTo\n                }));\n                return {\n                    id,\n                    from: this._pk,\n                    to: recipientPubkey,\n                    content: text || \"\",\n                    timestamp: Date.now(),\n                    msgType: attachment.type,\n                    attachment,\n                    replyTo\n                };\n            }\n        }\n        const file = attachment.file;\n        const transferId = Math.random().toString(36).slice(2) + Date.now().toString(36);\n        const fileSize = file ? file.size : attachment.size;\n        const totalChunks = Math.ceil(fileSize / NostrClient.CHUNK_SIZE);\n        let lastId = \"\";\n        let sent = 0;\n        await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.ensureTransfer)({\n            transferId,\n            fileName: attachment.name,\n            mimeType: attachment.mimeType,\n            fileType: attachment.type,\n            size: fileSize,\n            totalChunks,\n            text: text || \"\"\n        });\n        await this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n            _nostr_msg_type: \"file-meta\",\n            transferId,\n            totalChunks,\n            fileName: attachment.name,\n            mimeType: attachment.mimeType,\n            size: fileSize,\n            text: text || \"\",\n            fileType: attachment.type,\n            replyTo\n        }));\n        for(let batch = 0; batch < totalChunks; batch += NostrClient.PARALLEL){\n            const promises = [];\n            const localChunks = [];\n            for(let j = 0; j < NostrClient.PARALLEL && batch + j < totalChunks; j++){\n                const i = batch + j;\n                let chunkData;\n                if (file) {\n                    const start = i * NostrClient.CHUNK_SIZE;\n                    const end = Math.min(start + NostrClient.CHUNK_SIZE, fileSize);\n                    const bytes = new Uint8Array(await file.slice(start, end).arrayBuffer());\n                    chunkData = this.bytesToBase64(bytes);\n                } else {\n                    const base64ChunkSize = Math.floor(NostrClient.CHUNK_SIZE / 3 * 4);\n                    chunkData = attachment.data.slice(i * base64ChunkSize, (i + 1) * base64ChunkSize);\n                }\n                localChunks.push({\n                    i,\n                    data: chunkData\n                });\n                promises.push(this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n                    _nostr_msg_type: \"file-chunk\",\n                    transferId,\n                    chunkIndex: i,\n                    totalChunks,\n                    data: chunkData,\n                    fileName: attachment.name,\n                    mimeType: attachment.mimeType,\n                    size: fileSize,\n                    text: text || \"\",\n                    fileType: attachment.type,\n                    replyTo\n                })));\n            }\n            const ids = await Promise.all(promises);\n            lastId = ids[ids.length - 1] || lastId;\n            for (const chunk of localChunks){\n                await (0,_chunkStore__WEBPACK_IMPORTED_MODULE_0__.storeChunk)(transferId, chunk.i, totalChunks, chunk.data);\n            }\n            sent += promises.length;\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(sent, totalChunks);\n            if (sent < totalChunks) await new Promise((r)=>setTimeout(r, 50));\n        }\n        return {\n            id: lastId || \"local-\".concat(transferId),\n            from: this._pk,\n            to: recipientPubkey,\n            content: text || \"\",\n            timestamp: Date.now(),\n            msgType: attachment.type,\n            replyTo,\n            attachment: {\n                ...attachment,\n                data: attachment.file ? \"\" : attachment.data,\n                transferId,\n                totalChunks,\n                chunked: true\n            }\n        };\n    }\n    async sendWebRTCSignal(recipientPubkey, signal) {\n        await this.sendEncryptedPayload(recipientPubkey, JSON.stringify({\n            _nostr_msg_type: signal.type,\n            sdp: signal.sdp,\n            candidate: signal.candidate,\n            callType: signal.callType\n        }));\n    }\n    async createChannel(name, about) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const ev = {\n            kind: 40,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [],\n            content: JSON.stringify({\n                name,\n                about: about || \"\"\n            }),\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        const payload = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        for (const [, ws] of this.sockets)if (ws.readyState === WebSocket.OPEN) try {\n            ws.send(payload);\n        } catch (e) {}\n        const channel = {\n            id: event.id,\n            name,\n            about,\n            createdBy: this._pk,\n            createdAt: Date.now()\n        };\n        this.channelCallbacks.forEach((cb)=>cb(channel));\n        return channel;\n    }\n    async sendChannelMessage(channelId, text, replyTo) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const ev = {\n            kind: 42,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [\n                [\n                    \"e\",\n                    channelId,\n                    \"\",\n                    \"root\"\n                ]\n            ],\n            content: JSON.stringify({\n                text,\n                replyTo\n            }),\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        const payload = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        let sent = false;\n        for (const [, ws] of this.sockets){\n            if (ws.readyState !== WebSocket.OPEN) continue;\n            sent = true;\n            try {\n                ws.send(payload);\n            } catch (e) {}\n        }\n        if (!sent) throw new Error(\"No connected relays\");\n        return {\n            id: event.id,\n            from: this._pk,\n            to: \"\",\n            content: text,\n            timestamp: Date.now(),\n            msgType: \"channel\",\n            channelId,\n            replyTo\n        };\n    }\n    requestProfile(pubkey) {\n        if (this.profileCache.has(pubkey)) return this.profileCache.get(pubkey);\n        if (this.pendingProfiles.has(pubkey)) return null;\n        this.pendingProfiles.add(pubkey);\n        const subId = \"p-\" + Math.random().toString(36).slice(2, 8);\n        for (const [, ws] of this.sockets){\n            if (ws.readyState === WebSocket.OPEN) {\n                ws.send(JSON.stringify([\n                    \"REQ\",\n                    subId,\n                    {\n                        kinds: [\n                            0\n                        ],\n                        authors: [\n                            pubkey\n                        ],\n                        limit: 1\n                    }\n                ]));\n                break;\n            }\n        }\n        return null;\n    }\n    getProfile(pubkey) {\n        return this.profileCache.get(pubkey) || null;\n    }\n    async updateProfile(profile) {\n        if (!this._sk) throw new Error(\"Not authorized\");\n        const ev = {\n            kind: 0,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [],\n            content: JSON.stringify(profile),\n            pubkey: this._pk\n        };\n        const event = (0,nostr_tools_pure__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(ev, this._sk);\n        const json = JSON.stringify([\n            \"EVENT\",\n            event\n        ]);\n        for (const [, ws] of this.sockets)if (ws.readyState === WebSocket.OPEN) try {\n            ws.send(json);\n        } catch (e) {}\n        this.profileCache.set(this._pk, profile);\n    }\n    disconnectAll() {\n        for (const [, t] of this.reconnectTimers)clearTimeout(t);\n        this.reconnectTimers.clear();\n        this.reconnectAttempts.clear();\n        for (const [, ws] of this.sockets)ws.close();\n        this.sockets.clear();\n        this.subscriptions.clear();\n        this.relayStatus.clear();\n    }\n    addRelay(url) {\n        if (!this._relays.includes(url)) {\n            this._relays.push(url);\n            this.connectToRelay(url);\n        }\n    }\n    removeRelay(url) {\n        this._relays = this._relays.filter((r)=>r !== url);\n        const t = this.reconnectTimers.get(url);\n        if (t) {\n            clearTimeout(t);\n            this.reconnectTimers.delete(url);\n        }\n        this.reconnectAttempts.delete(url);\n        const ws = this.sockets.get(url);\n        if (ws) {\n            ws.close();\n            this.sockets.delete(url);\n        }\n        this.relayStatus.delete(url);\n    }\n    shortenKey(key) {\n        return !key || key.length < 16 ? key : key.slice(0, 8) + \"â€¦\" + key.slice(-8);\n    }\n    isValidHexKey(key) {\n        return /^[0-9a-fA-F]{64}$/.test(key);\n    }\n    constructor(){\n        this._sk = null;\n        this._pk = \"\";\n        this.sockets = new Map();\n        this.relayStatus = new Map();\n        this.subscriptions = new Map();\n        this.messageCallbacks = new Set();\n        this.channelCallbacks = new Set();\n        this.channelMessageCallbacks = new Set();\n        this.profileCallbacks = new Set();\n        this.connectionCallbacks = new Set();\n        this.signalCallbacks = new Set();\n        this.profileCache = new Map();\n        this.pendingProfiles = new Set();\n        this.seenEvents = new Set();\n        this._relays = [\n            ...DEFAULT_RELAYS\n        ];\n        this.reconnectAttempts = new Map();\n        this.reconnectTimers = new Map();\n        this._stopped = false;\n        this._channels = [];\n    }\n}\n// 256KB chunks, parallel send by 3\nNostrClient.CHUNK_SIZE = 262144;\nNostrClient.PARALLEL = 3;\nconst nostrClient = new NostrClient();\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbm9zdHIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNHO0FBQ2pEO0FBQ1E7QUFFaUI7QUFzRjlFLE1BQU1VLGlCQUFpQjtJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBZ0JELE1BQU1DO0lBcUJKLElBQUlDLFlBQW9CO1FBQUUsT0FBTyxJQUFJLENBQUNDLEdBQUc7SUFBRTtJQUMzQyxJQUFJQyxnQkFBd0I7UUFBRSxPQUFPLElBQUksQ0FBQ0MsR0FBRyxHQUFHViwrREFBVUEsQ0FBQyxJQUFJLENBQUNVLEdBQUcsSUFBSTtJQUFJO0lBQzNFLElBQUlDLFNBQW1CO1FBQUUsT0FBTztlQUFJLElBQUksQ0FBQ0MsT0FBTztTQUFDO0lBQUU7SUFDbkQsSUFBSUMsV0FBcUI7UUFBRSxPQUFPO2VBQUksSUFBSSxDQUFDQyxTQUFTO1NBQUM7SUFBRTtJQUN2RCxJQUFJQyxLQUF3QjtRQUFFLE9BQU8sSUFBSSxDQUFDTCxHQUFHO0lBQUU7SUFFL0NNLGVBQWVDLEtBQWEsRUFBVTtRQUNwQyxPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxHQUFHLENBQUNGLFVBQVU7SUFDeEM7SUFFQSxJQUFJRyxzQkFBOEI7UUFDaEMsSUFBSUMsSUFBSTtRQUNSLElBQUksQ0FBQ0gsV0FBVyxDQUFDSSxPQUFPLENBQUMsQ0FBQ0M7WUFDeEIsSUFBSUEsTUFBTSxhQUFhO2dCQUNyQkY7WUFDRjtRQUNGO1FBQ0EsT0FBT0E7SUFDVDtJQUVBRyxlQUFlO1FBQ2IsTUFBTVQsS0FBS3BCLG1FQUFpQkE7UUFDNUIsTUFBTThCLEtBQUs3Qiw4REFBWUEsQ0FBQ21CO1FBQ3hCLE9BQU87WUFBRVcsWUFBWTFCLCtEQUFVQSxDQUFDZTtZQUFLUixXQUFXa0I7UUFBRztJQUNyRDtJQUVBRSxNQUFNbEIsYUFBcUIsRUFBVTtRQUNuQyxNQUFNTSxLQUFLZCwrREFBVUEsQ0FBQ1E7UUFDdEIsTUFBTWdCLEtBQUs3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Q0FBQ1osT0FBTyxDQUFDcEIsTUFBTSxDQUFDeUI7UUFBTTtRQUNsRixJQUFJLENBQUNoRCxXQUFXLENBQUN1QixNQUFNLENBQUN5QjtJQUMxQjtJQUVBMEosV0FBV0MsR0FBVyxFQUFFO1FBQUUsT0FBTyxDQUFFQSxPQUFPQSxJQUFJekwsTUFBTSxHQUFHLEtBQU15TCxNQUFNQSxJQUFJM0UsS0FBSyxDQUFDLEdBQUcsS0FBSyxNQUFNMkUsSUFBSTNFLEtBQUssQ0FBQyxDQUFDO0lBQUk7SUFDMUc0RSxjQUFjRCxHQUFXLEVBQUU7UUFBRSxPQUFPLG9CQUFvQkUsSUFBSSxDQUFDRjtJQUFNOzthQWpoQjNEbk4sTUFBeUI7YUFDekJGLE1BQWM7YUFDZHFELFVBQWtDLElBQUltSzthQUN0QzlNLGNBQWtGLElBQUk4TTthQUN0RjVELGdCQUFtRSxJQUFJNEQ7YUFDdkV6TCxtQkFBeUMsSUFBSWtCO2FBQzdDZCxtQkFBeUMsSUFBSWM7YUFDN0NaLDBCQUF1RCxJQUFJWTthQUMzRFYsbUJBQXlDLElBQUlVO2FBQzdDUixzQkFBK0MsSUFBSVE7YUFDbkROLGtCQUF1QyxJQUFJTTthQUMzQ29GLGVBQTBDLElBQUltRjthQUM5Q2xGLGtCQUErQixJQUFJckY7YUFDbkNzQyxhQUEwQixJQUFJdEM7YUFDOUI3QyxVQUFvQjtlQUFJUDtTQUFlO2FBQ3ZDdUUsb0JBQXlDLElBQUlvSjthQUM3QzFJLGtCQUE4RCxJQUFJMEk7YUFDbEVwTSxXQUFXO2FBQ1hkLFlBQXNCLEVBQUU7O0FBZ2dCbEM7QUFwTkUsbUNBQW1DO0FBL1QvQlIsWUFnVVd5TCxhQUFhO0FBaFV4QnpMLFlBaVVXNkwsV0FBVztBQW9OckIsTUFBTThCLGNBQWMsSUFBSTNOLGNBQWM7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9ub3N0ci50cz9mOGY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdlbmVyYXRlU2VjcmV0S2V5LCBnZXRQdWJsaWNLZXksIGZpbmFsaXplRXZlbnQsIHR5cGUgVW5zaWduZWRFdmVudCB9IGZyb20gJ25vc3RyLXRvb2xzL3B1cmUnO1xuaW1wb3J0IHsgZW5jcnlwdCwgZGVjcnlwdCB9IGZyb20gJ25vc3RyLXRvb2xzL25pcDA0JztcbmltcG9ydCB7IGJ5dGVzVG9IZXgsIGhleFRvQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyIH0gZnJvbSAnbm9zdHItdG9vbHMnO1xuaW1wb3J0IHsgZW5zdXJlVHJhbnNmZXIsIGlzVHJhbnNmZXJDb21wbGV0ZSwgc3RvcmVDaHVuayB9IGZyb20gJy4vY2h1bmtTdG9yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9zdHJQcm9maWxlIHtcbiAgbmFtZT86IHN0cmluZztcbiAgYWJvdXQ/OiBzdHJpbmc7XG4gIHBpY3R1cmU/OiBzdHJpbmc7XG4gIG5pcDA1Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vc3RyRXZlbnQge1xuICBpZDogc3RyaW5nO1xuICBwdWJrZXk6IHN0cmluZztcbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuICBraW5kOiBudW1iZXI7XG4gIHRhZ3M6IHN0cmluZ1tdW107XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgc2lnOiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIE1lc3NhZ2VUeXBlID1cbiAgfCAndGV4dCdcbiAgfCAnaW1hZ2UnXG4gIHwgJ2ZpbGUnXG4gIHwgJ2F1ZGlvJ1xuICB8ICdmaWxlLW1ldGEnXG4gIHwgJ2ZpbGUtY2h1bmsnXG4gIHwgJ2NoYW5uZWwnXG4gIHwgJ3dlYnJ0Yy1vZmZlcidcbiAgfCAnd2VicnRjLWFuc3dlcidcbiAgfCAnd2VicnRjLWljZSdcbiAgfCAnY2FsbC1yZXF1ZXN0J1xuICB8ICdjYWxsLWFjY2VwdCdcbiAgfCAnY2FsbC1yZWplY3QnXG4gIHwgJ2NhbGwtZW5kJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXBseVJlZiB7XG4gIGlkOiBzdHJpbmc7XG4gIGZyb206IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICB0eXBlOiAnaW1hZ2UnIHwgJ2ZpbGUnIHwgJ2F1ZGlvJztcbiAgbmFtZTogc3RyaW5nO1xuICBtaW1lVHlwZTogc3RyaW5nO1xuICBkYXRhOiBzdHJpbmc7XG4gIHNpemU6IG51bWJlcjtcbiAgZmlsZT86IEZpbGU7XG4gIHRyYW5zZmVySWQ/OiBzdHJpbmc7XG4gIHRvdGFsQ2h1bmtzPzogbnVtYmVyO1xuICBjaHVua2VkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaXJlY3RNZXNzYWdlIHtcbiAgaWQ6IHN0cmluZztcbiAgZnJvbTogc3RyaW5nO1xuICB0bzogc3RyaW5nO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBwZW5kaW5nPzogYm9vbGVhbjtcbiAgZmFpbGVkPzogYm9vbGVhbjtcbiAgbXNnVHlwZT86IE1lc3NhZ2VUeXBlO1xuICBhdHRhY2htZW50PzogQXR0YWNobWVudDtcbiAgcmVwbHlUbz86IFJlcGx5UmVmO1xuICBjaGFubmVsSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhbm5lbCB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgYWJvdXQ/OiBzdHJpbmc7XG4gIGNyZWF0ZWRCeTogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250YWN0IHtcbiAgcHVia2V5OiBzdHJpbmc7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIGFib3V0Pzogc3RyaW5nO1xuICBwaWN0dXJlPzogc3RyaW5nO1xuICBsYXN0TWVzc2FnZT86IHN0cmluZztcbiAgbGFzdE1lc3NhZ2VUaW1lPzogbnVtYmVyO1xuICB1bnJlYWQ/OiBudW1iZXI7XG4gIG9ubGluZT86IGJvb2xlYW47XG59XG5cbmNvbnN0IERFRkFVTFRfUkVMQVlTID0gW1xuICAnd3NzOi8vcmVsYXkuZGFtdXMuaW8nLFxuICAnd3NzOi8vbm9zLmxvbCcsXG4gICd3c3M6Ly9yZWxheS5zbm9ydC5zb2NpYWwnLFxuICAnd3NzOi8vcmVsYXkucHJpbWFsLm5ldCcsXG4gICd3c3M6Ly9wdXJwbGVwYWcuZXMnLFxuICAnd3NzOi8vbm9zdHIubW9tJyxcbiAgJ3dzczovL3JlbGF5Lm5vc3RyLmJnJyxcbl07XG5cbnR5cGUgTWVzc2FnZUNhbGxiYWNrID0gKG1zZzogRGlyZWN0TWVzc2FnZSkgPT4gdm9pZDtcbnR5cGUgQ2hhbm5lbENhbGxiYWNrID0gKGNoYW5uZWw6IENoYW5uZWwpID0+IHZvaWQ7XG50eXBlIENoYW5uZWxNZXNzYWdlQ2FsbGJhY2sgPSAobXNnOiBEaXJlY3RNZXNzYWdlKSA9PiB2b2lkO1xudHlwZSBQcm9maWxlQ2FsbGJhY2sgPSAocHVia2V5OiBzdHJpbmcsIHByb2ZpbGU6IE5vc3RyUHJvZmlsZSkgPT4gdm9pZDtcbnR5cGUgQ29ubmVjdGlvbkNhbGxiYWNrID0gKHJlbGF5OiBzdHJpbmcsIHN0YXR1czogJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyB8ICdlcnJvcicpID0+IHZvaWQ7XG50eXBlIFNpZ25hbENhbGxiYWNrID0gKGZyb206IHN0cmluZywgc2lnbmFsOiBXZWJSVENTaWduYWwpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViUlRDU2lnbmFsIHtcbiAgdHlwZTogTWVzc2FnZVR5cGU7XG4gIHNkcD86IHN0cmluZztcbiAgY2FuZGlkYXRlPzogUlRDSWNlQ2FuZGlkYXRlSW5pdDtcbiAgY2FsbFR5cGU/OiAnYXVkaW8nIHwgJ3ZpZGVvJztcbn1cblxuY2xhc3MgTm9zdHJDbGllbnQge1xuICBwcml2YXRlIF9zazogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9wazogc3RyaW5nID0gJyc7XG4gIHByaXZhdGUgc29ja2V0czogTWFwPHN0cmluZywgV2ViU29ja2V0PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZWxheVN0YXR1czogTWFwPHN0cmluZywgJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyB8ICdjb25uZWN0aW5nJyB8ICdlcnJvcic+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IE1hcDxzdHJpbmcsIHsgZmlsdGVyczogRmlsdGVyW107IHJlbGF5OiBzdHJpbmcgfT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgbWVzc2FnZUNhbGxiYWNrczogU2V0PE1lc3NhZ2VDYWxsYmFjaz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgY2hhbm5lbENhbGxiYWNrczogU2V0PENoYW5uZWxDYWxsYmFjaz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgY2hhbm5lbE1lc3NhZ2VDYWxsYmFja3M6IFNldDxDaGFubmVsTWVzc2FnZUNhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBwcm9maWxlQ2FsbGJhY2tzOiBTZXQ8UHJvZmlsZUNhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBjb25uZWN0aW9uQ2FsbGJhY2tzOiBTZXQ8Q29ubmVjdGlvbkNhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBzaWduYWxDYWxsYmFja3M6IFNldDxTaWduYWxDYWxsYmFjaz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgcHJvZmlsZUNhY2hlOiBNYXA8c3RyaW5nLCBOb3N0clByb2ZpbGU+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHBlbmRpbmdQcm9maWxlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgc2VlbkV2ZW50czogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgX3JlbGF5czogc3RyaW5nW10gPSBbLi4uREVGQVVMVF9SRUxBWVNdO1xuICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlY29ubmVjdFRpbWVyczogTWFwPHN0cmluZywgUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIF9zdG9wcGVkID0gZmFsc2U7XG4gIHByaXZhdGUgX2NoYW5uZWxzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGdldCBwdWJsaWNLZXkoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX3BrOyB9XG4gIGdldCBwcml2YXRlS2V5SGV4KCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9zayA/IGJ5dGVzVG9IZXgodGhpcy5fc2spIDogJyc7IH1cbiAgZ2V0IHJlbGF5cygpOiBzdHJpbmdbXSB7IHJldHVybiBbLi4udGhpcy5fcmVsYXlzXTsgfVxuICBnZXQgY2hhbm5lbHMoKTogc3RyaW5nW10geyByZXR1cm4gWy4uLnRoaXMuX2NoYW5uZWxzXTsgfVxuICBnZXQgc2soKTogVWludDhBcnJheSB8IG51bGwgeyByZXR1cm4gdGhpcy5fc2s7IH1cblxuICBnZXRSZWxheVN0YXR1cyhyZWxheTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheVN0YXR1cy5nZXQocmVsYXkpIHx8ICdkaXNjb25uZWN0ZWQnO1xuICB9XG5cbiAgZ2V0IGNvbm5lY3RlZFJlbGF5Q291bnQoKTogbnVtYmVyIHtcbiAgICBsZXQgYyA9IDA7XG4gICAgdGhpcy5yZWxheVN0YXR1cy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBpZiAocyA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgYysrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgZ2VuZXJhdGVLZXlzKCkge1xuICAgIGNvbnN0IHNrID0gZ2VuZXJhdGVTZWNyZXRLZXkoKTtcbiAgICBjb25zdCBwayA9IGdldFB1YmxpY0tleShzayk7XG4gICAgcmV0dXJuIHsgcHJpdmF0ZUtleTogYnl0ZXNUb0hleChzayksIHB1YmxpY0tleTogcGsgfTtcbiAgfVxuXG4gIGxvZ2luKHByaXZhdGVLZXlIZXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2sgPSBoZXhUb0J5dGVzKHByaXZhdGVLZXlIZXgpO1xuICAgIGNvbnN0IHBrID0gZ2V0UHVibGljS2V5KHNrKTtcbiAgICB0aGlzLl9zayA9IHNrOyB0aGlzLl9wayA9IHBrOyB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ25vc3RyX3NrJywgcHJpdmF0ZUtleUhleCk7XG4gICAgcmV0dXJuIHBrO1xuICB9XG5cbiAgbG9nb3V0KCkge1xuICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlOyB0aGlzLmRpc2Nvbm5lY3RBbGwoKTtcbiAgICB0aGlzLl9zayA9IG51bGw7IHRoaXMuX3BrID0gJyc7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ25vc3RyX3NrJyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ25vc3RyX2NvbnRhY3RzJyk7XG4gIH1cblxuICB0cnlBdXRvTG9naW4oKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc2sgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbm9zdHJfc2snKTtcbiAgICBpZiAoc2s/Lmxlbmd0aCA9PT0gNjQpIHsgdHJ5IHsgdGhpcy5sb2dpbihzayk7IHJldHVybiB0cnVlOyB9IGNhdGNoIHsgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ25vc3RyX3NrJyk7IH0gfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG9uTWVzc2FnZShjYjogTWVzc2FnZUNhbGxiYWNrKSB7IHRoaXMubWVzc2FnZUNhbGxiYWNrcy5hZGQoY2IpOyByZXR1cm4gKCkgPT4geyB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZGVsZXRlKGNiKTsgfTsgfVxuICBvbkNoYW5uZWwoY2I6IENoYW5uZWxDYWxsYmFjaykgeyB0aGlzLmNoYW5uZWxDYWxsYmFja3MuYWRkKGNiKTsgcmV0dXJuICgpID0+IHsgdGhpcy5jaGFubmVsQ2FsbGJhY2tzLmRlbGV0ZShjYik7IH07IH1cbiAgb25DaGFubmVsTWVzc2FnZShjYjogQ2hhbm5lbE1lc3NhZ2VDYWxsYmFjaykgeyB0aGlzLmNoYW5uZWxNZXNzYWdlQ2FsbGJhY2tzLmFkZChjYik7IHJldHVybiAoKSA9PiB7IHRoaXMuY2hhbm5lbE1lc3NhZ2VDYWxsYmFja3MuZGVsZXRlKGNiKTsgfTsgfVxuICBvblByb2ZpbGUoY2I6IFByb2ZpbGVDYWxsYmFjaykgeyB0aGlzLnByb2ZpbGVDYWxsYmFja3MuYWRkKGNiKTsgcmV0dXJuICgpID0+IHsgdGhpcy5wcm9maWxlQ2FsbGJhY2tzLmRlbGV0ZShjYik7IH07IH1cbiAgb25Db25uZWN0aW9uKGNiOiBDb25uZWN0aW9uQ2FsbGJhY2spIHsgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzLmFkZChjYik7IHJldHVybiAoKSA9PiB7IHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcy5kZWxldGUoY2IpOyB9OyB9XG4gIG9uU2lnbmFsKGNiOiBTaWduYWxDYWxsYmFjaykgeyB0aGlzLnNpZ25hbENhbGxiYWNrcy5hZGQoY2IpOyByZXR1cm4gKCkgPT4geyB0aGlzLnNpZ25hbENhbGxiYWNrcy5kZWxldGUoY2IpOyB9OyB9XG5cbiAgYXN5bmMgY29ubmVjdFRvUmVsYXlzKCkgeyBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fcmVsYXlzKSB0aGlzLmNvbm5lY3RUb1JlbGF5KHIpOyB9XG5cbiAgc2V0Q2hhbm5lbHMoY2hhbm5lbElkczogc3RyaW5nW10pIHtcbiAgICB0aGlzLl9jaGFubmVscyA9IFsuLi5uZXcgU2V0KGNoYW5uZWxJZHMuZmlsdGVyKEJvb2xlYW4pKV07XG4gICAgZm9yIChjb25zdCBbcmVsYXksIHdzXSBvZiB0aGlzLnNvY2tldHMpIHtcbiAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWxzKHJlbGF5KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbm5lY3RUb1JlbGF5KHVybDogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX3N0b3BwZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5zb2NrZXRzLmhhcyh1cmwpKSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5zb2NrZXRzLmdldCh1cmwpITtcbiAgICAgIGlmIChlLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOIHx8IGUucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWxheVN0YXR1cy5zZXQodXJsLCAnY29ubmVjdGluZycpO1xuICAgIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHVybCwgJ2Rpc2Nvbm5lY3RlZCcpKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KHVybCk7XG4gICAgICBjb25zdCBjdCA9IHNldFRpbWVvdXQoKCkgPT4geyBpZiAod3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHdzLmNsb3NlKCk7IH0sIDgwMDApO1xuICAgICAgdGhpcy5zb2NrZXRzLnNldCh1cmwsIHdzKTtcbiAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHsgY2xlYXJUaW1lb3V0KGN0KTsgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cy5zZXQodXJsLCAwKTsgdGhpcy5yZWxheVN0YXR1cy5zZXQodXJsLCAnY29ubmVjdGVkJyk7IHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHVybCwgJ2Nvbm5lY3RlZCcpKTsgdGhpcy5zdWJzY3JpYmVUb01lc3NhZ2VzKHVybCk7IH07XG4gICAgICB3cy5vbmNsb3NlID0gKCkgPT4geyBjbGVhclRpbWVvdXQoY3QpOyB0aGlzLnJlbGF5U3RhdHVzLnNldCh1cmwsICdkaXNjb25uZWN0ZWQnKTsgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IodXJsLCAnZGlzY29ubmVjdGVkJykpOyB0aGlzLnNvY2tldHMuZGVsZXRlKHVybCk7IHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QodXJsKTsgfTtcbiAgICAgIHdzLm9uZXJyb3IgPSAoKSA9PiB7IHRoaXMucmVsYXlTdGF0dXMuc2V0KHVybCwgJ2Vycm9yJyk7IHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHVybCwgJ2Vycm9yJykpOyB9O1xuICAgICAgd3Mub25tZXNzYWdlID0gKGUpID0+IHsgdHJ5IHsgdGhpcy5oYW5kbGVSZWxheU1lc3NhZ2UoSlNPTi5wYXJzZShlLmRhdGEpKTsgfSBjYXRjaCB7fSB9O1xuICAgIH0gY2F0Y2ggeyB0aGlzLnJlbGF5U3RhdHVzLnNldCh1cmwsICdlcnJvcicpOyB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KHVybCk7IH1cbiAgfVxuXG4gIHByaXZhdGUgc2NoZWR1bGVSZWNvbm5lY3QodXJsOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5fc3RvcHBlZCkgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLnJlY29ubmVjdFRpbWVycy5nZXQodXJsKTsgaWYgKGUpIGNsZWFyVGltZW91dChlKTtcbiAgICBjb25zdCBhID0gdGhpcy5yZWNvbm5lY3RBdHRlbXB0cy5nZXQodXJsKSB8fCAwO1xuICAgIGNvbnN0IGQgPSBNYXRoLm1pbigzMDAwICogTWF0aC5wb3coMiwgYSksIDYwMDAwKTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzLnNldCh1cmwsIGEgKyAxKTtcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVycy5zZXQodXJsLCBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKCF0aGlzLl9zdG9wcGVkICYmIHRoaXMuX3NrKSB0aGlzLmNvbm5lY3RUb1JlbGF5KHVybCk7IH0sIGQpKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlUmVsYXlNZXNzYWdlKGRhdGE6IHVua25vd25bXSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkgcmV0dXJuO1xuICAgIGlmIChkYXRhWzBdID09PSAnRVZFTlQnKSB7XG4gICAgICBjb25zdCBldiA9IGRhdGFbMl0gYXMgTm9zdHJFdmVudDtcbiAgICAgIGlmICghZXYgfHwgdGhpcy5zZWVuRXZlbnRzLmhhcyhldi5pZCkpIHJldHVybjtcbiAgICAgIHRoaXMuc2VlbkV2ZW50cy5hZGQoZXYuaWQpO1xuICAgICAgaWYgKGV2LmtpbmQgPT09IDQpIHRoaXMuaGFuZGxlRW5jcnlwdGVkRE0oZXYpO1xuICAgICAgZWxzZSBpZiAoZXYua2luZCA9PT0gMCkgdGhpcy5oYW5kbGVQcm9maWxlRXZlbnQoZXYpO1xuICAgICAgZWxzZSBpZiAoZXYua2luZCA9PT0gNDApIHRoaXMuaGFuZGxlQ2hhbm5lbEV2ZW50KGV2KTtcbiAgICAgIGVsc2UgaWYgKGV2LmtpbmQgPT09IDQyKSB0aGlzLmhhbmRsZUNoYW5uZWxNZXNzYWdlRXZlbnQoZXYpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlRW5jcnlwdGVkRE0oZXZlbnQ6IE5vc3RyRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX3NrKSByZXR1cm47XG4gICAgY29uc3QgcFRhZyA9IGV2ZW50LnRhZ3MuZmluZCh0ID0+IHRbMF0gPT09ICdwJyk7IGlmICghcFRhZykgcmV0dXJuO1xuICAgIGNvbnN0IGlzRm9yTWUgPSBwVGFnWzFdID09PSB0aGlzLl9waywgaXNGcm9tTWUgPSBldmVudC5wdWJrZXkgPT09IHRoaXMuX3BrO1xuICAgIGlmICghaXNGb3JNZSAmJiAhaXNGcm9tTWUpIHJldHVybjtcbiAgICBjb25zdCBvdGhlciA9IGlzRnJvbU1lID8gcFRhZ1sxXSA6IGV2ZW50LnB1YmtleTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjID0gYXdhaXQgZGVjcnlwdCh0aGlzLl9zaywgb3RoZXIsIGV2ZW50LmNvbnRlbnQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcCA9IEpTT04ucGFyc2UoZGVjKTtcbiAgICAgICAgICBpZiAocD8uX25vc3RyX21zZ190eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBtdCA9IHAuX25vc3RyX21zZ190eXBlIGFzIE1lc3NhZ2VUeXBlO1xuICAgICAgICAgICAgaWYgKG10ID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2Ioe1xuICAgICAgICAgICAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgICAgICAgICAgICBmcm9tOiBldmVudC5wdWJrZXksXG4gICAgICAgICAgICAgICAgdG86IHBUYWdbMV0sXG4gICAgICAgICAgICAgICAgY29udGVudDogKHAudGV4dCBhcyBzdHJpbmcpIHx8ICcnLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsXG4gICAgICAgICAgICAgICAgbXNnVHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJlcGx5VG86IHAucmVwbHlUbyBhcyBSZXBseVJlZiB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoWyd3ZWJydGMtb2ZmZXInLCd3ZWJydGMtYW5zd2VyJywnd2VicnRjLWljZScsJ2NhbGwtcmVxdWVzdCcsJ2NhbGwtYWNjZXB0JywnY2FsbC1yZWplY3QnLCdjYWxsLWVuZCddLmluY2x1ZGVzKG10KSkge1xuICAgICAgICAgICAgdGhpcy5zaWduYWxDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYihldmVudC5wdWJrZXksIHsgdHlwZTogbXQsIHNkcDogcC5zZHAsIGNhbmRpZGF0ZTogcC5jYW5kaWRhdGUsIGNhbGxUeXBlOiBwLmNhbGxUeXBlIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG10ID09PSAnZmlsZS1jaHVuaycpIHsgdGhpcy5oYW5kbGVGaWxlQ2h1bmsoZXZlbnQuaWQsIGV2ZW50LnB1YmtleSwgcFRhZ1sxXSwgZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsIHApOyByZXR1cm47IH1cbiAgICAgICAgICBpZiAobXQgPT09ICdmaWxlLW1ldGEnKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2ZlcklkID0gKHAudHJhbnNmZXJJZCBhcyBzdHJpbmcpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2ZlcklkKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBmaWxlVHlwZSA9IFsnaW1hZ2UnLCAnYXVkaW8nXS5pbmNsdWRlcyhwLmZpbGVUeXBlIGFzIHN0cmluZykgPyBwLmZpbGVUeXBlIGFzICgnaW1hZ2UnIHwgJ2F1ZGlvJykgOiAnZmlsZSc7XG4gICAgICAgICAgICBhd2FpdCBlbnN1cmVUcmFuc2Zlcih7XG4gICAgICAgICAgICAgIHRyYW5zZmVySWQsXG4gICAgICAgICAgICAgIGZpbGVOYW1lOiAocC5maWxlTmFtZSBhcyBzdHJpbmcpIHx8ICdmaWxlJyxcbiAgICAgICAgICAgICAgbWltZVR5cGU6IChwLm1pbWVUeXBlIGFzIHN0cmluZykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAgIGZpbGVUeXBlLFxuICAgICAgICAgICAgICBzaXplOiAocC5zaXplIGFzIG51bWJlcikgfHwgMCxcbiAgICAgICAgICAgICAgdG90YWxDaHVua3M6IChwLnRvdGFsQ2h1bmtzIGFzIG51bWJlcikgfHwgMCxcbiAgICAgICAgICAgICAgdGV4dDogKHAudGV4dCBhcyBzdHJpbmcpIHx8ICcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtdCA9PT0gJ2ltYWdlJyB8fCBtdCA9PT0gJ2ZpbGUnIHx8IG10ID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYih7IGlkOiBldmVudC5pZCwgZnJvbTogZXZlbnQucHVia2V5LCB0bzogcFRhZ1sxXSwgY29udGVudDogcC50ZXh0IHx8ICcnLCB0aW1lc3RhbXA6IGV2ZW50LmNyZWF0ZWRfYXQgKiAxMDAwLCBtc2dUeXBlOiBtdCwgcmVwbHlUbzogcC5yZXBseVRvIGFzIFJlcGx5UmVmIHwgdW5kZWZpbmVkLCBhdHRhY2htZW50OiB7IHR5cGU6IG10LCBuYW1lOiBwLmZpbGVOYW1lIHx8ICdmaWxlJywgbWltZVR5cGU6IHAubWltZVR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsIGRhdGE6IHAuZGF0YSB8fCAnJywgc2l6ZTogcC5zaXplIHx8IDAgfSB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYih7IGlkOiBldmVudC5pZCwgZnJvbTogZXZlbnQucHVia2V5LCB0bzogcFRhZ1sxXSwgY29udGVudDogZGVjLCB0aW1lc3RhbXA6IGV2ZW50LmNyZWF0ZWRfYXQgKiAxMDAwLCBtc2dUeXBlOiAndGV4dCcgfSkpO1xuICAgIH0gY2F0Y2gge31cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlRmlsZUNodW5rKGV2ZW50SWQ6IHN0cmluZywgZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nLCB0aW1lc3RhbXA6IG51bWJlciwgcDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBjb25zdCB0cmFuc2ZlcklkID0gcC50cmFuc2ZlcklkIGFzIHN0cmluZztcbiAgICBjb25zdCBjaHVua0luZGV4ID0gcC5jaHVua0luZGV4IGFzIG51bWJlcjtcbiAgICBjb25zdCB0b3RhbENodW5rcyA9IHAudG90YWxDaHVua3MgYXMgbnVtYmVyO1xuICAgIGNvbnN0IGRhdGEgPSBwLmRhdGEgYXMgc3RyaW5nO1xuICAgIGlmICghdHJhbnNmZXJJZCB8fCB0eXBlb2YgY2h1bmtJbmRleCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRvdGFsQ2h1bmtzICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHJldHVybjtcblxuICAgIGNvbnN0IGZpbGVUeXBlID0gWydpbWFnZScsICdhdWRpbyddLmluY2x1ZGVzKHAuZmlsZVR5cGUgYXMgc3RyaW5nKSA/IHAuZmlsZVR5cGUgYXMgKCdpbWFnZScgfCAnYXVkaW8nKSA6ICdmaWxlJztcbiAgICBhd2FpdCBlbnN1cmVUcmFuc2Zlcih7XG4gICAgICB0cmFuc2ZlcklkLFxuICAgICAgZmlsZU5hbWU6IChwLmZpbGVOYW1lIGFzIHN0cmluZykgfHwgJ2ZpbGUnLFxuICAgICAgbWltZVR5cGU6IChwLm1pbWVUeXBlIGFzIHN0cmluZykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICBmaWxlVHlwZSxcbiAgICAgIHNpemU6IChwLnNpemUgYXMgbnVtYmVyKSB8fCAwLFxuICAgICAgdG90YWxDaHVua3MsXG4gICAgICB0ZXh0OiAocC50ZXh0IGFzIHN0cmluZykgfHwgJycsXG4gICAgfSk7XG4gICAgYXdhaXQgc3RvcmVDaHVuayh0cmFuc2ZlcklkLCBjaHVua0luZGV4LCB0b3RhbENodW5rcywgZGF0YSk7XG4gICAgY29uc3QgZG9uZSA9IGF3YWl0IGlzVHJhbnNmZXJDb21wbGV0ZSh0cmFuc2ZlcklkKTtcbiAgICBpZiAoIWRvbmUpIHJldHVybjtcblxuICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHtcbiAgICAgIGlkOiBgJHtldmVudElkfS1hc3NlbWJsZWQtJHt0cmFuc2ZlcklkfWAsXG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgICBjb250ZW50OiAocC50ZXh0IGFzIHN0cmluZykgfHwgJycsXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBtc2dUeXBlOiBmaWxlVHlwZSxcbiAgICAgIHJlcGx5VG86IHAucmVwbHlUbyBhcyBSZXBseVJlZiB8IHVuZGVmaW5lZCxcbiAgICAgIGF0dGFjaG1lbnQ6IHtcbiAgICAgICAgdHlwZTogZmlsZVR5cGUsXG4gICAgICAgIG5hbWU6IChwLmZpbGVOYW1lIGFzIHN0cmluZykgfHwgJ2ZpbGUnLFxuICAgICAgICBtaW1lVHlwZTogKHAubWltZVR5cGUgYXMgc3RyaW5nKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgZGF0YTogJycsXG4gICAgICAgIHNpemU6IChwLnNpemUgYXMgbnVtYmVyKSB8fCAwLFxuICAgICAgICB0cmFuc2ZlcklkLFxuICAgICAgICB0b3RhbENodW5rcyxcbiAgICAgICAgY2h1bmtlZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVQcm9maWxlRXZlbnQoZXZlbnQ6IE5vc3RyRXZlbnQpIHtcbiAgICB0cnkgeyBjb25zdCBwID0gSlNPTi5wYXJzZShldmVudC5jb250ZW50KSBhcyBOb3N0clByb2ZpbGU7IHRoaXMucHJvZmlsZUNhY2hlLnNldChldmVudC5wdWJrZXksIHApOyB0aGlzLnBlbmRpbmdQcm9maWxlcy5kZWxldGUoZXZlbnQucHVia2V5KTsgdGhpcy5wcm9maWxlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IoZXZlbnQucHVia2V5LCBwKSk7IH0gY2F0Y2gge31cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ2hhbm5lbEV2ZW50KGV2ZW50OiBOb3N0ckV2ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpIGFzIHsgbmFtZT86IHN0cmluZzsgYWJvdXQ/OiBzdHJpbmcgfTtcbiAgICAgIGNvbnN0IGNoYW5uZWw6IENoYW5uZWwgPSB7XG4gICAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgICAgbmFtZTogcGF5bG9hZC5uYW1lPy50cmltKCkgfHwgYGNoYW5uZWwtJHtldmVudC5pZC5zbGljZSgwLCA4KX1gLFxuICAgICAgICBhYm91dDogcGF5bG9hZC5hYm91dCxcbiAgICAgICAgY3JlYXRlZEJ5OiBldmVudC5wdWJrZXksXG4gICAgICAgIGNyZWF0ZWRBdDogZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsXG4gICAgICB9O1xuICAgICAgdGhpcy5jaGFubmVsQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2IoY2hhbm5lbCkpO1xuICAgIH0gY2F0Y2gge31cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ2hhbm5lbE1lc3NhZ2VFdmVudChldmVudDogTm9zdHJFdmVudCkge1xuICAgIGNvbnN0IGVUYWcgPSBldmVudC50YWdzLmZpbmQodCA9PiB0WzBdID09PSAnZScpPy5bMV07XG4gICAgaWYgKCFlVGFnKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpIGFzIHsgdGV4dD86IHN0cmluZzsgcmVwbHlUbz86IFJlcGx5UmVmIH07XG4gICAgICB0aGlzLmNoYW5uZWxNZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2Ioe1xuICAgICAgICBpZDogZXZlbnQuaWQsXG4gICAgICAgIGZyb206IGV2ZW50LnB1YmtleSxcbiAgICAgICAgdG86ICcnLFxuICAgICAgICBjb250ZW50OiBwYXlsb2FkLnRleHQgfHwgJycsXG4gICAgICAgIHRpbWVzdGFtcDogZXZlbnQuY3JlYXRlZF9hdCAqIDEwMDAsXG4gICAgICAgIG1zZ1R5cGU6ICdjaGFubmVsJyxcbiAgICAgICAgY2hhbm5lbElkOiBlVGFnLFxuICAgICAgICByZXBseVRvOiBwYXlsb2FkLnJlcGx5VG8sXG4gICAgICB9KSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aGlzLmNoYW5uZWxNZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4gY2Ioe1xuICAgICAgICBpZDogZXZlbnQuaWQsXG4gICAgICAgIGZyb206IGV2ZW50LnB1YmtleSxcbiAgICAgICAgdG86ICcnLFxuICAgICAgICBjb250ZW50OiBldmVudC5jb250ZW50IHx8ICcnLFxuICAgICAgICB0aW1lc3RhbXA6IGV2ZW50LmNyZWF0ZWRfYXQgKiAxMDAwLFxuICAgICAgICBtc2dUeXBlOiAnY2hhbm5lbCcsXG4gICAgICAgIGNoYW5uZWxJZDogZVRhZyxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmliZVRvTWVzc2FnZXMocmVsYXlVcmw6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5fcGspIHJldHVybjtcbiAgICBjb25zdCB3cyA9IHRoaXMuc29ja2V0cy5nZXQocmVsYXlVcmwpOyBpZiAoIXdzIHx8IHdzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSByZXR1cm47XG4gICAgY29uc3Qgc3ViSWQgPSAnZG0tJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDgpO1xuICAgIGNvbnN0IHNpbmNlID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgLSA4NjQwMCAqIDMwO1xuICAgIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkoWydSRVEnLCBzdWJJZCwgeyBraW5kczogWzRdLCAnI3AnOiBbdGhpcy5fcGtdLCBzaW5jZSB9LCB7IGtpbmRzOiBbNF0sIGF1dGhvcnM6IFt0aGlzLl9wa10sIHNpbmNlIH1dKSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWJJZCwgeyBmaWx0ZXJzOiBbXSwgcmVsYXk6IHJlbGF5VXJsIH0pO1xuICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVscyhyZWxheVVybCk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmliZVRvQ2hhbm5lbHMocmVsYXlVcmw6IHN0cmluZykge1xuICAgIGNvbnN0IHdzID0gdGhpcy5zb2NrZXRzLmdldChyZWxheVVybCk7XG4gICAgaWYgKCF3cyB8fCB3cy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9jaGFubmVscy5sZW5ndGggPT09IDApIHJldHVybjsgLy8gRG8gbm90IHN1YnNjcmliZSB0byBnbG9iYWwgY2hhbm5lbHNcblxuICAgIGNvbnN0IHN1YklkID0gJ2NoLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCA4KTtcbiAgICBjb25zdCBzaW5jZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gODY0MDAgKiAzMDtcblxuICAgIC8vIE9ubHkgc3Vic2NyaWJlIHRvIGNoYW5uZWxzIHRoZSB1c2VyIGhhcyBqb2luZWRcbiAgICB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KFsnUkVRJywgc3ViSWQsIHsga2luZHM6IFs0MF0sIGlkczogdGhpcy5fY2hhbm5lbHMsIHNpbmNlIH0sIHsga2luZHM6IFs0Ml0sICcjZSc6IHRoaXMuX2NoYW5uZWxzLCBzaW5jZSB9XSkpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoc3ViSWQsIHsgZmlsdGVyczogW10sIHJlbGF5OiByZWxheVVybCB9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRFbmNyeXB0ZWRQYXlsb2FkKHJlY2lwaWVudFB1YmtleTogc3RyaW5nLCBwYXlsb2FkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5fc2spIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhvcml6ZWQnKTtcbiAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBlbmNyeXB0KHRoaXMuX3NrLCByZWNpcGllbnRQdWJrZXksIHBheWxvYWQpO1xuICAgIGNvbnN0IGV2OiBVbnNpZ25lZEV2ZW50ID0geyBraW5kOiA0LCBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSwgdGFnczogW1sncCcsIHJlY2lwaWVudFB1YmtleV1dLCBjb250ZW50OiBlbmNyeXB0ZWQsIHB1YmtleTogdGhpcy5fcGsgfTtcbiAgICBjb25zdCBldmVudCA9IGZpbmFsaXplRXZlbnQoZXYsIHRoaXMuX3NrKTtcbiAgICB0aGlzLnNlZW5FdmVudHMuYWRkKGV2ZW50LmlkKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoWydFVkVOVCcsIGV2ZW50XSk7XG4gICAgY29uc3Qgb3BlbjogV2ViU29ja2V0W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFssIHdzXSBvZiB0aGlzLnNvY2tldHMpIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgb3Blbi5wdXNoKHdzKTtcbiAgICBpZiAoIW9wZW4ubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbm5lY3RlZCByZWxheXMnKTtcbiAgICBvcGVuLmZvckVhY2god3MgPT4geyB0cnkgeyB3cy5zZW5kKGpzb24pOyB9IGNhdGNoIHt9IH0pO1xuICAgIHJldHVybiBldmVudC5pZDtcbiAgfVxuXG4gIHByaXZhdGUgYnl0ZXNUb0Jhc2U2NChieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgbGV0IGJpbiA9ICcnO1xuICAgIGNvbnN0IHN0ZXAgPSAweDgwMDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgYmluICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYnl0ZXMuc3ViYXJyYXkoaSwgaSArIHN0ZXApKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluKTtcbiAgfVxuXG4gIGFzeW5jIHNlbmREaXJlY3RNZXNzYWdlKHJlY2lwaWVudFB1YmtleTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIHJlcGx5VG8/OiBSZXBseVJlZik6IFByb21pc2U8RGlyZWN0TWVzc2FnZT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSByZXBseVRvID8gSlNPTi5zdHJpbmdpZnkoeyBfbm9zdHJfbXNnX3R5cGU6ICd0ZXh0JywgdGV4dDogY29udGVudCwgcmVwbHlUbyB9KSA6IGNvbnRlbnQ7XG4gICAgY29uc3QgaWQgPSBhd2FpdCB0aGlzLnNlbmRFbmNyeXB0ZWRQYXlsb2FkKHJlY2lwaWVudFB1YmtleSwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHsgaWQsIGZyb206IHRoaXMuX3BrLCB0bzogcmVjaXBpZW50UHVia2V5LCBjb250ZW50LCB0aW1lc3RhbXA6IERhdGUubm93KCksIG1zZ1R5cGU6ICd0ZXh0JywgcmVwbHlUbyB9O1xuICB9XG5cbiAgLy8gMjU2S0IgY2h1bmtzLCBwYXJhbGxlbCBzZW5kIGJ5IDNcbiAgcHJpdmF0ZSBzdGF0aWMgQ0hVTktfU0laRSA9IDI2MjE0NDtcbiAgcHJpdmF0ZSBzdGF0aWMgUEFSQUxMRUwgPSAzO1xuXG4gIGFzeW5jIHNlbmRBdHRhY2htZW50KFxuICAgIHJlY2lwaWVudFB1YmtleTogc3RyaW5nLFxuICAgIGF0dGFjaG1lbnQ6IEF0dGFjaG1lbnQsXG4gICAgdGV4dD86IHN0cmluZyxcbiAgICBvblByb2dyZXNzPzogKHNlbnQ6IG51bWJlciwgdG90YWw6IG51bWJlcikgPT4gdm9pZCxcbiAgICByZXBseVRvPzogUmVwbHlSZWYsXG4gICk6IFByb21pc2U8RGlyZWN0TWVzc2FnZT4ge1xuICAgIGNvbnN0IG1heFNpemUgPSAyICogMTAyNCAqIDEwMjQgKiAxMDI0O1xuICAgIGlmIChhdHRhY2htZW50LnNpemUgPiBtYXhTaXplKSB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgaXMgdG9vIGxhcmdlLiBNYXggc2l6ZSBpcyAyR0IuJyk7XG5cbiAgICBpZiAoIWF0dGFjaG1lbnQuZmlsZSkge1xuICAgICAgY29uc3QgYjY0ID0gYXR0YWNobWVudC5kYXRhO1xuICAgICAgaWYgKGI2NC5sZW5ndGggPCA0MDAwMCkge1xuICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMuc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgX25vc3RyX21zZ190eXBlOiBhdHRhY2htZW50LnR5cGUsXG4gICAgICAgICAgZmlsZU5hbWU6IGF0dGFjaG1lbnQubmFtZSxcbiAgICAgICAgICBtaW1lVHlwZTogYXR0YWNobWVudC5taW1lVHlwZSxcbiAgICAgICAgICBkYXRhOiBiNjQsXG4gICAgICAgICAgc2l6ZTogYXR0YWNobWVudC5zaXplLFxuICAgICAgICAgIHRleHQ6IHRleHQgfHwgJycsXG4gICAgICAgICAgcmVwbHlUbyxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4geyBpZCwgZnJvbTogdGhpcy5fcGssIHRvOiByZWNpcGllbnRQdWJrZXksIGNvbnRlbnQ6IHRleHQgfHwgJycsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSwgbXNnVHlwZTogYXR0YWNobWVudC50eXBlLCBhdHRhY2htZW50LCByZXBseVRvIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZSA9IGF0dGFjaG1lbnQuZmlsZTtcbiAgICBjb25zdCB0cmFuc2ZlcklkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbiAgICBjb25zdCBmaWxlU2l6ZSA9IGZpbGUgPyBmaWxlLnNpemUgOiBhdHRhY2htZW50LnNpemU7XG4gICAgY29uc3QgdG90YWxDaHVua3MgPSBNYXRoLmNlaWwoZmlsZVNpemUgLyBOb3N0ckNsaWVudC5DSFVOS19TSVpFKTtcbiAgICBsZXQgbGFzdElkID0gJyc7XG4gICAgbGV0IHNlbnQgPSAwO1xuXG4gICAgYXdhaXQgZW5zdXJlVHJhbnNmZXIoe1xuICAgICAgICB0cmFuc2ZlcklkLFxuICAgICAgICBmaWxlTmFtZTogYXR0YWNobWVudC5uYW1lLFxuICAgICAgICBtaW1lVHlwZTogYXR0YWNobWVudC5taW1lVHlwZSxcbiAgICAgICAgZmlsZVR5cGU6IGF0dGFjaG1lbnQudHlwZSxcbiAgICAgICAgc2l6ZTogZmlsZVNpemUsXG4gICAgICAgIHRvdGFsQ2h1bmtzLFxuICAgICAgICB0ZXh0OiB0ZXh0IHx8ICcnLFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5zZW5kRW5jcnlwdGVkUGF5bG9hZChyZWNpcGllbnRQdWJrZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIF9ub3N0cl9tc2dfdHlwZTogJ2ZpbGUtbWV0YScsXG4gICAgICB0cmFuc2ZlcklkLFxuICAgICAgdG90YWxDaHVua3MsXG4gICAgICBmaWxlTmFtZTogYXR0YWNobWVudC5uYW1lLFxuICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQubWltZVR5cGUsXG4gICAgICBzaXplOiBmaWxlU2l6ZSxcbiAgICAgIHRleHQ6IHRleHQgfHwgJycsXG4gICAgICBmaWxlVHlwZTogYXR0YWNobWVudC50eXBlLFxuICAgICAgcmVwbHlUbyxcbiAgICB9KSk7XG5cbiAgICBmb3IgKGxldCBiYXRjaCA9IDA7IGJhdGNoIDwgdG90YWxDaHVua3M7IGJhdGNoICs9IE5vc3RyQ2xpZW50LlBBUkFMTEVMKSB7XG4gICAgICBjb25zdCBwcm9taXNlczogUHJvbWlzZTxzdHJpbmc+W10gPSBbXTtcbiAgICAgIGNvbnN0IGxvY2FsQ2h1bmtzOiB7aTogbnVtYmVyLCBkYXRhOiBzdHJpbmd9W10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOb3N0ckNsaWVudC5QQVJBTExFTCAmJiBiYXRjaCArIGogPCB0b3RhbENodW5rczsgaisrKSB7XG4gICAgICAgIGNvbnN0IGkgPSBiYXRjaCArIGo7XG4gICAgICAgIGxldCBjaHVua0RhdGE6IHN0cmluZztcblxuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSAqIE5vc3RyQ2xpZW50LkNIVU5LX1NJWkU7XG4gICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBOb3N0ckNsaWVudC5DSFVOS19TSVpFLCBmaWxlU2l6ZSk7XG4gICAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhd2FpdCBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpLmFycmF5QnVmZmVyKCkpO1xuICAgICAgICAgIGNodW5rRGF0YSA9IHRoaXMuYnl0ZXNUb0Jhc2U2NChieXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYmFzZTY0Q2h1bmtTaXplID0gTWF0aC5mbG9vcigoTm9zdHJDbGllbnQuQ0hVTktfU0laRSAvIDMpICogNCk7XG4gICAgICAgICAgY2h1bmtEYXRhID0gYXR0YWNobWVudC5kYXRhLnNsaWNlKGkgKiBiYXNlNjRDaHVua1NpemUsIChpICsgMSkgKiBiYXNlNjRDaHVua1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsb2NhbENodW5rcy5wdXNoKHtpLCBkYXRhOiBjaHVua0RhdGF9KTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBfbm9zdHJfbXNnX3R5cGU6ICdmaWxlLWNodW5rJyxcbiAgICAgICAgICAgIHRyYW5zZmVySWQsXG4gICAgICAgICAgICBjaHVua0luZGV4OiBpLFxuICAgICAgICAgICAgdG90YWxDaHVua3MsXG4gICAgICAgICAgICBkYXRhOiBjaHVua0RhdGEsXG4gICAgICAgICAgICBmaWxlTmFtZTogYXR0YWNobWVudC5uYW1lLFxuICAgICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQubWltZVR5cGUsXG4gICAgICAgICAgICBzaXplOiBmaWxlU2l6ZSxcbiAgICAgICAgICAgIHRleHQ6IHRleHQgfHwgJycsXG4gICAgICAgICAgICBmaWxlVHlwZTogYXR0YWNobWVudC50eXBlLFxuICAgICAgICAgICAgcmVwbHlUbyxcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGxhc3RJZCA9IGlkc1tpZHMubGVuZ3RoIC0gMV0gfHwgbGFzdElkO1xuXG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGxvY2FsQ2h1bmtzKSB7XG4gICAgICAgICAgYXdhaXQgc3RvcmVDaHVuayh0cmFuc2ZlcklkLCBjaHVuay5pLCB0b3RhbENodW5rcywgY2h1bmsuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHNlbnQgKz0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgb25Qcm9ncmVzcz8uKHNlbnQsIHRvdGFsQ2h1bmtzKTtcbiAgICAgIGlmIChzZW50IDwgdG90YWxDaHVua3MpIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCA1MCkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpZDogbGFzdElkIHx8IGBsb2NhbC0ke3RyYW5zZmVySWR9YCxcbiAgICAgIGZyb206IHRoaXMuX3BrLFxuICAgICAgdG86IHJlY2lwaWVudFB1YmtleSxcbiAgICAgIGNvbnRlbnQ6IHRleHQgfHwgJycsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBtc2dUeXBlOiBhdHRhY2htZW50LnR5cGUsXG4gICAgICByZXBseVRvLFxuICAgICAgYXR0YWNobWVudDoge1xuICAgICAgICAuLi5hdHRhY2htZW50LFxuICAgICAgICBkYXRhOiBhdHRhY2htZW50LmZpbGUgPyAnJyA6IGF0dGFjaG1lbnQuZGF0YSxcbiAgICAgICAgdHJhbnNmZXJJZCxcbiAgICAgICAgdG90YWxDaHVua3MsXG4gICAgICAgIGNodW5rZWQ6IHRydWUsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBzZW5kV2ViUlRDU2lnbmFsKHJlY2lwaWVudFB1YmtleTogc3RyaW5nLCBzaWduYWw6IFdlYlJUQ1NpZ25hbCkge1xuICAgIGF3YWl0IHRoaXMuc2VuZEVuY3J5cHRlZFBheWxvYWQocmVjaXBpZW50UHVia2V5LCBKU09OLnN0cmluZ2lmeSh7IF9ub3N0cl9tc2dfdHlwZTogc2lnbmFsLnR5cGUsIHNkcDogc2lnbmFsLnNkcCwgY2FuZGlkYXRlOiBzaWduYWwuY2FuZGlkYXRlLCBjYWxsVHlwZTogc2lnbmFsLmNhbGxUeXBlIH0pKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUNoYW5uZWwobmFtZTogc3RyaW5nLCBhYm91dD86IHN0cmluZyk6IFByb21pc2U8Q2hhbm5lbD4ge1xuICAgIGlmICghdGhpcy5fc2spIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhvcml6ZWQnKTtcbiAgICBjb25zdCBldjogVW5zaWduZWRFdmVudCA9IHtcbiAgICAgIGtpbmQ6IDQwLFxuICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICB0YWdzOiBbXSxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHsgbmFtZSwgYWJvdXQ6IGFib3V0IHx8ICcnIH0pLFxuICAgICAgcHVia2V5OiB0aGlzLl9wayxcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50ID0gZmluYWxpemVFdmVudChldiwgdGhpcy5fc2spO1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShbJ0VWRU5UJywgZXZlbnRdKTtcbiAgICBmb3IgKGNvbnN0IFssIHdzXSBvZiB0aGlzLnNvY2tldHMpIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgdHJ5IHsgd3Muc2VuZChwYXlsb2FkKTsgfSBjYXRjaCB7fVxuICAgIGNvbnN0IGNoYW5uZWw6IENoYW5uZWwgPSB7IGlkOiBldmVudC5pZCwgbmFtZSwgYWJvdXQsIGNyZWF0ZWRCeTogdGhpcy5fcGssIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSB9O1xuICAgIHRoaXMuY2hhbm5lbENhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKGNoYW5uZWwpKTtcbiAgICByZXR1cm4gY2hhbm5lbDtcbiAgfVxuXG4gIGFzeW5jIHNlbmRDaGFubmVsTWVzc2FnZShjaGFubmVsSWQ6IHN0cmluZywgdGV4dDogc3RyaW5nLCByZXBseVRvPzogUmVwbHlSZWYpOiBQcm9taXNlPERpcmVjdE1lc3NhZ2U+IHtcbiAgICBpZiAoIXRoaXMuX3NrKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRob3JpemVkJyk7XG4gICAgY29uc3QgZXY6IFVuc2lnbmVkRXZlbnQgPSB7XG4gICAgICBraW5kOiA0MixcbiAgICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgdGFnczogW1snZScsIGNoYW5uZWxJZCwgJycsICdyb290J11dLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoeyB0ZXh0LCByZXBseVRvIH0pLFxuICAgICAgcHVia2V5OiB0aGlzLl9wayxcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50ID0gZmluYWxpemVFdmVudChldiwgdGhpcy5fc2spO1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShbJ0VWRU5UJywgZXZlbnRdKTtcbiAgICBsZXQgc2VudCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgWywgd3NdIG9mIHRoaXMuc29ja2V0cykge1xuICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSBjb250aW51ZTtcbiAgICAgIHNlbnQgPSB0cnVlO1xuICAgICAgdHJ5IHsgd3Muc2VuZChwYXlsb2FkKTsgfSBjYXRjaCB7fVxuICAgIH1cbiAgICBpZiAoIXNlbnQpIHRocm93IG5ldyBFcnJvcignTm8gY29ubmVjdGVkIHJlbGF5cycpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogZXZlbnQuaWQsXG4gICAgICBmcm9tOiB0aGlzLl9wayxcbiAgICAgIHRvOiAnJyxcbiAgICAgIGNvbnRlbnQ6IHRleHQsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBtc2dUeXBlOiAnY2hhbm5lbCcsXG4gICAgICBjaGFubmVsSWQsXG4gICAgICByZXBseVRvLFxuICAgIH07XG4gIH1cblxuICByZXF1ZXN0UHJvZmlsZShwdWJrZXk6IHN0cmluZyk6IE5vc3RyUHJvZmlsZSB8IG51bGwge1xuICAgIGlmICh0aGlzLnByb2ZpbGVDYWNoZS5oYXMocHVia2V5KSkgcmV0dXJuIHRoaXMucHJvZmlsZUNhY2hlLmdldChwdWJrZXkpITtcbiAgICBpZiAodGhpcy5wZW5kaW5nUHJvZmlsZXMuaGFzKHB1YmtleSkpIHJldHVybiBudWxsO1xuICAgIHRoaXMucGVuZGluZ1Byb2ZpbGVzLmFkZChwdWJrZXkpO1xuICAgIGNvbnN0IHN1YklkID0gJ3AtJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDgpO1xuICAgIGZvciAoY29uc3QgWywgd3NdIG9mIHRoaXMuc29ja2V0cykgeyBpZiAod3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHsgd3Muc2VuZChKU09OLnN0cmluZ2lmeShbJ1JFUScsIHN1YklkLCB7IGtpbmRzOiBbMF0sIGF1dGhvcnM6IFtwdWJrZXldLCBsaW1pdDogMSB9XSkpOyBicmVhazsgfSB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRQcm9maWxlKHB1YmtleTogc3RyaW5nKSB7IHJldHVybiB0aGlzLnByb2ZpbGVDYWNoZS5nZXQocHVia2V5KSB8fCBudWxsOyB9XG5cbiAgYXN5bmMgdXBkYXRlUHJvZmlsZShwcm9maWxlOiBOb3N0clByb2ZpbGUpIHtcbiAgICBpZiAoIXRoaXMuX3NrKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRob3JpemVkJyk7XG4gICAgY29uc3QgZXY6IFVuc2lnbmVkRXZlbnQgPSB7IGtpbmQ6IDAsIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLCB0YWdzOiBbXSwgY29udGVudDogSlNPTi5zdHJpbmdpZnkocHJvZmlsZSksIHB1YmtleTogdGhpcy5fcGsgfTtcbiAgICBjb25zdCBldmVudCA9IGZpbmFsaXplRXZlbnQoZXYsIHRoaXMuX3NrKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoWydFVkVOVCcsIGV2ZW50XSk7XG4gICAgZm9yIChjb25zdCBbLCB3c10gb2YgdGhpcy5zb2NrZXRzKSBpZiAod3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHRyeSB7IHdzLnNlbmQoanNvbik7IH0gY2F0Y2gge31cbiAgICB0aGlzLnByb2ZpbGVDYWNoZS5zZXQodGhpcy5fcGssIHByb2ZpbGUpO1xuICB9XG5cbiAgZGlzY29ubmVjdEFsbCgpIHtcbiAgICBmb3IgKGNvbnN0IFssIHRdIG9mIHRoaXMucmVjb25uZWN0VGltZXJzKSBjbGVhclRpbWVvdXQodCk7XG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lcnMuY2xlYXIoKTsgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgWywgd3NdIG9mIHRoaXMuc29ja2V0cykgd3MuY2xvc2UoKTtcbiAgICB0aGlzLnNvY2tldHMuY2xlYXIoKTsgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7IHRoaXMucmVsYXlTdGF0dXMuY2xlYXIoKTtcbiAgfVxuXG4gIGFkZFJlbGF5KHVybDogc3RyaW5nKSB7IGlmICghdGhpcy5fcmVsYXlzLmluY2x1ZGVzKHVybCkpIHsgdGhpcy5fcmVsYXlzLnB1c2godXJsKTsgdGhpcy5jb25uZWN0VG9SZWxheSh1cmwpOyB9IH1cbiAgcmVtb3ZlUmVsYXkodXJsOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9yZWxheXMgPSB0aGlzLl9yZWxheXMuZmlsdGVyKHIgPT4gciAhPT0gdXJsKTtcbiAgICBjb25zdCB0ID0gdGhpcy5yZWNvbm5lY3RUaW1lcnMuZ2V0KHVybCk7IGlmICh0KSB7IGNsZWFyVGltZW91dCh0KTsgdGhpcy5yZWNvbm5lY3RUaW1lcnMuZGVsZXRlKHVybCk7IH1cbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzLmRlbGV0ZSh1cmwpO1xuICAgIGNvbnN0IHdzID0gdGhpcy5zb2NrZXRzLmdldCh1cmwpOyBpZiAod3MpIHsgd3MuY2xvc2UoKTsgdGhpcy5zb2NrZXRzLmRlbGV0ZSh1cmwpOyB9XG4gICAgdGhpcy5yZWxheVN0YXR1cy5kZWxldGUodXJsKTtcbiAgfVxuXG4gIHNob3J0ZW5LZXkoa2V5OiBzdHJpbmcpIHsgcmV0dXJuICgha2V5IHx8IGtleS5sZW5ndGggPCAxNikgPyBrZXkgOiBrZXkuc2xpY2UoMCwgOCkgKyAn4oCmJyArIGtleS5zbGljZSgtOCk7IH1cbiAgaXNWYWxpZEhleEtleShrZXk6IHN0cmluZykgeyByZXR1cm4gL15bMC05YS1mQS1GXXs2NH0kLy50ZXN0KGtleSk7IH1cbn1cblxuZXhwb3J0IGNvbnN0IG5vc3RyQ2xpZW50ID0gbmV3IE5vc3RyQ2xpZW50KCk7XG5leHBvcnQgeyBERUZBVUxUX1JFTEFZUyB9O1xuIl0sIm5hbWVzIjpbImdlbmVyYXRlU2VjcmV0S2V5IiwiZ2V0UHVibGljS2V5IiwiZmluYWxpemVFdmVudCIsImVuY3J5cHQiLCJkZWNyeXB0IiwiYnl0ZXNUb0hleCIsImhleFRvQnl0ZXMiLCJlbnN1cmVUcmFuc2ZlciIsImlzVHJhbnNmZXJDb21wbGV0ZSIsInN0b3JlQ2h1bmsiLCJERUZBVUxUX1JFTEFZUyIsIk5vc3RyQ2xpZW50IiwicHVibGljS2V5IiwiX3BrIiwicHJpdmF0ZUtleUhleCIsIl9zayIsInJlbGF5cyIsIl9yZWxheXMiLCJjaGFubmVscyIsIl9jaGFubmVscyIsInNrIiwiZ2V0UmVsYXlTdGF0dXMiLCJyZWxheSIsInJlbGF5U3RhdHVzIiwiZ2V0IiwiY29ubmVjdGVkUmVsYXlDb3VudCIsImMiLCJmb3JFYWNoIiwicyIsImdlbmVyYXRlS2V5cyIsInBrIiwicHJpdmF0ZUtleSIsImxvZ2luIiwiX3N0b3BwZWQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwibG9nb3V0IiwiZGlzY29ubmVjdEFsbCIsInJlbW92ZUl0ZW0iLCJ0cnlBdXRvTG9naW4iLCJnZXRJdGVtIiwibGVuZ3RoIiwib25NZXNzYWdlIiwiY2IiLCJtZXNzYWdlQ2FsbGJhY2tzIiwiYWRkIiwiZGVsZXRlIiwib25DaGFubmVsIiwiY2hhbm5lbENhbGxiYWNrcyIsIm9uQ2hhbm5lbE1lc3NhZ2UiLCJjaGFubmVsTWVzc2FnZUNhbGxiYWNrcyIsIm9uUHJvZmlsZSIsInByb2ZpbGVDYWxsYmFja3MiLCJvbkNvbm5lY3Rpb24iLCJjb25uZWN0aW9uQ2FsbGJhY2tzIiwib25TaWduYWwiLCJzaWduYWxDYWxsYmFja3MiLCJjb25uZWN0VG9SZWxheXMiLCJyIiwiY29ubmVjdFRvUmVsYXkiLCJzZXRDaGFubmVscyIsImNoYW5uZWxJZHMiLCJTZXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwid3MiLCJzb2NrZXRzIiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJzdWJzY3JpYmVUb0NoYW5uZWxzIiwidXJsIiwiaGFzIiwiZSIsIkNPTk5FQ1RJTkciLCJzZXQiLCJjdCIsInNldFRpbWVvdXQiLCJjbG9zZSIsIm9ub3BlbiIsImNsZWFyVGltZW91dCIsInJlY29ubmVjdEF0dGVtcHRzIiwic3Vic2NyaWJlVG9NZXNzYWdlcyIsIm9uY2xvc2UiLCJzY2hlZHVsZVJlY29ubmVjdCIsIm9uZXJyb3IiLCJvbm1lc3NhZ2UiLCJoYW5kbGVSZWxheU1lc3NhZ2UiLCJKU09OIiwicGFyc2UiLCJkYXRhIiwicmVjb25uZWN0VGltZXJzIiwiYSIsImQiLCJNYXRoIiwibWluIiwicG93IiwiQXJyYXkiLCJpc0FycmF5IiwiZXYiLCJzZWVuRXZlbnRzIiwiaWQiLCJraW5kIiwiaGFuZGxlRW5jcnlwdGVkRE0iLCJoYW5kbGVQcm9maWxlRXZlbnQiLCJoYW5kbGVDaGFubmVsRXZlbnQiLCJoYW5kbGVDaGFubmVsTWVzc2FnZUV2ZW50IiwiZXZlbnQiLCJwVGFnIiwidGFncyIsImZpbmQiLCJ0IiwiaXNGb3JNZSIsImlzRnJvbU1lIiwicHVia2V5Iiwib3RoZXIiLCJkZWMiLCJjb250ZW50IiwicCIsIl9ub3N0cl9tc2dfdHlwZSIsIm10IiwiZnJvbSIsInRvIiwidGV4dCIsInRpbWVzdGFtcCIsImNyZWF0ZWRfYXQiLCJtc2dUeXBlIiwicmVwbHlUbyIsImluY2x1ZGVzIiwidHlwZSIsInNkcCIsImNhbmRpZGF0ZSIsImNhbGxUeXBlIiwiaGFuZGxlRmlsZUNodW5rIiwidHJhbnNmZXJJZCIsImZpbGVUeXBlIiwiZmlsZU5hbWUiLCJtaW1lVHlwZSIsInNpemUiLCJ0b3RhbENodW5rcyIsImF0dGFjaG1lbnQiLCJuYW1lIiwiZXZlbnRJZCIsImNodW5rSW5kZXgiLCJkb25lIiwiY2h1bmtlZCIsInByb2ZpbGVDYWNoZSIsInBlbmRpbmdQcm9maWxlcyIsInBheWxvYWQiLCJjaGFubmVsIiwidHJpbSIsInNsaWNlIiwiYWJvdXQiLCJjcmVhdGVkQnkiLCJjcmVhdGVkQXQiLCJlVGFnIiwiY2hhbm5lbElkIiwicmVsYXlVcmwiLCJzdWJJZCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2luY2UiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJzZW5kIiwic3RyaW5naWZ5Iiwia2luZHMiLCJhdXRob3JzIiwic3Vic2NyaXB0aW9ucyIsImZpbHRlcnMiLCJpZHMiLCJzZW5kRW5jcnlwdGVkUGF5bG9hZCIsInJlY2lwaWVudFB1YmtleSIsIkVycm9yIiwiZW5jcnlwdGVkIiwianNvbiIsIm9wZW4iLCJwdXNoIiwiYnl0ZXNUb0Jhc2U2NCIsImJ5dGVzIiwiYmluIiwic3RlcCIsImkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdWJhcnJheSIsImJ0b2EiLCJzZW5kRGlyZWN0TWVzc2FnZSIsInNlbmRBdHRhY2htZW50Iiwib25Qcm9ncmVzcyIsIm1heFNpemUiLCJmaWxlIiwiYjY0IiwiZmlsZVNpemUiLCJjZWlsIiwiQ0hVTktfU0laRSIsImxhc3RJZCIsInNlbnQiLCJiYXRjaCIsIlBBUkFMTEVMIiwicHJvbWlzZXMiLCJsb2NhbENodW5rcyIsImoiLCJjaHVua0RhdGEiLCJzdGFydCIsImVuZCIsIlVpbnQ4QXJyYXkiLCJhcnJheUJ1ZmZlciIsImJhc2U2NENodW5rU2l6ZSIsIlByb21pc2UiLCJhbGwiLCJjaHVuayIsInNlbmRXZWJSVENTaWduYWwiLCJzaWduYWwiLCJjcmVhdGVDaGFubmVsIiwic2VuZENoYW5uZWxNZXNzYWdlIiwicmVxdWVzdFByb2ZpbGUiLCJsaW1pdCIsImdldFByb2ZpbGUiLCJ1cGRhdGVQcm9maWxlIiwicHJvZmlsZSIsImNsZWFyIiwiYWRkUmVsYXkiLCJyZW1vdmVSZWxheSIsInNob3J0ZW5LZXkiLCJrZXkiLCJpc1ZhbGlkSGV4S2V5IiwidGVzdCIsIk1hcCIsIm5vc3RyQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/nostr.ts\n"));

/***/ })

});